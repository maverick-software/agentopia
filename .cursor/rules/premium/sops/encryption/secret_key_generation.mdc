---
description: Enterprise-grade secret key generation and management best practices with mandatory Supabase Vault integration for zero plain-text storage
globs: 
alwaysApply: false
---
# Secret Key Generation & Management Best Practices (Enterprise Edition)

## Overview

This document outlines the **mandatory enterprise-grade standards** for generating, managing, and storing secret keys in Agentopia projects. These guidelines ensure **zero plain-text storage**, complete audit trails, and full compliance with HIPAA, SOC 2, and ISO 27001 standards.

## üîê MANDATORY VAULT INTEGRATION

**CRITICAL REQUIREMENT**: All secret key management **MUST** use Supabase Vault integration. Plain-text storage is **STRICTLY FORBIDDEN**.

### Vault Integration Prerequisites

Before implementing any secret management:
1. ‚úÖ **Follow**: `@supabase_vault_encryption_protocol.mdc` completely
2. ‚úÖ **Implement**: VaultService class for all secret operations
3. ‚úÖ **Deploy**: `create_vault_secret()` and `vault_decrypt()` functions
4. ‚úÖ **Verify**: Zero plain-text storage compliance

## Secret Key Types and Purposes

| Key Type | Purpose | Typical Length | Storage Location | Security Level |
|----------|---------|----------------|------------------|----------------|
| API Keys | Authentication between services | 32+ bytes (64+ hex chars) | **Supabase Vault ONLY** | **ENTERPRISE** |
| OAuth Tokens | User/agent authentication | 32+ bytes (64+ hex chars) | **Supabase Vault ONLY** | **ENTERPRISE** |
| Refresh Tokens | Token renewal | 32+ bytes (64+ hex chars) | **Supabase Vault ONLY** | **ENTERPRISE** |
| Encryption Keys | Data encryption | 32 bytes (64 hex chars) | **Supabase Vault ONLY** | **ENTERPRISE** |
| Service Credentials | Database/service access | Variable | **Supabase Vault ONLY** | **ENTERPRISE** |
| Session Tokens | Temporary user sessions | 16+ bytes (32+ hex chars) | **Redis/Database (encrypted)** | **STANDARD** |

## Generation Methods

### Node.js

```javascript
// For hex output (preferred for most API keys, secrets)
const crypto = require('crypto');
const secretKey = crypto.randomBytes(32).toString('hex');
// Output: 64 character hex string

// For URL-safe base64
const urlSafeKey = crypto.randomBytes(32).toString('base64url');
```

### Command Line

```bash
# Using Node.js
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

# Using OpenSSL (if available)
openssl rand -hex 32

# Using PowerShell
$bytes = New-Object byte[] 32
[System.Security.Cryptography.RNGCryptoServiceProvider]::Create().GetBytes($bytes)
[System.BitConverter]::ToString($bytes).Replace('-', '').ToLower()
```

## Enterprise Implementation Rules (MANDATORY)

### üö´ ABSOLUTE FORBIDDENS

1. **NEVER store secrets in plain text** - Zero exceptions, zero fallbacks
2. **NEVER hardcode secret keys in source code** - All secrets must use Supabase Vault
3. **NEVER use client-side vault access** - Vault operations are server-side only
4. **NEVER bypass vault encryption** - No "temporary" plain-text storage

### ‚úÖ MANDATORY REQUIREMENTS

1. **Use Supabase Vault for ALL secrets**
   ```typescript
   // ‚úÖ REQUIRED PATTERN
   const { data: vaultId } = await supabase.rpc('create_vault_secret', {
     p_secret: secretValue,
     p_name: `${provider}_${type}_${userId}_${timestamp}`,
     p_description: `${provider} ${type} for user ${userId}`
   });
   ```

2. **Cryptographically secure key generation**
   - Node.js: `crypto.randomBytes(32).toString('hex')` (minimum)
   - Minimum 32 bytes (64 hex chars) for all security-critical keys
   - Use `VaultService.generateSecretName()` for standardized naming

3. **Implement mandatory key rotation**
   - API keys: 90-day maximum rotation cycle
   - OAuth tokens: Refresh token rotation on each use
   - Service credentials: 60-day maximum rotation cycle
   - Emergency rotation procedures documented

4. **Complete audit trail logging**
   - Log all vault operations (creation, access, rotation)
   - Never log actual secret values
   - Include user ID, timestamp, operation type, and secret identifier
   - Tamper-evident audit log storage

5. **Enterprise access controls**
   - Service role only for vault operations
   - Role-based access control (RBAC) implementation
   - Principle of least privilege enforcement
   - Regular access reviews and certifications

## Enterprise Storage Guidelines (MANDATORY)

### üéØ PRIMARY STORAGE METHOD: Supabase Vault

**ALL sensitive credentials MUST use Supabase Vault - no exceptions**

#### 1. **Supabase Vault (MANDATORY for all secrets)**
```typescript
// ‚úÖ ENTERPRISE PATTERN: VaultService usage
import { VaultService } from '@/services/VaultService';

const vaultService = new VaultService(supabase);

// Create vault secret with standardized naming
const secretName = VaultService.generateSecretName('openai', 'api_key', userId);
const description = VaultService.generateSecretDescription('OpenAI', 'API key', userId);

const vaultId = await vaultService.createSecret(secretName, secretValue, description);
```

#### 2. **Database Integration (Vault UUIDs only)**
```sql
-- ‚úÖ SECURE: Store only vault UUIDs
INSERT INTO user_integration_credentials (
  vault_access_token_id,     -- Vault UUID only
  encrypted_access_token,    -- ALWAYS NULL (deprecated)
  credential_type,
  user_id
) VALUES (
  '550e8400-e29b-41d4-a716-446655440000',  -- Vault UUID
  NULL,                                      -- Never store plain text
  'api_key',
  'user123'
);
```

#### 3. **Environment Variables (Non-sensitive configuration only)**
```bash
# ‚úÖ ALLOWED: Non-sensitive configuration
VITE_SUPABASE_URL=https://your-project.supabase.co
NODE_ENV=production
API_VERSION=v1

# ‚ùå FORBIDDEN: Sensitive data in environment variables
# OPENAI_API_KEY=sk-abc123...  # Use Vault instead
# DATABASE_PASSWORD=secret123   # Use Vault instead
```

#### 4. **Server-Side Retrieval Pattern**
```typescript
// ‚úÖ ENTERPRISE: Server-side vault access only
export default async function handler(req: Request) {
  const supabase = createClient(url, SERVICE_ROLE_KEY); // Service role required
  
  // Get vault UUID from database
  const { data: connection } = await supabase
    .from('user_integration_credentials')
    .select('vault_access_token_id')
    .eq('id', connectionId)
    .single();
    
  // Decrypt secret from vault (server-side only)
  const { data: decryptedToken } = await supabase.rpc('vault_decrypt', {
    vault_id: connection.vault_access_token_id
  });
  
  // Use decrypted secret for API call
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    headers: { 'Authorization': `Bearer ${decryptedToken}` }
  });
}
```

## Enterprise Implementation Examples

### 1. Generating and Storing API Keys (ENTERPRISE)

```typescript
// ‚úÖ ENTERPRISE PATTERN: Complete API key management
import { VaultService } from '@/services/VaultService';
import { createClient } from '@supabase/supabase-js';

async function createApiKeyIntegration(userId: string, provider: string, apiKey: string) {
  const supabase = createClient(url, serviceRoleKey);
  const vaultService = new VaultService(supabase);
  
  try {
    // 1. Generate secure secret name
    const secretName = VaultService.generateSecretName(provider, 'api_key', userId);
    const description = VaultService.generateSecretDescription(provider, 'API key', userId);
    
    // 2. Create vault secret
    const vaultId = await vaultService.createSecret(secretName, apiKey, description);
    console.log(`‚úÖ API key securely vaulted: ${vaultId}`);
    
    // 3. Store vault UUID in database (never plain text)
    const { data, error } = await supabase
      .from('user_integration_credentials')
      .insert({
        user_id: userId,
        vault_access_token_id: vaultId,      // ‚úÖ Vault UUID only
        encrypted_access_token: null,        // ‚úÖ Never store plain text
        credential_type: 'api_key',
        connection_name: `${provider} API Key`,
        connection_status: 'active'
      })
      .select()
      .single();
      
    if (error) throw new Error(`Database error: ${error.message}`);
    
    return { success: true, connectionId: data.id };
    
  } catch (error) {
    console.error('‚ùå Failed to create secure API key:', error);
    throw error;
  }
}
```

### 2. OAuth Token Storage (ENTERPRISE)

```typescript
// ‚úÖ ENTERPRISE PATTERN: OAuth token management
async function storeOAuthTokens(userId: string, provider: string, tokens: {
  access_token: string;
  refresh_token: string;
  expires_at?: number;
}) {
  const supabase = createClient(url, serviceRoleKey);
  const vaultService = new VaultService(supabase);
  
  // Create vault secrets for both tokens
  const [accessVaultId, refreshVaultId] = await Promise.all([
    vaultService.createSecret(
      VaultService.generateSecretName(provider, 'access_token', userId),
      tokens.access_token,
      VaultService.generateSecretDescription(provider, 'access token', userId)
    ),
    vaultService.createSecret(
      VaultService.generateSecretName(provider, 'refresh_token', userId),
      tokens.refresh_token,
      VaultService.generateSecretDescription(provider, 'refresh token', userId)
    )
  ]);
  
  // Store vault UUIDs only
  await supabase.from('user_integration_credentials').insert({
    user_id: userId,
    vault_access_token_id: accessVaultId,    // ‚úÖ Vault UUID
    vault_refresh_token_id: refreshVaultId,  // ‚úÖ Vault UUID
    encrypted_access_token: null,            // ‚úÖ Never store plain text
    encrypted_refresh_token: null,           // ‚úÖ Never store plain text
    credential_type: 'oauth',
    token_expires_at: tokens.expires_at ? new Date(tokens.expires_at * 1000) : null
  });
}
```

### 3. Secure API Authentication Middleware (ENTERPRISE)

```typescript
// ‚úÖ ENTERPRISE PATTERN: Server-side secret verification
async function authenticateWithStoredCredentials(connectionId: string) {
  const supabase = createClient(url, serviceRoleKey); // Service role required
  
  try {
    // 1. Get vault UUID from database
    const { data: connection, error: fetchError } = await supabase
      .from('user_integration_credentials')
      .select('vault_access_token_id, credential_type, connection_status')
      .eq('id', connectionId)
      .eq('connection_status', 'active')
      .single();
      
    if (fetchError || !connection) {
      throw new Error('Invalid or inactive connection');
    }
    
    // 2. Decrypt secret from vault (server-side only)
    const { data: apiKey, error: decryptError } = await supabase.rpc('vault_decrypt', {
      vault_id: connection.vault_access_token_id
    });
    
    if (decryptError || !apiKey) {
      throw new Error('Failed to decrypt API key from vault');
    }
    
    // 3. Use decrypted key for authentication
    return {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    };
    
  } catch (error) {
    console.error('‚ùå Authentication failed:', error);
    throw new Error('Authentication failed - check vault configuration');
  }
}
```

### 4. Key Rotation Implementation (ENTERPRISE)

```typescript
// ‚úÖ ENTERPRISE PATTERN: Automated key rotation
async function rotateApiKey(connectionId: string, newApiKey: string) {
  const supabase = createClient(url, serviceRoleKey);
  const vaultService = new VaultService(supabase);
  
  // 1. Get existing connection
  const { data: connection } = await supabase
    .from('user_integration_credentials')
    .select('*')
    .eq('id', connectionId)
    .single();
    
  // 2. Create new vault secret
  const newSecretName = VaultService.generateSecretName(
    'rotated', 'api_key', connection.user_id
  );
  const newVaultId = await vaultService.createSecret(
    newSecretName, newApiKey, `Rotated API key - ${new Date().toISOString()}`
  );
  
  // 3. Update connection with new vault ID
  await supabase
    .from('user_integration_credentials')
    .update({
      vault_access_token_id: newVaultId,
      last_token_refresh: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })
    .eq('id', connectionId);
    
  // 4. Old vault secret automatically handled by Supabase Vault lifecycle
  console.log(`‚úÖ API key rotated successfully: ${newVaultId}`);
}
```

## Enterprise Security Considerations (MANDATORY)

### üîê **Primary Security Requirements**

1. **Vault-Only Storage (ABSOLUTE REQUIREMENT)**
   - **Zero plain-text storage** - All sensitive data must be vault-encrypted
   - **No temporary plain-text** - Even during processing, use secure memory
   - **No client-side vault access** - Vault operations restricted to service role
   - **Automated compliance scanning** - Regular verification of vault-only storage

2. **Transport Security (ENHANCED)**
   - **TLS 1.3 minimum** for all secret transmission
   - **Certificate pinning** for critical API communications
   - **End-to-end encryption** for vault operations
   - **Never transmit secrets** via email, chat, logs, or error messages

3. **Access Controls (ENTERPRISE-GRADE)**
   - **Service role only** for vault decryption operations
   - **Role-based access control (RBAC)** with principle of least privilege
   - **Multi-factor authentication** for vault administration
   - **Time-limited access tokens** with automatic expiration
   - **Just-in-time (JIT) access** for sensitive operations

4. **Comprehensive Audit Trail (SOC 2 COMPLIANT)**
   - **Complete logging** of all vault operations (create, read, update, rotate)
   - **Tamper-evident audit logs** with cryptographic integrity
   - **Real-time monitoring** and anomaly detection
   - **Automated alerting** for suspicious vault access patterns
   - **Regular audit reviews** and compliance reporting

5. **Key Lifecycle Management (ENTERPRISE)**
   - **Mandatory key rotation** schedules (90 days for API keys, 60 days for service credentials)
   - **Emergency rotation procedures** for compromised credentials
   - **Automated rotation workflows** with zero downtime
   - **Version tracking** for key rotation history
   - **Secure key disposal** following enterprise guidelines

### üö® **Security Incident Response**

#### Immediate Response (0-4 hours)
1. **Credential Compromise**: Immediately rotate affected vault secrets
2. **Access Anomaly**: Disable affected user/service accounts
3. **Vault Breach**: Initiate emergency key rotation for all affected secrets
4. **Data Exposure**: Execute data breach notification procedures

#### Investigation Phase (4-24 hours)
1. **Audit Log Analysis**: Review complete vault operation audit trail
2. **Impact Assessment**: Determine scope of potentially affected credentials
3. **Root Cause Analysis**: Identify security control failures
4. **Evidence Collection**: Preserve forensic evidence for analysis

#### Recovery Phase (24-72 hours)
1. **System Hardening**: Implement additional security controls
2. **Credential Re-encryption**: Re-vault all potentially compromised secrets
3. **Access Review**: Validate all vault permissions and access patterns
4. **Monitoring Enhancement**: Deploy additional detection capabilities

### üìä **Compliance Monitoring**

#### Automated Security Checks
```sql
-- Daily vault security verification
SELECT 
  'SECURITY_ALERT' as alert_type,
  COUNT(*) as violation_count,
  'Plain text credentials detected' as message
FROM user_integration_credentials
WHERE encrypted_access_token IS NOT NULL 
   OR encrypted_refresh_token IS NOT NULL;
```

#### Key Performance Indicators (KPIs)
- **Vault Adoption Rate**: 100% (mandatory)
- **Key Rotation Compliance**: >95% within scheduled timeframes
- **Security Incident Response Time**: <2 hours for credential compromise
- **Audit Compliance Score**: >98% for all vault operations
- **Access Control Violations**: 0 per quarter (zero tolerance)

### üõ°Ô∏è **Defense in Depth Strategy**

1. **Perimeter Security**: Network-level access controls and monitoring
2. **Application Security**: Input validation and secure coding practices
3. **Data Security**: Vault encryption for all sensitive data
4. **Access Security**: Multi-layered authentication and authorization
5. **Monitoring Security**: Real-time threat detection and response
6. **Physical Security**: Cloud infrastructure security assessments
7. **Personnel Security**: Background checks and security training

This enterprise-grade approach ensures **military-level security** for all sensitive credentials while maintaining compliance with the highest industry standards (HIPAA, SOC 2, ISO 27001).

