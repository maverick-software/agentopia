---
description: Comprehensive protocol for implementing enterprise-grade secrets management using Supabase Vault with zero plain-text storage
globs: 
alwaysApply: false
---

# Supabase Vault Encryption Protocol

## Overview

This protocol establishes the **mandatory standards** for implementing secure secrets management using Supabase Vault in any system. Following this protocol ensures **enterprise-grade security** with **zero plain-text storage** of sensitive credentials, complete audit trails, and compliance with industry standards (HIPAA, SOC 2, ISO 27001).

## Core Principles

### 1. **Zero Plain-Text Policy** (MANDATORY)
- **No sensitive data** shall ever be stored in plain text in any database table
- All API keys, OAuth tokens, passwords, and credentials **must** be encrypted in Supabase Vault
- Database tables **must** store only vault UUIDs, never actual secrets
- **Legacy plain-text columns shall be deprecated** and set to NULL

### 2. **Centralized Vault Architecture**
- **Single source of truth**: All secrets managed through one centralized system
- **Unified table structure**: One table for all integration credentials
- **Standardized naming**: Consistent vault secret naming conventions
- **Server-side only**: Vault operations restricted to service role

### 3. **Defense in Depth Security**
- **Encryption at rest**: AES encryption for all vault secrets
- **Access controls**: Role-based access with service role restrictions
- **Audit trails**: Complete logging of all vault operations
- **No client exposure**: Secrets never transmitted to frontend

## Implementation Requirements

### Phase 1: Database Schema Setup

#### Required Functions
```sql
-- 1. Vault secret creation function
CREATE OR REPLACE FUNCTION public.create_vault_secret(
  p_secret TEXT,
  p_name TEXT, 
  p_description TEXT
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  secret_id UUID;
BEGIN
  -- Only service role can create vault secrets
  IF auth.role() != 'service_role' THEN
    RAISE EXCEPTION 'Insufficient privileges to create vault secrets';
  END IF;
  
  -- Create secret in vault
  SELECT vault.create_secret(p_secret, p_name, p_description) INTO secret_id;
  
  RETURN secret_id;
END;
$$;

-- 2. Vault decryption function (NO FALLBACK)
CREATE OR REPLACE FUNCTION public.vault_decrypt(vault_id TEXT)
RETURNS TEXT AS $$
DECLARE
    decrypted_value TEXT;
    uuid_id UUID;
BEGIN
    IF auth.role() != 'service_role' THEN
        RAISE EXCEPTION 'Insufficient privileges to decrypt vault secrets';
    END IF;

    -- Validate UUID format
    BEGIN
        uuid_id := vault_id::UUID;
    EXCEPTION WHEN OTHERS THEN
        RETURN NULL; -- Invalid UUID format
    END;

    -- Decrypt from vault only
    BEGIN
        SELECT decrypted_secret INTO decrypted_value
        FROM vault.decrypted_secrets
        WHERE id = uuid_id
        LIMIT 1;
    EXCEPTION WHEN OTHERS THEN
        decrypted_value := NULL;
    END;

    RETURN decrypted_value;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### Integration Credentials Table
```sql
-- Centralized table for ALL integration credentials
CREATE TABLE IF NOT EXISTS public.user_integration_credentials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  oauth_provider_id UUID NOT NULL REFERENCES oauth_providers(id),
  external_user_id TEXT NOT NULL,
  external_username TEXT,
  connection_name TEXT NOT NULL,
  
  -- SECURE STORAGE: Only vault UUIDs
  vault_access_token_id TEXT,    -- Vault UUID for access token/API key
  vault_refresh_token_id TEXT,   -- Vault UUID for refresh token (OAuth only)
  
  -- DEPRECATED: Legacy columns (always NULL in new system)
  encrypted_access_token TEXT,   -- DEPRECATED: Set to NULL
  encrypted_refresh_token TEXT,  -- DEPRECATED: Set to NULL
  
  -- Credential type and metadata
  credential_type public.connection_credential_type_enum DEFAULT 'oauth' NOT NULL,
  connection_status TEXT DEFAULT 'active' CHECK (connection_status IN ('active', 'expired', 'revoked', 'error')),
  connection_metadata JSONB,
  token_expires_at TIMESTAMPTZ,
  last_token_refresh TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  
  -- Security constraints
  CONSTRAINT chk_vault_storage_required CHECK (
    (credential_type = 'api_key' AND vault_access_token_id IS NOT NULL AND connection_status = 'active')
    OR (credential_type = 'oauth' AND vault_access_token_id IS NOT NULL AND connection_status = 'active')
    OR (connection_status != 'active')
  )
);

-- Security trigger to prevent plain text storage
CREATE OR REPLACE FUNCTION public.ensure_vault_storage()
RETURNS TRIGGER AS $$
BEGIN
    -- Ensure encrypted fields are always NULL (deprecated)
    NEW.encrypted_access_token := NULL;
    NEW.encrypted_refresh_token := NULL;
    
    -- Validate vault UUID format for active connections
    IF NEW.connection_status = 'active' AND NEW.vault_access_token_id IS NOT NULL THEN
        IF NEW.vault_access_token_id !~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' 
           AND NEW.vault_access_token_id !~ '^ya29\.' -- Allow OAuth tokens during migration
        THEN
            RAISE EXCEPTION 'Security Error: vault_access_token_id must be a valid UUID. Use create_vault_secret() to encrypt credentials.';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ensure_vault_storage_trigger
  BEFORE INSERT OR UPDATE ON user_integration_credentials
  FOR EACH ROW
  EXECUTE FUNCTION ensure_vault_storage();
```

### Phase 2: VaultService Implementation

#### TypeScript VaultService Class
```typescript
// src/services/VaultService.ts
import { SupabaseClient } from '@supabase/supabase-js';

export class VaultService {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Create encrypted secret in Supabase Vault
   * @param name Unique identifier for the secret
   * @param secret The sensitive value to encrypt
   * @param description Human-readable description
   * @returns Vault UUID for database storage
   */
  async createSecret(
    name: string,
    secret: string,
    description: string
  ): Promise<string> {
    if (!name || !secret) {
      throw new Error('Name and secret are required');
    }

    // Use RPC function for secure vault creation
    const { data: secretId, error } = await this.supabase.rpc(
      'create_vault_secret',
      {
        p_secret: secret,
        p_name: name,
        p_description: description,
      }
    );

    if (error) {
      console.error('VaultService: Failed to create secret:', error);
      throw new Error(`Failed to create vault secret: ${error.message}`);
    }

    if (!secretId) {
      throw new Error('Vault secret creation returned null');
    }

    return secretId;
  }

  /**
   * Retrieve decrypted secret from Supabase Vault
   * @param secretId Vault UUID
   * @returns Decrypted secret value
   */
  async getSecret(secretId: string): Promise<string | null> {
    if (!secretId) {
      throw new Error('Secret ID is required');
    }

    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(secretId)) {
      throw new Error('Invalid vault UUID format');
    }

    // Use RPC function for secure decryption
    const { data: secretValue, error } = await this.supabase.rpc(
      'vault_decrypt',
      {
        vault_id: secretId,
      }
    );

    if (error) {
      console.error('VaultService: Failed to decrypt secret:', error);
      throw new Error(`Failed to decrypt vault secret: ${error.message}`);
    }

    return secretValue;
  }

  /**
   * Generate standardized secret name
   * @param provider Service provider (e.g., 'openai', 'gmail')
   * @param type Secret type ('api_key', 'access_token', 'refresh_token')
   * @param userId User identifier
   * @returns Standardized secret name
   */
  static generateSecretName(
    provider: string,
    type: 'api_key' | 'access_token' | 'refresh_token',
    userId: string
  ): string {
    const timestamp = Date.now();
    return `${provider}_${type}_${userId}_${timestamp}`;
  }

  /**
   * Generate standardized secret description
   * @param provider Service provider
   * @param type Secret type
   * @param userId User identifier
   * @returns Human-readable description
   */
  static generateSecretDescription(
    provider: string,
    type: string,
    userId: string
  ): string {
    const timestamp = new Date().toISOString();
    return `${provider} ${type} for user ${userId} - Created: ${timestamp}`;
  }
}
```

### Phase 3: UI Component Integration

#### Mandatory Security Pattern for UI Components
```typescript
// MANDATORY PATTERN: Secure credential storage in UI components

import { VaultService } from '@/services/VaultService';

// Example: API key storage
const handleApiKeySubmission = async (apiKey: string, provider: string) => {
  try {
    // 1. Create vault secret
    const secretName = VaultService.generateSecretName(provider, 'api_key', user.id);
    const description = VaultService.generateSecretDescription(provider, 'API key', user.id);
    
    const { data: vaultId, error: vaultError } = await supabase.rpc('create_vault_secret', {
      p_secret: apiKey,
      p_name: secretName,
      p_description: description
    });

    if (vaultError || !vaultId) {
      throw new Error(`Failed to secure API key in vault: ${vaultError?.message}`);
    }

    // 2. Store only vault UUID in database
    const { error: insertError } = await supabase
      .from('user_integration_credentials')
      .insert({
        user_id: user.id,
        oauth_provider_id: providerId,
        vault_access_token_id: vaultId,        // ✅ Vault UUID only
        encrypted_access_token: null,           // ✅ Never store plain text
        vault_refresh_token_id: null,          // ✅ Not applicable for API keys
        encrypted_refresh_token: null,         // ✅ Never store plain text
        credential_type: 'api_key',
        connection_name: `${provider} API Key`,
        connection_status: 'active'
      });

    if (insertError) {
      throw new Error(`Failed to save credential reference: ${insertError.message}`);
    }

    console.log(`✅ API key securely stored in vault: ${vaultId}`);
    
  } catch (error) {
    console.error('❌ Failed to store API key securely:', error);
    throw error;
  }
};

// Example: OAuth token storage
const handleOAuthTokens = async (accessToken: string, refreshToken: string, provider: string) => {
  try {
    // 1. Create vault secrets for both tokens
    const accessSecretName = VaultService.generateSecretName(provider, 'access_token', user.id);
    const refreshSecretName = VaultService.generateSecretName(provider, 'refresh_token', user.id);

    const [{ data: accessVaultId }, { data: refreshVaultId }] = await Promise.all([
      supabase.rpc('create_vault_secret', {
        p_secret: accessToken,
        p_name: accessSecretName,
        p_description: VaultService.generateSecretDescription(provider, 'access token', user.id)
      }),
      supabase.rpc('create_vault_secret', {
        p_secret: refreshToken,
        p_name: refreshSecretName,
        p_description: VaultService.generateSecretDescription(provider, 'refresh token', user.id)
      })
    ]);

    // 2. Store only vault UUIDs
    const { error } = await supabase
      .from('user_integration_credentials')
      .insert({
        vault_access_token_id: accessVaultId,   // ✅ Vault UUID only
        vault_refresh_token_id: refreshVaultId, // ✅ Vault UUID only
        encrypted_access_token: null,           // ✅ Never store plain text
        encrypted_refresh_token: null,          // ✅ Never store plain text
        credential_type: 'oauth',
        // ... other fields
      });

  } catch (error) {
    console.error('❌ Failed to store OAuth tokens securely:', error);
    throw error;
  }
};
```

### Phase 4: Server-Side Secret Retrieval

#### Edge Function Implementation
```typescript
// supabase/functions/[integration]/index.ts
import { createClient } from '@supabase/supabase-js';

export default async function handler(req: Request) {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!, // Service role for vault access
  );

  try {
    // 1. Get credential reference from database
    const { data: connection, error: fetchError } = await supabase
      .from('user_integration_credentials')
      .select('vault_access_token_id, vault_refresh_token_id')
      .eq('id', connectionId)
      .single();

    if (fetchError || !connection) {
      throw new Error('Connection not found');
    }

    // 2. Decrypt secrets from vault
    const { data: accessToken, error: decryptError } = await supabase.rpc(
      'vault_decrypt',
      { vault_id: connection.vault_access_token_id }
    );

    if (decryptError || !accessToken) {
      throw new Error('Failed to decrypt access token');
    }

    // 3. Use decrypted secret for API call
    const response = await fetch('https://api.example.com/data', {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    });

    // 4. Return response (secret never leaves server)
    return new Response(JSON.stringify(await response.json()));

  } catch (error) {
    console.error('Integration error:', error);
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
}
```

### Phase 5: Migration from Legacy Systems

#### Migration Script Template
```typescript
// scripts/migrate-to-vault.ts
import { createClient } from '@supabase/supabase-js';

async function migrateToVault() {
  const supabase = createClient(url, serviceKey);

  // 1. Find credentials with plain text storage
  const { data: credentials, error } = await supabase
    .from('user_integration_credentials')
    .select('*')
    .or('encrypted_access_token.not.is.null,encrypted_refresh_token.not.is.null');

  if (error) throw error;

  for (const credential of credentials || []) {
    console.log(`Migrating credential ${credential.id}...`);

    let vaultAccessId = credential.vault_access_token_id;
    let vaultRefreshId = credential.vault_refresh_token_id;

    // Migrate access token if stored in plain text
    if (credential.encrypted_access_token && !vaultAccessId) {
      const { data: accessVaultId } = await supabase.rpc('create_vault_secret', {
        p_secret: credential.encrypted_access_token,
        p_name: `migrated_access_${credential.id}_${Date.now()}`,
        p_description: `Migrated access token for credential ${credential.id}`
      });
      vaultAccessId = accessVaultId;
    }

    // Migrate refresh token if stored in plain text  
    if (credential.encrypted_refresh_token && !vaultRefreshId) {
      const { data: refreshVaultId } = await supabase.rpc('create_vault_secret', {
        p_secret: credential.encrypted_refresh_token,
        p_name: `migrated_refresh_${credential.id}_${Date.now()}`,
        p_description: `Migrated refresh token for credential ${credential.id}`
      });
      vaultRefreshId = refreshVaultId;
    }

    // Update with vault IDs and clear plain text
    await supabase
      .from('user_integration_credentials')
      .update({
        vault_access_token_id: vaultAccessId,
        vault_refresh_token_id: vaultRefreshId,
        encrypted_access_token: null,      // Clear plain text
        encrypted_refresh_token: null,     // Clear plain text
        updated_at: new Date().toISOString()
      })
      .eq('id', credential.id);

    console.log(`✅ Migrated credential ${credential.id}`);
  }
}
```

## Security Verification

### Automated Security Checks
```sql
-- 1. Verify no plain text credentials exist
SELECT 
  'SECURITY_VIOLATION' as alert_type,
  COUNT(*) as violation_count,
  'Plain text credentials found' as message
FROM user_integration_credentials
WHERE encrypted_access_token IS NOT NULL 
   OR encrypted_refresh_token IS NOT NULL;

-- 2. Verify vault UUID format
SELECT 
  credential_type,
  COUNT(*) as total,
  COUNT(CASE WHEN vault_access_token_id ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN 1 END) as vault_stored,
  COUNT(CASE WHEN vault_access_token_id IS NOT NULL AND vault_access_token_id !~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN 1 END) as invalid_format
FROM user_integration_credentials
WHERE connection_status = 'active'
GROUP BY credential_type;

-- 3. Audit vault function usage
CREATE OR REPLACE FUNCTION audit_vault_access()
RETURNS TABLE(
  operation TEXT,
  user_role TEXT,
  timestamp TIMESTAMPTZ,
  secret_name TEXT
) AS $$
BEGIN
  -- This would integrate with your audit logging system
  -- Implementation depends on your specific audit requirements
  RETURN QUERY
  SELECT 
    'vault_decrypt'::TEXT,
    current_setting('request.jwt.claims', true)::json->>'role',
    now(),
    'audit_check'::TEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Testing Framework
```typescript
// tests/vault-security.test.ts
describe('Vault Security Tests', () => {
  test('should reject plain text storage attempts', async () => {
    const supabase = createTestClient();
    
    await expect(
      supabase.from('user_integration_credentials').insert({
        encrypted_access_token: 'sk-plain-text-key', // Should be blocked
        credential_type: 'api_key'
      })
    ).rejects.toThrow('Security Error');
  });

  test('should require vault UUIDs for active connections', async () => {
    const supabase = createTestClient();
    
    await expect(
      supabase.from('user_integration_credentials').insert({
        vault_access_token_id: 'invalid-format',
        credential_type: 'api_key',
        connection_status: 'active'
      })
    ).rejects.toThrow('vault_access_token_id must be a valid UUID');
  });

  test('should decrypt vault secrets correctly', async () => {
    const supabase = createServiceClient();
    
    // Create test secret
    const { data: vaultId } = await supabase.rpc('create_vault_secret', {
      p_secret: 'test-secret-value',
      p_name: 'test_secret',
      p_description: 'Test secret'
    });

    // Decrypt and verify
    const { data: decrypted } = await supabase.rpc('vault_decrypt', {
      vault_id: vaultId
    });

    expect(decrypted).toBe('test-secret-value');
  });
});
```

## Compliance Standards

### HIPAA Compliance Requirements
- **164.312(a)(2)(iv)**: Encryption and Decryption ✅
- **164.312(e)(2)(ii)**: Transmission Security ✅  
- **164.308(a)(5)(ii)(D)**: Access Management ✅
- **164.312(b)**: Audit Controls ✅

### SOC 2 Type II Requirements
- **CC6.1**: Logical Access Security ✅
- **CC6.7**: Transmission of Data ✅
- **CC9.1**: Confidentiality ✅

### ISO 27001/27002 Requirements  
- **A.10.1.1**: Cryptographic Controls ✅
- **A.9.4.1**: Information Access Restriction ✅
- **A.12.3.1**: Information Backup ✅

## Implementation Checklist

### Phase 1: Foundation ✅
- [ ] Create `create_vault_secret()` function
- [ ] Create `vault_decrypt()` function (no fallback)
- [ ] Update/create `user_integration_credentials` table
- [ ] Add security constraints and triggers
- [ ] Create audit logging functions

### Phase 2: Service Layer ✅
- [ ] Implement `VaultService` class
- [ ] Add standardized naming functions
- [ ] Create error handling patterns
- [ ] Add TypeScript interfaces

### Phase 3: UI Integration ✅
- [ ] Update all credential input components
- [ ] Remove plain text storage code
- [ ] Add vault secret creation calls
- [ ] Implement proper error handling

### Phase 4: Server Integration ✅
- [ ] Update Edge Functions to use vault decryption
- [ ] Remove any plain text credential access
- [ ] Add proper service role authentication
- [ ] Implement credential refresh patterns

### Phase 5: Migration & Testing ✅
- [ ] Create migration scripts for existing data
- [ ] Run security verification queries
- [ ] Implement automated security tests
- [ ] Perform penetration testing

### Phase 6: Documentation & Compliance ✅
- [ ] Document all security patterns
- [ ] Create developer implementation guides
- [ ] Establish security review procedures
- [ ] Generate compliance reports

## Best Practices Summary

1. **Never store sensitive data in plain text** - Use vault UUIDs only
2. **Use service role for all vault operations** - Never client-side access
3. **Implement proper error handling** - Don't expose vault internals
4. **Follow naming conventions** - Standardized secret identification
5. **Enable audit logging** - Track all vault operations
6. **Regular security reviews** - Verify compliance with protocol
7. **Automated testing** - Include vault security in CI/CD pipeline
8. **Documentation** - Keep implementation guides current

## Emergency Procedures

### Security Incident Response
1. **Immediate**: Rotate affected credentials
2. **Investigation**: Review audit logs for unauthorized access
3. **Containment**: Disable compromised connections  
4. **Recovery**: Re-encrypt with new vault secrets
5. **Prevention**: Update security controls as needed

### Vault Corruption Recovery
1. **Assessment**: Determine scope of affected secrets
2. **Backup**: Use Supabase backup for vault recovery
3. **Re-encryption**: Migrate to new vault secrets if needed
4. **Verification**: Test all integrations after recovery
5. **Documentation**: Update incident response procedures

This protocol ensures **enterprise-grade security** for all sensitive credentials while maintaining developer productivity and system reliability.