---
description: Detailed schema documentation for user_integration_credentials table and credential management system
globs: []
alwaysApply: false
---

# Integration Credentials Schema

## Overview

The `user_integration_credentials` table stores all user connections to external services, supporting both OAuth tokens and API keys with enterprise-grade security through Supabase Vault encryption. This table replaces the legacy `user_oauth_connections` table with a unified approach.

## Table Definition

```sql
CREATE TABLE user_integration_credentials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  service_provider_id UUID REFERENCES service_providers(id),
  credential_type credential_type DEFAULT 'oauth' NOT NULL, -- 'oauth', 'api_key'
  
  -- SECURE: Only vault UUIDs stored
  vault_access_token_id TEXT,    -- Vault UUID for token/key
  vault_refresh_token_id TEXT,   -- Vault UUID for refresh token (OAuth only)
  encrypted_access_token TEXT,   -- DEPRECATED: Always NULL in new system
  encrypted_refresh_token TEXT,  -- DEPRECATED: Always NULL in new system
  
  connection_name TEXT NOT NULL,
  connection_status TEXT DEFAULT 'active',
  connection_metadata JSONB,
  scopes_granted JSONB,           -- Array of granted OAuth scopes
  token_expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  
  UNIQUE(user_id, service_provider_id, connection_name)
);
```

## Credential Types

### OAuth Credentials (`credential_type = 'oauth'`)

OAuth credentials include access tokens, refresh tokens, and scope information.

**Example: Gmail OAuth Connection**
```sql
INSERT INTO user_integration_credentials (
  user_id,
  service_provider_id,
  credential_type,
  vault_access_token_id,
  vault_refresh_token_id,
  connection_name,
  scopes_granted,
  token_expires_at,
  connection_metadata
) VALUES (
  'user-uuid-here',
  (SELECT id FROM service_providers WHERE name = 'gmail'),
  'oauth',
  'vault-uuid-for-access-token',
  'vault-uuid-for-refresh-token',
  'Primary Gmail Account',
  '["https://www.googleapis.com/auth/gmail.send", "https://www.googleapis.com/auth/gmail.readonly"]'::jsonb,
  now() + interval '1 hour',
  '{
    "external_user_id": "google-user-id",
    "external_username": "user@gmail.com",
    "profile_picture": "https://lh3.googleusercontent.com/...",
    "last_token_refresh": "2025-09-17T10:00:00Z"
  }'::jsonb
);
```

### API Key Credentials (`credential_type = 'api_key'`)

API key credentials store long-lived authentication keys for API services.

**Example: Serper API Key Connection**
```sql
INSERT INTO user_integration_credentials (
  user_id,
  service_provider_id,
  credential_type,
  vault_access_token_id,
  connection_name,
  connection_metadata
) VALUES (
  'user-uuid-here',
  (SELECT id FROM service_providers WHERE name = 'serper_api'),
  'api_key',
  'vault-uuid-for-api-key',
  'Web Search API',
  '{
    "api_key_name": "Production Key",
    "usage_limits": {
      "daily_limit": 2500,
      "monthly_limit": 75000
    },
    "last_used": "2025-09-17T09:30:00Z"
  }'::jsonb
);
```

## Security Architecture

### Vault Integration

All sensitive credentials are stored in Supabase Vault, not in the database directly.

```sql
-- Security constraint to ensure vault storage
CONSTRAINT "chk_vault_storage_required" CHECK (
  (credential_type = 'api_key' AND vault_access_token_id IS NOT NULL AND connection_status = 'active')
  OR (credential_type = 'oauth' AND vault_access_token_id IS NOT NULL AND connection_status = 'active')
  OR (connection_status != 'active')
)

-- Security trigger to prevent plain text storage
CREATE OR REPLACE FUNCTION ensure_vault_storage()
RETURNS TRIGGER AS $$
BEGIN
    -- Ensure encrypted fields are always NULL (deprecated)
    NEW.encrypted_access_token := NULL;
    NEW.encrypted_refresh_token := NULL;
    
    -- Validate vault storage for active connections
    IF NEW.connection_status = 'active' AND NEW.vault_access_token_id IS NULL THEN
        RAISE EXCEPTION 'Active connections must have vault_access_token_id';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_ensure_vault_storage
    BEFORE INSERT OR UPDATE ON user_integration_credentials
    FOR EACH ROW EXECUTE FUNCTION ensure_vault_storage();
```

## Connection Status States

### Status Lifecycle
```
active → expired → refreshed → active
  ↓
revoked (terminal)
  ↓
error (requires user intervention)
```

**Status Definitions:**
- `active`: Connection working normally
- `expired`: Token expired but refresh possible
- `revoked`: User revoked access (terminal state)
- `error`: Connection failed, needs user attention

## Indexes and Performance

```sql
-- Primary performance indexes
CREATE INDEX idx_user_integration_credentials_user_id 
ON user_integration_credentials (user_id, connection_status);

CREATE INDEX idx_user_integration_credentials_provider 
ON user_integration_credentials (service_provider_id, credential_type);

CREATE INDEX idx_user_integration_credentials_status 
ON user_integration_credentials (connection_status) 
WHERE connection_status IN ('active', 'expired');

-- JSONB indexes for metadata queries
CREATE INDEX idx_user_integration_credentials_metadata 
ON user_integration_credentials USING GIN (connection_metadata);

CREATE INDEX idx_user_integration_credentials_scopes 
ON user_integration_credentials USING GIN (scopes_granted);
```

## RLS Policies

```sql
-- Users can only access their own credentials
CREATE POLICY "Users can manage their own credentials"
ON user_integration_credentials FOR ALL
USING (user_id = auth.uid());

-- Service role can access all credentials (for system operations)
CREATE POLICY "Service role can manage all credentials"
ON user_integration_credentials FOR ALL
TO service_role
USING (true);

-- Agents can only read credentials they have permissions for
CREATE POLICY "Agents can read permitted credentials"
ON user_integration_credentials FOR SELECT
USING (
  id IN (
    SELECT connection_id FROM agent_integration_permissions 
    WHERE is_active = true
  )
);
```

## Common Queries

### Get User's Active Connections
```sql
SELECT 
  uic.*,
  sp.name as provider_name,
  sp.display_name as provider_display_name,
  sp.provider_type
FROM user_integration_credentials uic
JOIN service_providers sp ON sp.id = uic.service_provider_id
WHERE uic.user_id = $1 
AND uic.connection_status = 'active'
ORDER BY uic.created_at DESC;
```

### Get OAuth Connections Needing Refresh
```sql
SELECT * FROM user_integration_credentials
WHERE credential_type = 'oauth'
AND connection_status = 'active'
AND token_expires_at < now() + interval '5 minutes'
AND vault_refresh_token_id IS NOT NULL;
```

### Get Connections by Provider Type
```sql
SELECT uic.*, sp.display_name
FROM user_integration_credentials uic
JOIN service_providers sp ON sp.id = uic.service_provider_id
WHERE uic.user_id = $1
AND sp.provider_type = $2
AND uic.connection_status = 'active';
```

## Management Functions

### Create OAuth Connection
```sql
CREATE OR REPLACE FUNCTION create_oauth_connection(
  p_user_id UUID,
  p_provider_name TEXT,
  p_access_token TEXT,
  p_refresh_token TEXT DEFAULT NULL,
  p_scopes TEXT[],
  p_expires_in INTEGER DEFAULT 3600,
  p_connection_name TEXT DEFAULT NULL,
  p_external_username TEXT DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  v_provider_id UUID;
  v_connection_id UUID;
  v_vault_access_id TEXT;
  v_vault_refresh_id TEXT;
  v_final_connection_name TEXT;
BEGIN
  -- Get provider ID
  SELECT id INTO v_provider_id 
  FROM service_providers 
  WHERE name = p_provider_name AND provider_type = 'oauth';
  
  IF v_provider_id IS NULL THEN
    RAISE EXCEPTION 'OAuth provider % not found', p_provider_name;
  END IF;
  
  -- Store access token in vault
  SELECT create_vault_secret(
    p_access_token,
    format('%s_access_token_%s', p_provider_name, p_user_id),
    format('%s access token for user %s', p_provider_name, p_user_id)
  ) INTO v_vault_access_id;
  
  -- Store refresh token in vault if provided
  IF p_refresh_token IS NOT NULL THEN
    SELECT create_vault_secret(
      p_refresh_token,
      format('%s_refresh_token_%s', p_provider_name, p_user_id),
      format('%s refresh token for user %s', p_provider_name, p_user_id)
    ) INTO v_vault_refresh_id;
  END IF;
  
  -- Set default connection name
  v_final_connection_name := COALESCE(
    p_connection_name,
    (SELECT display_name FROM service_providers WHERE id = v_provider_id)
  );
  
  -- Create connection record
  INSERT INTO user_integration_credentials (
    user_id,
    service_provider_id,
    credential_type,
    vault_access_token_id,
    vault_refresh_token_id,
    connection_name,
    scopes_granted,
    token_expires_at,
    connection_metadata
  ) VALUES (
    p_user_id,
    v_provider_id,
    'oauth',
    v_vault_access_id,
    v_vault_refresh_id,
    v_final_connection_name,
    to_jsonb(p_scopes),
    now() + make_interval(secs => p_expires_in),
    jsonb_build_object('external_username', p_external_username)
  ) RETURNING id INTO v_connection_id;
  
  RETURN v_connection_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Create API Key Connection
```sql
CREATE OR REPLACE FUNCTION create_api_key_connection(
  p_user_id UUID,
  p_provider_name TEXT,
  p_api_key TEXT,
  p_connection_name TEXT DEFAULT NULL,
  p_metadata JSONB DEFAULT '{}'::jsonb
) RETURNS UUID AS $$
DECLARE
  v_provider_id UUID;
  v_connection_id UUID;
  v_vault_key_id TEXT;
  v_final_connection_name TEXT;
BEGIN
  -- Get provider ID
  SELECT id INTO v_provider_id 
  FROM service_providers 
  WHERE name = p_provider_name AND provider_type = 'api_key';
  
  IF v_provider_id IS NULL THEN
    RAISE EXCEPTION 'API key provider % not found', p_provider_name;
  END IF;
  
  -- Store API key in vault
  SELECT create_vault_secret(
    p_api_key,
    format('%s_api_key_%s', p_provider_name, p_user_id),
    format('%s API key for user %s', p_provider_name, p_user_id)
  ) INTO v_vault_key_id;
  
  -- Set default connection name
  v_final_connection_name := COALESCE(
    p_connection_name,
    (SELECT display_name FROM service_providers WHERE id = v_provider_id)
  );
  
  -- Create connection record
  INSERT INTO user_integration_credentials (
    user_id,
    service_provider_id,
    credential_type,
    vault_access_token_id,
    connection_name,
    connection_metadata
  ) VALUES (
    p_user_id,
    v_provider_id,
    'api_key',
    v_vault_key_id,
    v_final_connection_name,
    p_metadata
  ) RETURNING id INTO v_connection_id;
  
  RETURN v_connection_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Refresh OAuth Token
```sql
CREATE OR REPLACE FUNCTION refresh_oauth_token(
  p_connection_id UUID,
  p_new_access_token TEXT,
  p_new_refresh_token TEXT DEFAULT NULL,
  p_expires_in INTEGER DEFAULT 3600
) RETURNS BOOLEAN AS $$
DECLARE
  v_user_id UUID;
  v_provider_name TEXT;
  v_vault_access_id TEXT;
  v_vault_refresh_id TEXT;
BEGIN
  -- Get connection details
  SELECT uic.user_id, sp.name
  INTO v_user_id, v_provider_name
  FROM user_integration_credentials uic
  JOIN service_providers sp ON sp.id = uic.service_provider_id
  WHERE uic.id = p_connection_id
  AND uic.credential_type = 'oauth';
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'OAuth connection % not found', p_connection_id;
  END IF;
  
  -- Store new access token in vault
  SELECT create_vault_secret(
    p_new_access_token,
    format('%s_access_token_%s_%s', v_provider_name, v_user_id, extract(epoch from now())),
    format('Refreshed %s access token for user %s', v_provider_name, v_user_id)
  ) INTO v_vault_access_id;
  
  -- Store new refresh token if provided
  IF p_new_refresh_token IS NOT NULL THEN
    SELECT create_vault_secret(
      p_new_refresh_token,
      format('%s_refresh_token_%s_%s', v_provider_name, v_user_id, extract(epoch from now())),
      format('Refreshed %s refresh token for user %s', v_provider_name, v_user_id)
    ) INTO v_vault_refresh_id;
  END IF;
  
  -- Update connection with new tokens
  UPDATE user_integration_credentials SET
    vault_access_token_id = v_vault_access_id,
    vault_refresh_token_id = COALESCE(v_vault_refresh_id, vault_refresh_token_id),
    token_expires_at = now() + make_interval(secs => p_expires_in),
    connection_status = 'active',
    connection_metadata = jsonb_set(
      COALESCE(connection_metadata, '{}'::jsonb),
      '{last_token_refresh}',
      to_jsonb(now())
    ),
    updated_at = now()
  WHERE id = p_connection_id;
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Migration from Legacy Schema

### Backward Compatibility
The system maintains references to deprecated `encrypted_access_token` and `encrypted_refresh_token` fields but ensures they remain NULL through database triggers.

### Migration Pattern
```sql
-- Example migration from old schema
UPDATE user_integration_credentials 
SET credential_type = 'api_key'
WHERE service_provider_id IN (
  SELECT id FROM service_providers 
  WHERE name IN ('serper_api', 'serpapi', 'brave_search')
);
```

## Related Documentation

- **[Service Providers Schema](service_providers_schema.mdc)** - Provider configuration details
- **[Agent Permissions Schema](agent_permissions_schema.mdc)** - How agents access credentials
- **[Vault Security Schema](vault_security_schema.mdc)** - Encryption implementation
- **[OAuth Flow Protocol](../02_integrations/oauth_flow_protocol.mdc)** - OAuth implementation
- **[API Key Integration Protocol](../02_integrations/api_key_integration_protocol.mdc)** - API key handling

---

**Last Updated**: September 17, 2025  
**Schema Version**: Production  
**Migration History**: Evolved from user_oauth_connections in migration 20250107000001_create_integrations_tables.sql