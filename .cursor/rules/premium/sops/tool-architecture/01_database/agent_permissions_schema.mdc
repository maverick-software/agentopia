---
description: Detailed schema documentation for agent_integration_permissions table and agent access control system
globs: []
alwaysApply: false
---

# Agent Integration Permissions Schema

## Overview

The `agent_integration_permissions` table controls which agents have access to which user integration credentials and with what level of permissions. This table replaces the legacy `agent_oauth_permissions` table with a unified approach supporting all credential types.

## Table Definition

```sql
CREATE TABLE agent_integration_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID REFERENCES agents(id) ON DELETE CASCADE,
  connection_id UUID REFERENCES user_integration_credentials(id) ON DELETE CASCADE,
  granted_by_user_id UUID REFERENCES auth.users(id),
  permission_level TEXT DEFAULT 'custom' CHECK (permission_level IN ('read_only', 'full_access', 'custom')),
  allowed_scopes JSONB NOT NULL,           -- Subset of granted_scopes from connection
  granted_at TIMESTAMPTZ DEFAULT now(),
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT true,
  usage_count INTEGER DEFAULT 0,
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
```

## Permission Levels

### Read-Only (`permission_level = 'read_only'`)

Agents can only read data, not modify or send.

**Example: Gmail Read-Only Permission**
```sql
INSERT INTO agent_integration_permissions (
  agent_id,
  connection_id,
  granted_by_user_id,
  permission_level,
  allowed_scopes
) VALUES (
  'agent-uuid-here',
  'gmail-connection-uuid',
  'user-uuid-here',
  'read_only',
  '["https://www.googleapis.com/auth/gmail.readonly"]'::jsonb
);
```

### Full Access (`permission_level = 'full_access'`)

Agents have access to all scopes granted to the user connection.

**Example: Gmail Full Access Permission**
```sql
INSERT INTO agent_integration_permissions (
  agent_id,
  connection_id,
  granted_by_user_id,
  permission_level,
  allowed_scopes
) VALUES (
  'agent-uuid-here',
  'gmail-connection-uuid',
  'user-uuid-here',
  'full_access',
  '["https://www.googleapis.com/auth/gmail.send", "https://www.googleapis.com/auth/gmail.readonly", "https://www.googleapis.com/auth/gmail.modify"]'::jsonb
);
```

### Custom (`permission_level = 'custom'`)

Agents have access to a specific subset of scopes defined by the user.

**Example: Gmail Custom Permission**
```sql
INSERT INTO agent_integration_permissions (
  agent_id,
  connection_id,
  granted_by_user_id,
  permission_level,
  allowed_scopes
) VALUES (
  'agent-uuid-here',
  'gmail-connection-uuid',
  'user-uuid-here',
  'custom',
  '["https://www.googleapis.com/auth/gmail.send"]'::jsonb
);
```

## Permission Scope Validation

### OAuth Scope Validation
For OAuth connections, `allowed_scopes` must be a subset of `scopes_granted` from the user's connection.

```sql
-- Validation function
CREATE OR REPLACE FUNCTION validate_oauth_scopes()
RETURNS TRIGGER AS $$
DECLARE
  v_granted_scopes JSONB;
  v_credential_type TEXT;
BEGIN
  -- Get the granted scopes and credential type from the connection
  SELECT uic.scopes_granted, uic.credential_type
  INTO v_granted_scopes, v_credential_type
  FROM user_integration_credentials uic
  WHERE uic.id = NEW.connection_id;
  
  -- For OAuth connections, validate scopes
  IF v_credential_type = 'oauth' THEN
    -- Check if all allowed_scopes are in granted_scopes
    IF NOT (NEW.allowed_scopes <@ v_granted_scopes) THEN
      RAISE EXCEPTION 'Allowed scopes must be a subset of granted scopes';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validate_oauth_scopes
  BEFORE INSERT OR UPDATE ON agent_integration_permissions
  FOR EACH ROW EXECUTE FUNCTION validate_oauth_scopes();
```

### API Key Permission Validation
For API key connections, permissions are typically capability-based rather than scope-based.

**Example: Web Search API Permission**
```sql
INSERT INTO agent_integration_permissions (
  agent_id,
  connection_id,
  granted_by_user_id,
  permission_level,
  allowed_scopes
) VALUES (
  'agent-uuid-here',
  'serper-api-connection-uuid',
  'user-uuid-here',
  'custom',
  '["web_search", "news_search"]'::jsonb
);
```

## Permission Inheritance and Defaults

### Default Permissions by Provider Type

```sql
-- Function to get default permissions for a provider
CREATE OR REPLACE FUNCTION get_default_permissions(
  p_service_provider_id UUID,
  p_credential_type TEXT
) RETURNS JSONB AS $$
BEGIN
  CASE p_credential_type
    WHEN 'oauth' THEN
      -- Return read-only scopes by default
      RETURN (
        SELECT jsonb_agg(scope)
        FROM jsonb_array_elements_text(scopes_supported) AS scope
        WHERE scope LIKE '%readonly%' OR scope LIKE '%read%'
      )
      FROM service_providers
      WHERE id = p_service_provider_id;
    
    WHEN 'api_key' THEN
      -- Return basic capabilities for API keys
      RETURN '["basic_access"]'::jsonb;
    
    ELSE
      RETURN '[]'::jsonb;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

## Indexes and Performance

```sql
-- Primary lookup indexes
CREATE INDEX idx_agent_integration_permissions_agent_id 
ON agent_integration_permissions (agent_id, is_active);

CREATE INDEX idx_agent_integration_permissions_connection_id 
ON agent_integration_permissions (connection_id, is_active);

-- Composite index for permission checks
CREATE INDEX idx_agent_integration_permissions_lookup 
ON agent_integration_permissions (agent_id, connection_id, is_active);

-- Usage tracking index
CREATE INDEX idx_agent_integration_permissions_usage 
ON agent_integration_permissions (last_used_at DESC) 
WHERE usage_count > 0;

-- Expiration index
CREATE INDEX idx_agent_integration_permissions_expires 
ON agent_integration_permissions (expires_at) 
WHERE expires_at IS NOT NULL AND is_active = true;

-- JSONB index for scope queries
CREATE INDEX idx_agent_integration_permissions_scopes 
ON agent_integration_permissions USING GIN (allowed_scopes);
```

## RLS Policies

```sql
-- Users can only manage permissions for their own agents
CREATE POLICY "Users can manage their agent permissions"
ON agent_integration_permissions FOR ALL
USING (
  agent_id IN (
    SELECT id FROM agents WHERE user_id = auth.uid()
  )
);

-- Users can only grant permissions for their own connections
CREATE POLICY "Users can only grant their own connection permissions"
ON agent_integration_permissions FOR INSERT, UPDATE
WITH CHECK (
  connection_id IN (
    SELECT id FROM user_integration_credentials WHERE user_id = auth.uid()
  )
);

-- Service role can manage all permissions
CREATE POLICY "Service role can manage all permissions"
ON agent_integration_permissions FOR ALL
TO service_role
USING (true);
```

## Common Queries

### Get Agent's Integration Permissions
```sql
SELECT 
  aip.*,
  uic.connection_name,
  uic.connection_metadata->>'external_username' AS external_username,
  sp.name AS provider_name,
  sp.display_name AS provider_display_name
FROM agent_integration_permissions aip
JOIN user_integration_credentials uic ON uic.id = aip.connection_id
JOIN service_providers sp ON sp.id = uic.service_provider_id
WHERE aip.agent_id = $1
AND aip.is_active = true
AND uic.connection_status = 'active'
ORDER BY aip.granted_at DESC;
```

### Check Specific Permission
```sql
SELECT EXISTS (
  SELECT 1 FROM agent_integration_permissions aip
  JOIN user_integration_credentials uic ON uic.id = aip.connection_id
  JOIN service_providers sp ON sp.id = uic.service_provider_id
  WHERE aip.agent_id = $1
  AND sp.name = $2
  AND aip.allowed_scopes ? $3
  AND aip.is_active = true
  AND uic.connection_status = 'active'
) AS has_permission;
```

### Get Permissions Needing Renewal
```sql
SELECT * FROM agent_integration_permissions
WHERE expires_at IS NOT NULL
AND expires_at < now() + interval '7 days'
AND is_active = true;
```

## Management Functions

### Grant Integration Permission
```sql
CREATE OR REPLACE FUNCTION grant_agent_integration_permission(
  p_agent_id UUID,
  p_connection_id UUID,
  p_allowed_scopes JSONB,
  p_permission_level TEXT DEFAULT 'custom'
) RETURNS UUID AS $$
DECLARE
  v_permission_id UUID;
  v_user_id UUID;
  v_granted_scopes JSONB;
BEGIN
  -- Verify the agent belongs to the current user
  SELECT user_id INTO v_user_id
  FROM agents
  WHERE id = p_agent_id AND user_id = auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Agent not found or not owned by current user';
  END IF;
  
  -- Verify the connection belongs to the current user
  SELECT scopes_granted INTO v_granted_scopes
  FROM user_integration_credentials
  WHERE id = p_connection_id AND user_id = auth.uid();
  
  IF v_granted_scopes IS NULL THEN
    RAISE EXCEPTION 'Connection not found or not owned by current user';
  END IF;
  
  -- For OAuth connections, validate scopes
  IF v_granted_scopes IS NOT NULL AND NOT (p_allowed_scopes <@ v_granted_scopes) THEN
    RAISE EXCEPTION 'Allowed scopes must be a subset of granted scopes';
  END IF;
  
  -- Create or update permission
  INSERT INTO agent_integration_permissions (
    agent_id,
    connection_id,
    granted_by_user_id,
    permission_level,
    allowed_scopes
  ) VALUES (
    p_agent_id,
    p_connection_id,
    v_user_id,
    p_permission_level,
    p_allowed_scopes
  ) 
  ON CONFLICT (agent_id, connection_id) 
  DO UPDATE SET
    permission_level = EXCLUDED.permission_level,
    allowed_scopes = EXCLUDED.allowed_scopes,
    is_active = true,
    updated_at = now()
  RETURNING id INTO v_permission_id;
  
  RETURN v_permission_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Revoke Integration Permission
```sql
CREATE OR REPLACE FUNCTION revoke_agent_integration_permission(
  p_permission_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
  UPDATE agent_integration_permissions 
  SET 
    is_active = false,
    updated_at = now()
  WHERE id = p_permission_id
  AND agent_id IN (
    SELECT id FROM agents WHERE user_id = auth.uid()
  );
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Update Permission Usage
```sql
CREATE OR REPLACE FUNCTION update_permission_usage(
  p_agent_id UUID,
  p_connection_id UUID
) RETURNS VOID AS $$
BEGIN
  UPDATE agent_integration_permissions
  SET 
    usage_count = usage_count + 1,
    last_used_at = now()
  WHERE agent_id = p_agent_id
  AND connection_id = p_connection_id
  AND is_active = true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Permission Scopes by Provider

### Gmail Scopes
```json
{
  "read_only": [
    "https://www.googleapis.com/auth/gmail.readonly"
  ],
  "send_only": [
    "https://www.googleapis.com/auth/gmail.send"
  ],
  "full_access": [
    "https://www.googleapis.com/auth/gmail.readonly",
    "https://www.googleapis.com/auth/gmail.send",
    "https://www.googleapis.com/auth/gmail.modify",
    "https://www.googleapis.com/auth/gmail.compose"
  ]
}
```

### Web Search API Capabilities
```json
{
  "basic": ["web_search"],
  "extended": ["web_search", "news_search", "image_search"],
  "full": ["web_search", "news_search", "image_search", "scrape_and_summarize"]
}
```

### Microsoft Outlook Scopes
```json
{
  "read_only": [
    "https://graph.microsoft.com/Mail.Read"
  ],
  "send_only": [
    "https://graph.microsoft.com/Mail.Send"
  ],
  "full_access": [
    "https://graph.microsoft.com/Mail.Read",
    "https://graph.microsoft.com/Mail.Send",
    "https://graph.microsoft.com/Mail.ReadWrite"
  ]
}
```

## Audit and Compliance

### Permission Change Logging
```sql
-- Trigger to log permission changes
CREATE OR REPLACE FUNCTION log_permission_changes()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO tool_execution_logs (
      agent_id, user_id, tool_name, tool_provider, parameters, success, result_data
    ) VALUES (
      NEW.agent_id, NEW.granted_by_user_id, 'grant_permission', 'system',
      jsonb_build_object('connection_id', NEW.connection_id, 'scopes', NEW.allowed_scopes),
      true, jsonb_build_object('permission_id', NEW.id)
    );
  ELSIF TG_OP = 'UPDATE' AND OLD.is_active = true AND NEW.is_active = false THEN
    INSERT INTO tool_execution_logs (
      agent_id, user_id, tool_name, tool_provider, parameters, success, result_data
    ) VALUES (
      NEW.agent_id, NEW.granted_by_user_id, 'revoke_permission', 'system',
      jsonb_build_object('connection_id', NEW.connection_id),
      true, jsonb_build_object('permission_id', NEW.id)
    );
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_log_permission_changes
  AFTER INSERT OR UPDATE ON agent_integration_permissions
  FOR EACH ROW EXECUTE FUNCTION log_permission_changes();
```

## Related Documentation

- **[Integration Credentials Schema](integration_credentials_schema.mdc)** - User credential storage
- **[Service Providers Schema](service_providers_schema.mdc)** - Provider configurations
- **[Permission Management UI](../05_ui_components/permission_management_ui.mdc)** - User interface patterns
- **[Tool Discovery Protocol](../03_tools/tool_discovery_protocol.mdc)** - How permissions affect tool availability
- **[Permission Validation Service](../06_backend_services/permission_validation_service.mdc)** - Runtime permission checking

---

**Last Updated**: September 17, 2025  
**Schema Version**: Production  
**Migration History**: Evolved from agent_oauth_permissions in migration 20250107000018_agent_integration_functions.sql