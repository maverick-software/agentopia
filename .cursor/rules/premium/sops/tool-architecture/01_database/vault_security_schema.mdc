---
description: Supabase Vault implementation for enterprise-grade credential encryption and security patterns
globs: []
alwaysApply: false
---

# Vault Security Schema

## Overview

Agentopia implements enterprise-grade security for all sensitive credentials using Supabase Vault. This system ensures zero plain-text storage of API keys, OAuth tokens, and other sensitive data through military-grade AES encryption.

## Vault Architecture

### Security Principles

1. **Zero Plain-Text Storage**: No sensitive data stored directly in database
2. **Vault-Only Access**: All credentials accessed through Vault APIs
3. **Audit Trails**: Complete logging of all secret operations
4. **Key Rotation**: Support for credential rotation and versioning
5. **Access Control**: Role-based access to encrypted secrets

### Vault Integration Flow

```mermaid
sequenceDiagram
    participant App as Application
    participant DB as Database
    participant Vault as Supabase Vault
    participant External as External Service
    
    App->>Vault: Store credential
    Vault-->>App: Return vault_id (UUID)
    App->>DB: Store vault_id only
    
    Note over App,DB: Later: Tool execution
    App->>DB: Get vault_id
    DB-->>App: Return vault_id
    App->>Vault: Decrypt credential
    Vault-->>App: Return decrypted credential
    App->>External: Use credential for API call
```

## Vault Functions

### Core RPC Functions

```sql
-- Create encrypted secret in vault
CREATE OR REPLACE FUNCTION create_vault_secret(
  p_secret TEXT,
  p_name TEXT,
  p_description TEXT DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
  v_vault_id TEXT;
BEGIN
  -- Call Supabase Vault to encrypt and store the secret
  SELECT vault.create_secret(p_secret, p_name, p_description) INTO v_vault_id;
  
  -- Log the secret creation (without the secret value)
  INSERT INTO vault_audit_logs (
    operation, vault_id, secret_name, created_by, created_at
  ) VALUES (
    'create', v_vault_id, p_name, auth.uid(), now()
  );
  
  RETURN v_vault_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Decrypt secret from vault
CREATE OR REPLACE FUNCTION vault_decrypt(vault_id TEXT) 
RETURNS TEXT AS $$
DECLARE
  v_secret TEXT;
BEGIN
  -- Only service role can decrypt secrets
  IF auth.role() != 'service_role' THEN
    RAISE EXCEPTION 'Only service role can decrypt vault secrets';
  END IF;
  
  -- Decrypt the secret
  SELECT decrypted_secret INTO v_secret
  FROM vault.decrypted_secrets
  WHERE id = vault_id::uuid;
  
  -- Log the access
  INSERT INTO vault_audit_logs (
    operation, vault_id, accessed_by, accessed_at
  ) VALUES (
    'decrypt', vault_id, auth.uid(), now()
  );
  
  RETURN v_secret;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update vault secret
CREATE OR REPLACE FUNCTION update_vault_secret(
  p_vault_id TEXT,
  p_new_secret TEXT
) RETURNS BOOLEAN AS $$
BEGIN
  -- Only service role can update secrets
  IF auth.role() != 'service_role' THEN
    RAISE EXCEPTION 'Only service role can update vault secrets';
  END IF;
  
  -- Update the secret
  PERFORM vault.update_secret(p_vault_id::uuid, p_new_secret);
  
  -- Log the update
  INSERT INTO vault_audit_logs (
    operation, vault_id, updated_by, updated_at
  ) VALUES (
    'update', p_vault_id, auth.uid(), now()
  );
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Delete vault secret
CREATE OR REPLACE FUNCTION delete_vault_secret(p_vault_id TEXT) 
RETURNS BOOLEAN AS $$
BEGIN
  -- Only service role can delete secrets
  IF auth.role() != 'service_role' THEN
    RAISE EXCEPTION 'Only service role can delete vault secrets';
  END IF;
  
  -- Delete the secret
  DELETE FROM vault.secrets WHERE id = p_vault_id::uuid;
  
  -- Log the deletion
  INSERT INTO vault_audit_logs (
    operation, vault_id, deleted_by, deleted_at
  ) VALUES (
    'delete', p_vault_id, auth.uid(), now()
  );
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Audit Logging

### Vault Audit Log Table

```sql
CREATE TABLE vault_audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  operation TEXT NOT NULL CHECK (operation IN ('create', 'decrypt', 'update', 'delete')),
  vault_id TEXT NOT NULL,
  secret_name TEXT,
  created_by UUID REFERENCES auth.users(id),
  accessed_by UUID REFERENCES auth.users(id),
  updated_by UUID REFERENCES auth.users(id),
  deleted_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ,
  accessed_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  deleted_at TIMESTAMPTZ,
  metadata JSONB DEFAULT '{}'::jsonb,
  
  -- Ensure at least one timestamp is set
  CONSTRAINT chk_vault_audit_timestamps CHECK (
    created_at IS NOT NULL OR 
    accessed_at IS NOT NULL OR 
    updated_at IS NOT NULL OR 
    deleted_at IS NOT NULL
  )
);

-- Indexes for audit queries
CREATE INDEX idx_vault_audit_logs_vault_id ON vault_audit_logs (vault_id);
CREATE INDEX idx_vault_audit_logs_operation ON vault_audit_logs (operation, created_at DESC);
CREATE INDEX idx_vault_audit_logs_user ON vault_audit_logs (created_by, accessed_by, updated_by, deleted_by);
```

## VaultService Class

### TypeScript Integration

```typescript
import { SupabaseClient } from '@supabase/supabase-js';

export class VaultService {
  constructor(private supabaseClient: SupabaseClient) {}

  /**
   * Store a secret in Supabase Vault
   * @param secret The secret value to encrypt
   * @param name Descriptive name for the secret
   * @param description Optional description
   * @returns Vault UUID for the encrypted secret
   */
  async createSecret(
    secret: string, 
    name: string, 
    description?: string
  ): Promise<string> {
    const { data, error } = await this.supabaseClient.rpc('create_vault_secret', {
      p_secret: secret,
      p_name: name,
      p_description: description
    });

    if (error) {
      throw new Error(`Failed to create vault secret: ${error.message}`);
    }

    return data;
  }

  /**
   * Retrieve and decrypt a secret from Supabase Vault
   * @param vaultId The vault UUID
   * @returns Decrypted secret value
   */
  async getSecret(vaultId: string): Promise<string> {
    const { data, error } = await this.supabaseClient.rpc('vault_decrypt', {
      vault_id: vaultId
    });

    if (error) {
      throw new Error(`Failed to decrypt vault secret: ${error.message}`);
    }

    return data;
  }

  /**
   * Update an existing vault secret
   * @param vaultId The vault UUID
   * @param newSecret The new secret value
   */
  async updateSecret(vaultId: string, newSecret: string): Promise<void> {
    const { error } = await this.supabaseClient.rpc('update_vault_secret', {
      p_vault_id: vaultId,
      p_new_secret: newSecret
    });

    if (error) {
      throw new Error(`Failed to update vault secret: ${error.message}`);
    }
  }

  /**
   * Delete a vault secret
   * @param vaultId The vault UUID
   */
  async deleteSecret(vaultId: string): Promise<void> {
    const { error } = await this.supabaseClient.rpc('delete_vault_secret', {
      p_vault_id: vaultId
    });

    if (error) {
      throw new Error(`Failed to delete vault secret: ${error.message}`);
    }
  }
}
```

## Security Patterns

### OAuth Token Storage Pattern

```typescript
// Store OAuth tokens securely
export async function storeOAuthTokens(
  vaultService: VaultService,
  userId: string,
  providerName: string,
  tokens: {
    access_token: string;
    refresh_token?: string;
    expires_in: number;
  }
): Promise<{
  vault_access_token_id: string;
  vault_refresh_token_id?: string;
}> {
  const timestamp = Date.now();
  
  // Store access token
  const vault_access_token_id = await vaultService.createSecret(
    tokens.access_token,
    `${providerName}_access_token_${userId}_${timestamp}`,
    `${providerName} access token for user ${userId}`
  );

  // Store refresh token if provided
  let vault_refresh_token_id: string | undefined;
  if (tokens.refresh_token) {
    vault_refresh_token_id = await vaultService.createSecret(
      tokens.refresh_token,
      `${providerName}_refresh_token_${userId}_${timestamp}`,
      `${providerName} refresh token for user ${userId}`
    );
  }

  return {
    vault_access_token_id,
    vault_refresh_token_id
  };
}
```

### API Key Storage Pattern

```typescript
// Store API key securely
export async function storeAPIKey(
  vaultService: VaultService,
  userId: string,
  providerName: string,
  apiKey: string,
  keyName?: string
): Promise<string> {
  const timestamp = Date.now();
  const name = keyName || `${providerName}_api_key_${userId}_${timestamp}`;
  
  return await vaultService.createSecret(
    apiKey,
    name,
    `${providerName} API key for user ${userId}`
  );
}
```

### Credential Retrieval Pattern

```typescript
// Retrieve credentials for tool execution
export async function getCredentialsForTool(
  vaultService: SupabaseClient,
  agentId: string,
  providerName: string
): Promise<{
  access_token?: string;
  api_key?: string;
  credential_type: 'oauth' | 'api_key';
}> {
  // Get the connection and permission info
  const { data: permission } = await vaultService
    .from('agent_integration_permissions')
    .select(`
      allowed_scopes,
      user_integration_credentials!inner(
        credential_type,
        vault_access_token_id,
        service_providers!inner(name)
      )
    `)
    .eq('agent_id', agentId)
    .eq('user_integration_credentials.service_providers.name', providerName)
    .eq('is_active', true)
    .single();

  if (!permission) {
    throw new Error(`No active permission found for agent ${agentId} and provider ${providerName}`);
  }

  const connection = permission.user_integration_credentials;
  const credentialType = connection.credential_type;

  // Decrypt the credential
  const { data: decryptedCredential } = await vaultService.rpc('vault_decrypt', {
    vault_id: connection.vault_access_token_id
  });

  if (credentialType === 'oauth') {
    return {
      access_token: decryptedCredential,
      credential_type: 'oauth'
    };
  } else {
    return {
      api_key: decryptedCredential,
      credential_type: 'api_key'
    };
  }
}
```

## Security Triggers

### Prevent Plain-Text Storage

```sql
-- Trigger to ensure no plain-text credentials are stored
CREATE OR REPLACE FUNCTION prevent_plaintext_credentials()
RETURNS TRIGGER AS $$
BEGIN
  -- Ensure deprecated encrypted fields remain NULL
  NEW.encrypted_access_token := NULL;
  NEW.encrypted_refresh_token := NULL;
  
  -- Ensure vault IDs are provided for active connections
  IF NEW.connection_status = 'active' THEN
    IF NEW.vault_access_token_id IS NULL THEN
      RAISE EXCEPTION 'Active connections must have vault_access_token_id';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_prevent_plaintext_credentials
  BEFORE INSERT OR UPDATE ON user_integration_credentials
  FOR EACH ROW EXECUTE FUNCTION prevent_plaintext_credentials();
```

### Vault ID Validation

```sql
-- Validate vault IDs are proper UUIDs
CREATE OR REPLACE FUNCTION validate_vault_ids()
RETURNS TRIGGER AS $$
BEGIN
  -- Validate access token vault ID format
  IF NEW.vault_access_token_id IS NOT NULL THEN
    BEGIN
      PERFORM NEW.vault_access_token_id::uuid;
    EXCEPTION WHEN invalid_text_representation THEN
      RAISE EXCEPTION 'vault_access_token_id must be a valid UUID';
    END;
  END IF;
  
  -- Validate refresh token vault ID format
  IF NEW.vault_refresh_token_id IS NOT NULL THEN
    BEGIN
      PERFORM NEW.vault_refresh_token_id::uuid;
    EXCEPTION WHEN invalid_text_representation THEN
      RAISE EXCEPTION 'vault_refresh_token_id must be a valid UUID';
    END;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validate_vault_ids
  BEFORE INSERT OR UPDATE ON user_integration_credentials
  FOR EACH ROW EXECUTE FUNCTION validate_vault_ids();
```

## Compliance and Standards

### Encryption Standards
- **Algorithm**: AES-256-GCM encryption
- **Key Management**: Supabase managed encryption keys
- **Key Rotation**: Automatic key rotation supported
- **Access Control**: Role-based access with audit trails

### Compliance Features
- **HIPAA**: Healthcare data encryption requirements
- **SOC 2**: Security controls for service organizations
- **ISO 27001**: Information security management
- **GDPR**: European data protection regulation
- **PCI DSS**: Payment card industry data security (when applicable)

### Audit Requirements
- **Complete Logging**: All vault operations logged
- **Immutable Logs**: Audit logs cannot be modified
- **Retention**: Configurable retention periods
- **Access Tracking**: Who accessed what and when
- **Compliance Reports**: Automated compliance reporting

## Performance Considerations

### Caching Strategy
```typescript
// Implement credential caching for performance
class CachedVaultService extends VaultService {
  private cache = new Map<string, { value: string; expires: number }>();
  private cacheTTL = 5 * 60 * 1000; // 5 minutes

  async getSecret(vaultId: string): Promise<string> {
    const cached = this.cache.get(vaultId);
    if (cached && cached.expires > Date.now()) {
      return cached.value;
    }

    const secret = await super.getSecret(vaultId);
    this.cache.set(vaultId, {
      value: secret,
      expires: Date.now() + this.cacheTTL
    });

    return secret;
  }

  clearCache(vaultId?: string): void {
    if (vaultId) {
      this.cache.delete(vaultId);
    } else {
      this.cache.clear();
    }
  }
}
```

### Batch Operations
```sql
-- Function for batch vault operations
CREATE OR REPLACE FUNCTION batch_decrypt_secrets(vault_ids TEXT[])
RETURNS TABLE(vault_id TEXT, secret_value TEXT) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ds.id::text,
    ds.decrypted_secret
  FROM vault.decrypted_secrets ds
  WHERE ds.id = ANY(vault_ids::uuid[]);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Related Documentation

- **[Integration Credentials Schema](integration_credentials_schema.mdc)** - How vault IDs are stored
- **[OAuth Flow Protocol](../02_integrations/oauth_flow_protocol.mdc)** - OAuth token handling
- **[API Key Integration Protocol](../02_integrations/api_key_integration_protocol.mdc)** - API key storage
- **[Security Patterns](../07_security/oauth_security_patterns.mdc)** - Additional security implementations
- **[Backend Services](../06_backend_services/universal_tool_executor.mdc)** - How credentials are used

---

**Last Updated**: September 17, 2025  
**Security Level**: Enterprise-Grade  
**Compliance**: HIPAA, SOC 2, ISO 27001, GDPR Ready