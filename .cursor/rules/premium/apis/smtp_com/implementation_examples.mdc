# SMTP.com Implementation Examples

## Complete Integration Examples for Agentopia

### 1. Enhanced SMTP Configuration Type

```typescript
// src/types/smtp.ts - Enhanced type definitions
interface SMTPComConfiguration extends SMTPConfiguration {
  // API-specific fields
  use_api?: boolean;
  api_key_vault_id?: string;
  api_endpoint?: string;
  webhook_url?: string;
  tracking_enabled?: boolean;
  
  // Advanced settings
  click_tracking?: boolean;
  open_tracking?: boolean;
  unsubscribe_tracking?: boolean;
  custom_headers?: Record<string, string>;
}

interface SMTPComAPIResponse {
  status: 'success' | 'fail' | 'error';
  data?: {
    message_id: string;
    status: 'queued' | 'sent' | 'delivered' | 'bounced';
    created_at: string;
  };
  message?: string;
  code?: number;
}
```

### 2. Supabase Edge Function Integration

```typescript
// supabase/functions/smtp-api/smtp-com-provider.ts
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

export class SMTPComProvider {
  private supabaseClient: any;
  private apiKey: string;
  
  constructor(supabaseClient: any, apiKey: string) {
    this.supabaseClient = supabaseClient;
    this.apiKey = apiKey;
  }
  
  async sendEmail(params: {
    to: string | string[];
    from: string;
    subject: string;
    html?: string;
    text?: string;
    cc?: string | string[];
    bcc?: string | string[];
    reply_to?: string;
    attachments?: Array<{
      filename: string;
      content: string;
      content_type: string;
    }>;
  }): Promise<SMTPComAPIResponse> {
    
    const payload = {
      to: Array.isArray(params.to) ? params.to : [params.to],
      from: params.from,
      subject: params.subject,
      html: params.html,
      text: params.text,
      cc: params.cc ? (Array.isArray(params.cc) ? params.cc : [params.cc]) : undefined,
      bcc: params.bcc ? (Array.isArray(params.bcc) ? params.bcc : [params.bcc]) : undefined,
      reply_to: params.reply_to,
      attachments: params.attachments
    };
    
    // Remove undefined fields
    Object.keys(payload).forEach(key => 
      payload[key] === undefined && delete payload[key]
    );
    
    try {
      const response = await fetch('https://api.smtp.com/v4/messages', {
        method: 'POST',
        headers: {
          'X-SMTPCOM-API': this.apiKey,
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
      
      const result = await response.json();
      
      // Log the operation
      await this.logOperation({
        action: 'send_email',
        status: response.ok ? 'success' : 'error',
        response_code: response.status,
        message_id: result.data?.message_id,
        recipient_count: payload.to.length,
        error_message: result.message
      });
      
      return result;
      
    } catch (error) {
      console.error('[SMTPCom] Send email error:', error);
      
      await this.logOperation({
        action: 'send_email',
        status: 'error',
        error_message: error.message,
        recipient_count: payload.to.length
      });
      
      throw error;
    }
  }
  
  async testConnection(): Promise<boolean> {
    try {
      const response = await fetch('https://api.smtp.com/v4/account', {
        headers: {
          'X-SMTPCOM-API': this.apiKey,
          'Accept': 'application/json'
        }
      });
      
      const result = response.ok;
      
      await this.logOperation({
        action: 'test_connection',
        status: result ? 'success' : 'error',
        response_code: response.status
      });
      
      return result;
      
    } catch (error) {
      console.error('[SMTPCom] Connection test error:', error);
      
      await this.logOperation({
        action: 'test_connection',
        status: 'error',
        error_message: error.message
      });
      
      return false;
    }
  }
  
  async getMessageStatus(messageId: string): Promise<SMTPComAPIResponse> {
    try {
      const response = await fetch(`https://api.smtp.com/v4/messages/${messageId}`, {
        headers: {
          'X-SMTPCOM-API': this.apiKey,
          'Accept': 'application/json'
        }
      });
      
      return await response.json();
      
    } catch (error) {
      console.error('[SMTPCom] Get message status error:', error);
      throw error;
    }
  }
  
  private async logOperation(operation: {
    action: string;
    status: string;
    response_code?: number;
    message_id?: string;
    recipient_count?: number;
    error_message?: string;
  }) {
    try {
      await this.supabaseClient.rpc('log_smtp_operation', {
        provider: 'smtp_com',
        operation_type: operation.action,
        status: operation.status,
        response_code: operation.response_code,
        message_id: operation.message_id,
        recipient_count: operation.recipient_count,
        error_message: operation.error_message,
        metadata: {
          timestamp: new Date().toISOString(),
          api_version: 'v4'
        }
      });
    } catch (error) {
      console.error('[SMTPCom] Logging error:', error);
      // Don't throw - logging failures shouldn't break email sending
    }
  }
}
```

### 3. Enhanced SMTP Function Integration

```typescript
// supabase/functions/smtp-api/index.ts - Enhanced with SMTP.com API support
import { SMTPComProvider } from './smtp-com-provider.ts';

// Add to the main handler
const handleSMTPComAPI = async (
  action: string,
  agentId: string,
  userId: string,
  params: any,
  supabaseClient: any
): Promise<any> => {
  
  // Get configuration with API key
  const { data: config, error: configError } = await supabaseClient
    .from('smtp_configurations')
    .select('*, api_key_vault_id')
    .eq('id', params.smtp_config_id)
    .eq('user_id', userId)
    .eq('is_active', true)
    .single();
    
  if (configError || !config) {
    throw new Error('SMTP configuration not found');
  }
  
  // Get API key from vault if using API mode
  let apiKey: string | null = null;
  if (config.use_api && config.api_key_vault_id) {
    const { data: vaultData, error: vaultError } = await supabaseClient.rpc(
      'get_smtp_api_key',
      { vault_id: config.api_key_vault_id }
    );
    
    if (vaultError || !vaultData) {
      throw new Error('Failed to retrieve API key');
    }
    
    apiKey = vaultData.api_key;
  }
  
  if (config.use_api && apiKey) {
    // Use SMTP.com REST API
    const provider = new SMTPComProvider(supabaseClient, apiKey);
    
    switch (action) {
      case 'send_email':
        return await provider.sendEmail({
          to: params.to,
          from: params.from || config.from_email,
          subject: params.subject,
          html: params.html_body,
          text: params.text_body,
          cc: params.cc,
          bcc: params.bcc,
          reply_to: params.reply_to || config.reply_to_email,
          attachments: params.attachments
        });
        
      case 'test_connection':
        const isConnected = await provider.testConnection();
        return {
          success: isConnected,
          message: isConnected ? 'Connection successful' : 'Connection failed'
        };
        
      case 'get_message_status':
        return await provider.getMessageStatus(params.message_id);
        
      default:
        throw new Error(`Unsupported action: ${action}`);
    }
  } else {
    // Fall back to traditional SMTP relay
    return await handleTraditionalSMTP(action, config, params);
  }
};
```

### 4. Frontend Configuration Component

```typescript
// src/components/integrations/SMTPComConfigForm.tsx
import React, { useState, useEffect } from 'react';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Info, Key, Server } from 'lucide-react';

interface SMTPComConfigFormProps {
  onSave: (config: SMTPComConfiguration) => Promise<void>;
  initialConfig?: SMTPComConfiguration;
}

export const SMTPComConfigForm: React.FC<SMTPComConfigFormProps> = ({
  onSave,
  initialConfig
}) => {
  const [useAPI, setUseAPI] = useState(initialConfig?.use_api || false);
  const [config, setConfig] = useState<Partial<SMTPComConfiguration>>({
    connection_name: initialConfig?.connection_name || '',
    host: 'smtp.smtp.com',
    port: 2525,
    secure: false,
    username: initialConfig?.username || '',
    password: '',
    from_email: initialConfig?.from_email || '',
    from_name: initialConfig?.from_name || '',
    use_api: useAPI,
    api_endpoint: 'https://api.smtp.com/v4',
    tracking_enabled: initialConfig?.tracking_enabled || false,
    ...initialConfig
  });
  
  const [testing, setTesting] = useState(false);
  const [testResult, setTestResult] = useState<string | null>(null);
  
  useEffect(() => {
    setConfig(prev => ({ ...prev, use_api: useAPI }));
  }, [useAPI]);
  
  const handleTest = async () => {
    setTesting(true);
    setTestResult(null);
    
    try {
      // Test the configuration
      const testConfig = { ...config };
      
      if (useAPI) {
        // Test API connection
        const response = await fetch('/api/smtp/test-api', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            api_key: testConfig.password, // API key stored in password field temporarily
            endpoint: testConfig.api_endpoint
          })
        });
        
        const result = await response.json();
        setTestResult(result.success ? 'API connection successful!' : 'API connection failed');
      } else {
        // Test SMTP connection
        const response = await fetch('/api/smtp/test-smtp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(testConfig)
        });
        
        const result = await response.json();
        setTestResult(result.success ? 'SMTP connection successful!' : 'SMTP connection failed');
      }
    } catch (error) {
      setTestResult('Connection test failed');
    } finally {
      setTesting(false);
    }
  };
  
  const handleSave = async () => {
    await onSave(config as SMTPComConfiguration);
  };
  
  return (
    <div className="space-y-6">
      {/* Connection Mode Toggle */}
      <div className="flex items-center space-x-2">
        <Switch
          id="use-api"
          checked={useAPI}
          onCheckedChange={setUseAPI}
        />
        <Label htmlFor="use-api" className="text-sm font-medium">
          Use SMTP.com REST API (Recommended)
        </Label>
      </div>
      
      <Alert>
        <Info className="h-4 w-4" />
        <AlertDescription>
          {useAPI 
            ? "REST API provides better tracking, analytics, and error handling."
            : "SMTP relay is simpler but offers fewer features."
          }
        </AlertDescription>
      </Alert>
      
      {/* Basic Configuration */}
      <div className="grid grid-cols-2 gap-4">
        <div>
          <Label htmlFor="connection_name">Connection Name</Label>
          <Input
            id="connection_name"
            value={config.connection_name}
            onChange={(e) => setConfig(prev => ({ ...prev, connection_name: e.target.value }))}
            placeholder="My SMTP.com Connection"
          />
        </div>
        
        <div>
          <Label htmlFor="from_email">From Email</Label>
          <Input
            id="from_email"
            type="email"
            value={config.from_email}
            onChange={(e) => setConfig(prev => ({ ...prev, from_email: e.target.value }))}
            placeholder="sender@yourdomain.com"
          />
        </div>
      </div>
      
      {/* API Configuration */}
      {useAPI ? (
        <div className="space-y-4 p-4 border rounded-lg">
          <div className="flex items-center space-x-2">
            <Key className="h-4 w-4" />
            <Label className="text-sm font-medium">API Configuration</Label>
          </div>
          
          <div>
            <Label htmlFor="api_key">API Key</Label>
            <Input
              id="api_key"
              type="password"
              value={config.password}
              onChange={(e) => setConfig(prev => ({ ...prev, password: e.target.value }))}
              placeholder="Your SMTP.com API key"
            />
          </div>
          
          <div>
            <Label htmlFor="api_endpoint">API Endpoint</Label>
            <Input
              id="api_endpoint"
              value={config.api_endpoint}
              onChange={(e) => setConfig(prev => ({ ...prev, api_endpoint: e.target.value }))}
              placeholder="https://api.smtp.com/v4"
            />
          </div>
          
          <div className="flex items-center space-x-2">
            <Switch
              id="tracking"
              checked={config.tracking_enabled}
              onCheckedChange={(checked) => setConfig(prev => ({ ...prev, tracking_enabled: checked }))}
            />
            <Label htmlFor="tracking" className="text-sm">
              Enable email tracking (opens, clicks)
            </Label>
          </div>
        </div>
      ) : (
        /* SMTP Configuration */
        <div className="space-y-4 p-4 border rounded-lg">
          <div className="flex items-center space-x-2">
            <Server className="h-4 w-4" />
            <Label className="text-sm font-medium">SMTP Configuration</Label>
          </div>
          
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="host">SMTP Host</Label>
              <Input
                id="host"
                value={config.host}
                onChange={(e) => setConfig(prev => ({ ...prev, host: e.target.value }))}
                placeholder="smtp.smtp.com"
              />
            </div>
            
            <div>
              <Label htmlFor="port">Port</Label>
              <Input
                id="port"
                type="number"
                value={config.port}
                onChange={(e) => setConfig(prev => ({ ...prev, port: parseInt(e.target.value) }))}
                placeholder="2525"
              />
            </div>
          </div>
          
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="username">Username</Label>
              <Input
                id="username"
                value={config.username}
                onChange={(e) => setConfig(prev => ({ ...prev, username: e.target.value }))}
                placeholder="Your SMTP.com username"
              />
            </div>
            
            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={config.password}
                onChange={(e) => setConfig(prev => ({ ...prev, password: e.target.value }))}
                placeholder="Your SMTP.com password"
              />
            </div>
          </div>
        </div>
      )}
      
      {/* Test Result */}
      {testResult && (
        <Alert className={testResult.includes('successful') ? 'border-green-500' : 'border-red-500'}>
          <AlertDescription>{testResult}</AlertDescription>
        </Alert>
      )}
      
      {/* Actions */}
      <div className="flex space-x-2">
        <Button
          type="button"
          variant="outline"
          onClick={handleTest}
          disabled={testing}
        >
          {testing ? 'Testing...' : 'Test Connection'}
        </Button>
        
        <Button onClick={handleSave}>
          Save Configuration
        </Button>
      </div>
    </div>
  );
};
```

### 5. Webhook Handler Example

```typescript
// supabase/functions/smtp-webhooks/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface SMTPComWebhookPayload {
  event: 'delivered' | 'bounced' | 'complained' | 'opened' | 'clicked';
  message_id: string;
  email: string;
  timestamp: string;
  reason?: string;
  user_agent?: string;
  ip?: string;
  url?: string; // For click events
}

serve(async (req) => {
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }
  
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );
    
    const payload: SMTPComWebhookPayload = await req.json();
    
    // Verify webhook signature (if configured)
    const signature = req.headers.get('X-SMTPCOM-Signature');
    if (signature && !verifyWebhookSignature(payload, signature)) {
      return new Response('Invalid signature', { status: 401 });
    }
    
    // Process the webhook event
    await processWebhookEvent(supabase, payload);
    
    return new Response('OK', { status: 200 });
    
  } catch (error) {
    console.error('Webhook processing error:', error);
    return new Response('Internal server error', { status: 500 });
  }
});

async function processWebhookEvent(supabase: any, payload: SMTPComWebhookPayload) {
  // Log the webhook event
  await supabase.from('smtp_webhook_events').insert({
    provider: 'smtp_com',
    event_type: payload.event,
    message_id: payload.message_id,
    recipient_email: payload.email,
    timestamp: payload.timestamp,
    metadata: {
      reason: payload.reason,
      user_agent: payload.user_agent,
      ip: payload.ip,
      url: payload.url
    }
  });
  
  // Update message status if needed
  if (['delivered', 'bounced', 'complained'].includes(payload.event)) {
    await supabase
      .from('smtp_operation_logs')
      .update({
        delivery_status: payload.event,
        delivery_timestamp: payload.timestamp,
        delivery_reason: payload.reason
      })
      .eq('message_id', payload.message_id);
  }
  
  // Handle specific events
  switch (payload.event) {
    case 'bounced':
      await handleBounce(supabase, payload);
      break;
    case 'complained':
      await handleComplaint(supabase, payload);
      break;
    case 'opened':
      await handleOpen(supabase, payload);
      break;
    case 'clicked':
      await handleClick(supabase, payload);
      break;
  }
}

function verifyWebhookSignature(payload: any, signature: string): boolean {
  // Implement webhook signature verification
  // This depends on SMTP.com's webhook signing method
  return true; // Placeholder
}

async function handleBounce(supabase: any, payload: SMTPComWebhookPayload) {
  // Handle bounced email - maybe add to suppression list
  console.log(`Email bounced: ${payload.email}, reason: ${payload.reason}`);
}

async function handleComplaint(supabase: any, payload: SMTPComWebhookPayload) {
  // Handle spam complaint - add to suppression list
  console.log(`Spam complaint: ${payload.email}`);
}

async function handleOpen(supabase: any, payload: SMTPComWebhookPayload) {
  // Track email open
  console.log(`Email opened: ${payload.email}`);
}

async function handleClick(supabase: any, payload: SMTPComWebhookPayload) {
  // Track link click
  console.log(`Link clicked: ${payload.email}, URL: ${payload.url}`);
}
```

### 6. Database Migration for API Support

```sql
-- Migration: Add SMTP.com API support
-- File: supabase/migrations/20250125000003_add_smtpcom_api_support.sql

-- Add API-specific columns to smtp_configurations
ALTER TABLE smtp_configurations 
ADD COLUMN IF NOT EXISTS use_api BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS api_key_vault_id UUID REFERENCES vault.secrets(id),
ADD COLUMN IF NOT EXISTS api_endpoint TEXT DEFAULT 'https://api.smtp.com/v4',
ADD COLUMN IF NOT EXISTS webhook_url TEXT,
ADD COLUMN IF NOT EXISTS tracking_enabled BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS click_tracking BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS open_tracking BOOLEAN DEFAULT FALSE;

-- Create webhook events table
CREATE TABLE IF NOT EXISTS smtp_webhook_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  provider TEXT NOT NULL,
  event_type TEXT NOT NULL,
  message_id TEXT NOT NULL,
  recipient_email TEXT NOT NULL,
  timestamp TIMESTAMPTZ NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add RLS policies for webhook events
ALTER TABLE smtp_webhook_events ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their webhook events" ON smtp_webhook_events
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM smtp_operation_logs 
      WHERE smtp_operation_logs.message_id = smtp_webhook_events.message_id
      AND smtp_operation_logs.user_id = auth.uid()
    )
  );

-- Create function to store SMTP.com API key
CREATE OR REPLACE FUNCTION store_smtpcom_api_key(
  p_user_id UUID,
  p_config_id UUID,
  p_api_key TEXT
) RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_vault_id UUID;
BEGIN
  -- Store API key in vault
  INSERT INTO vault.secrets (name, secret)
  VALUES (
    'smtp_com_api_key_' || p_config_id::text,
    p_api_key
  )
  RETURNING id INTO v_vault_id;
  
  -- Update configuration with vault reference
  UPDATE smtp_configurations 
  SET api_key_vault_id = v_vault_id
  WHERE id = p_config_id AND user_id = p_user_id;
  
  RETURN v_vault_id;
END;
$$;

-- Create function to retrieve SMTP.com API key
CREATE OR REPLACE FUNCTION get_smtpcom_api_key(
  p_vault_id UUID
) RETURNS TABLE(api_key TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT vault.secrets.secret::TEXT
  FROM vault.secrets
  WHERE vault.secrets.id = p_vault_id;
END;
$$;
```

These examples provide a comprehensive foundation for implementing SMTP.com integration in Agentopia, supporting both traditional SMTP relay and modern REST API approaches with proper security, error handling, and monitoring.

---

*Implementation examples for SMTP.com integration in Agentopia*
*Covers both SMTP relay and REST API approaches*