# GetZep Integration Documentation
# Account-Wide Knowledge Graph System

## Overview

GetZep (getzep.com) is our primary knowledge graph and semantic memory provider for Agentopia. It provides a cloud-based, AI-native memory management system that automatically builds knowledge graphs from conversations and documents.

## Architecture

### System Design
```
User Conversations → Chat Function → Memory Manager → Graph Ingestion Queue → GetZep Cloud
                                           ↓
                                    Vector Storage (Pinecone)
                                           ↓
                                    Context Retrieval → AI Response
```

### Key Components
1. **Account-Wide Knowledge Graph**: Single graph per user account, shared across all agents
2. **Graph Ingestion Queue**: Asynchronous processing pipeline for knowledge extraction
3. **GetZep Cloud API**: Managed service for graph construction and querying
4. **Integration with Vector Memory**: Bidirectional references between episodic and semantic memory

## Implementation Details

### API Key Management

GetZep API keys are stored securely in the Supabase Vault and managed through the integrations system:

1. **Storage Location**: `user_oauth_connections` table
2. **Vault Integration**: API key stored in `vault_access_token_id`
3. **Metadata Storage**: Project ID and Account ID stored in `connection_metadata` JSONB field
4. **Permissions**: `['graph_read', 'graph_write', 'memory_read', 'memory_write']`

### Database Schema

#### account_graphs Table
```sql
CREATE TABLE account_graphs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    connection_id UUID REFERENCES user_oauth_connections(id),
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### graph_ingestion_queue Table
```sql
CREATE TABLE graph_ingestion_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    account_graph_id UUID REFERENCES account_graphs(id),
    payload JSONB NOT NULL,  -- Contains: user_id, agent_id, content, entities, relations
    status TEXT DEFAULT 'pending',
    error TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Edge Function: graph-ingestion

The `graph-ingestion` edge function processes queued items and sends them to GetZep:

```typescript
// supabase/functions/graph-ingestion/index.ts
import { ZepClient } from '@getzep/zep-cloud';

// Main processing logic
const client = new ZepClient({ apiKey });

// Add content to user's graph
const episode = await client.graph.add({
    userId: userId,
    type: 'text',  // or 'message' or 'json'
    data: content
});
```

### GetZep v3 API Usage

#### Adding Data to Graph
```typescript
// Three types of data can be added:
// 1. Text data (processed conversations, documents)
await client.graph.add({
    userId: "user_id",
    type: 'text',
    data: "The user is building an AI agent platform..."
});

// 2. Message data (with speaker attribution)
await client.graph.add({
    userId: "user_id",
    type: 'message',
    data: "John: I need help with the GetZep integration"
});

// 3. JSON data (structured information)
await client.graph.add({
    userId: "user_id",
    type: 'json',
    data: JSON.stringify({ name: "Project", status: "active" })
});
```

#### Retrieving Context
```typescript
// Get user context for a query
const context = await client.thread.getUserContext(threadId, {
    query: "What does the user know about GetZep?"
});
```

## Setup Instructions

### 1. Obtain GetZep API Key

1. Sign up at [app.getzep.com](https://app.getzep.com)
2. Create a new project
3. Copy your API key and Account ID

### 2. Configure in Agentopia

1. Navigate to **Settings → Integrations**
2. Find **GetZep** in the list
3. Click **Connect**
4. Enter:
   - API Key: Your GetZep API key
   - Account ID: Your GetZep account ID (optional but recommended)
   - Project ID: Your GetZep project ID (optional)
5. Click **Save**

### 3. Enable Knowledge Graph

The system automatically:
1. Creates an `account_graphs` entry when GetZep is connected
2. Begins processing conversations through the ingestion queue
3. Builds the knowledge graph asynchronously

### 4. Monitor Graph Building

View graph statistics at **Knowledge Graph** in the sidebar:
- Total nodes and edges
- Queue depth
- Last sync time
- Contradiction detection

## Feature Flags

Control knowledge graph features via environment variables:

```env
# Enable/disable features
ENABLE_ACCOUNT_GRAPH=true      # Master switch for graph functionality
ENABLE_GRAPH_FUSION=true        # Combine graph and vector search results
ENABLE_AUTO_EXTRACTION=true     # Automatic entity/relation extraction
ENABLE_GRAPH_UI=true           # Show Knowledge Graph UI

# Rollout control
GRAPH_ROLLOUT_PERCENTAGE=100   # Percentage of users with access
GRAPH_ENABLED_AGENT_IDS=[]     # Specific agents to enable (optional)
GRAPH_ENABLED_USER_IDS=[]      # Specific users to enable (optional)
```

## Integration Points

### 1. Chat Processing Pipeline

The memory manager automatically enqueues content for graph processing:

```typescript
// In supabase/functions/chat/core/memory/memory_manager.ts
await this.queueGraphIngestion({
    source_kind: 'message',
    source_id: messageId,
    agent_id: agentId,
    user_id: userId,
    content: conversationText,
    entities: extractedEntities,
    relations: extractedRelations
});
```

### 2. Context Enrichment

Graph context is injected during the enrichment stage:

```typescript
// In supabase/functions/chat/processor/stages.ts
if (isFeatureEnabled('enable_account_graph', userId, agentId)) {
    const graphContext = await getGraphNeighborhood(
        supabase,
        accountGraphId,
        concepts,
        hopDepth,
        maxResults
    );
    // Add to context window
}
```

### 3. Memory System Instructions

The system message includes specific instructions for handling graph-derived knowledge:

```
=== MEMORY HANDLING INSTRUCTIONS ===
- Use SEMANTIC MEMORY (facts, entities, conclusions/concepts) to ground answers
- Prioritize confidence > recency for semantic facts
- Prefer conclusions/concepts backed by 3–6 connected nodes/edges
- Resolve conflicts by: (1) higher confidence > (2) more evidence > (3) more recent
```

## Troubleshooting

### Common Issues

#### 1. "404 not found" Errors
**Cause**: Incorrect API endpoint or missing user/thread
**Solution**: Ensure using GetZep v3 API methods (`graph.add()` not `graph.add_episode()`)

#### 2. Vault Decryption Errors
**Cause**: Supabase Vault misconfiguration
**Solution**: API keys are stored directly as fallback when Vault fails

#### 3. No Graph Data Appearing
**Check**:
- API key is valid and has correct permissions
- Account ID matches your GetZep dashboard
- Queue items show "completed" status
- Check GetZep dashboard for processing status

### Debugging Commands

```powershell
# Test GetZep connection
npx tsx scripts/tests/check_zep_connection.ts

# Send test data to GetZep
npx tsx scripts/tests/send_to_getzep.ts

# Check queue status
npx tsx scripts/tests/check_queue_status.ts
```

## API Reference

### GetZep Cloud API
- **Documentation**: [help.getzep.com](https://help.getzep.com)
- **SDK Reference**: [docs.getzep.com](https://docs.getzep.com)
- **Dashboard**: [app.getzep.com](https://app.getzep.com)

### Key Endpoints
- **Add Data**: `POST /api/graph/add`
- **Get User Context**: `GET /api/thread/{threadId}/context`
- **Search Graph**: `POST /api/graph/search`

### Useful Links
- [Graph Overview](https://help.getzep.com/graph-overview)
- [Adding Memory](https://help.getzep.com/adding-memory)
- [Adding Data to Graph](https://help.getzep.com/adding-data-to-the-graph)
- [Retrieving Memory](https://help.getzep.com/retrieving-memory)
- [v2 to v3 Migration](https://help.getzep.com/zep-v2-to-v3-migration)

## Best Practices

### 1. Data Ingestion
- Process conversations in real-time, not batch
- Include both user and assistant messages for context
- Use appropriate data types (text vs message vs json)
- Keep individual data chunks under 10,000 characters

### 2. Graph Management
- Monitor graph size and growth rate
- Review contradiction edges regularly
- Implement retention policies for old data
- Use confidence scores for fact validation

### 3. Performance
- Use async processing via queue
- Implement caching for frequently accessed nodes
- Monitor API rate limits
- Optimize query patterns

### 4. Security
- Never expose API keys in client code
- Use RLS policies on database tables
- Audit access to graph data
- Implement user-level isolation

## Metrics and Monitoring

### Key Metrics
- **Graph Size**: Nodes and edges per user
- **Ingestion Rate**: Queue items processed/hour
- **Query Performance**: p95 response times
- **Confidence Scores**: Average fact confidence
- **Contradiction Rate**: Conflicts detected/resolved

### Monitoring Dashboard
Access via **Knowledge Graph** page:
- Live node/edge counts
- Queue depth and processing rate
- Last successful sync
- Error rates and types

## Future Enhancements

### Planned Features
1. **Visual Graph Explorer**: Interactive visualization of knowledge graph
2. **Custom Entity Types**: Domain-specific entity definitions
3. **Fact Rating System**: User feedback on fact accuracy
4. **Graph Merge Tools**: Combine graphs from multiple sources
5. **Export/Import**: Backup and restore graph data

### Research Areas
- Advanced conflict resolution algorithms
- Temporal reasoning improvements
- Multi-agent graph sharing
- Incremental learning from corrections

---

*Last Updated: January 2025*
*Version: 1.0.0*
*Status: Production Ready*