## Next Steps: Technical Guide for MCP-DTMA Deployment

This document provides a technical breakdown of the remaining issues and a step-by-step guide for the next developer to complete the MCP-DTMA integration.

### **1. Primary Blocker: Fix Database Schema for `tool_catalog`**

*   **Problem**: The application attempts to write to a `created_by` column in the `tool_catalog` table when creating a new, unique entry for an MCP template deployment. This column **does not exist in the database schema**, causing the `INSERT` operation to fail with a `400 Bad Request`. This is the root cause of the current deployment failure.
*   **File to Investigate**: `src/lib/services/adminMCPService.ts`, specifically the `ensureToolCatalogEntry` function. This is where the failing `insert` operation is constructed.
*   **Recommended Solution**: Create and apply a new database migration to add the missing column to the `tool_catalog` table. This will align the database schema with the application's expectations.

    *   **Step 1**: From the `supabase` directory, create a new migration file.
        ```bash
        npx supabase migrations new add_created_by_to_tool_catalog
        ```
    *   **Step 2**: Add the following SQL to the newly created migration file. This adds the column and links it to `auth.users`, ensuring data integrity.
        ```sql
        -- Add created_by column to track who created the tool/template
        ALTER TABLE public.tool_catalog
        ADD COLUMN created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL;

        -- Add a comment for clarity
        COMMENT ON COLUMN public.tool_catalog.created_by IS 'The user who created the tool catalog entry.';
        ```
    *   **Step 3**: Apply the migration to the remote database.
        ```bash
        npx supabase db push
        ```
*   **Alternative (Not Recommended)**: Modify the `ensureToolCatalogEntry` function in `adminMCPService.ts` to remove the `created_by` field from the `.insert()` call. This is a faster workaround but sacrifices valuable audit information about who created tool entries.

### **2. Secondary Blocker: Investigate RLS on `tool_catalog`**

*   **Problem**: The browser console logs show a `406 Not Acceptable` error when the application tries to `GET` data from the `tool_catalog` before attempting the `INSERT`. This type of error strongly suggests a Row Level Security (RLS) policy is preventing access.
*   **Action**: After fixing the schema (Step 1), if deployment errors persist, the next step is to review and correct the RLS policies for the `tool_catalog` table.
*   **What to Check**:
    1.  Navigate to the Supabase Dashboard -> Auth -> Policies.
    2.  Use the search filter to find policies associated with the `tool_catalog` table.
    3.  Ensure that policies exist to grant `SELECT` and `INSERT` permissions to the appropriate users (specifically, users with an `admin` role). If no policies exist, or if they are too restrictive, you will need to create or update them.
    4.  A robust set of policies for this table would look like this:
        ```sql
        -- Policy for admins to read all tool catalog entries
        CREATE POLICY "Admins can view all tool catalog entries"
        ON public.tool_catalog FOR SELECT
        TO authenticated
        USING (
          (SELECT user_has_role(auth.uid(), 'admin'))
        );

        -- Policy for admins to create tool catalog entries
        CREATE POLICY "Admins can create tool catalog entries"
        ON public.tool_catalog FOR INSERT
        TO authenticated
        WITH CHECK (
          (SELECT user_has_role(auth.uid(), 'admin'))
        );
        ```
    *   **Note**: The `user_has_role` function is a common helper. If it doesn't exist in your database, you can use the subquery method we implemented elsewhere: `EXISTS (SELECT 1 FROM user_roles ur JOIN roles r ON ur.role_id = r.id WHERE ur.user_id = auth.uid() AND r.name = 'admin')`.

### **3. Final Verification and System Test**

*   **Objective**: Once the schema and RLS issues are resolved, the final step is to confirm the end-to-end deployment workflow is successful.
*   **Test Plan**:
    1.  Log into the application as a user with the `admin` role.
    2.  Navigate to the "MCP Templates" page from the admin sidebar.
    3.  Click the blue "Deploy" button on any template.
    4.  In the deployment modal, select a target droplet from the dropdown list.
    5.  Confirm the deployment.
*   **Success Criteria**:
    *   The deployment process completes without any errors in the browser console.
    *   The UI automatically switches to the "Deployed Servers" tab, where the new server appears with a "deploying" or "running" status.
    *   A new record is successfully created in the `account_tool_instances` table in the database, linking the template to the selected droplet.
    *   A new record for the `deploy` operation appears in the `admin_operation_logs` table.

### **4. Future Enhancement: Full Lifecycle Management UI**

*   **Context**: The backend services for managing a deployed server (`startMCPServer`, `stopMCPServer`, `restartMCPServer`, `deleteMCPServer`) are already implemented in `AdminMCPService.ts`. However, the UI in the "Deployed Servers" tab is currently read-only.
*   **Task**: Implement the UI controls to expose this functionality.
    *   **Action**: In `AdminMCPMarketplaceManagement.tsx`, for each server listed in the "Deployed Servers" tab, add a set of buttons (e.g., `Start`, `Stop`, `Restart`, `Delete`).
    *   **Implementation**: Wire these buttons' `onClick` handlers to call the corresponding methods in the `adminMCPService` instance. Ensure the server list is refreshed after each action to reflect the new status. 