# API Endpoint Design Planning for Temporary Chat Links

## Planning Summary

This document outlines the comprehensive API endpoint architecture for temporary chat links, including Edge Function design, request/response patterns, and integration with existing systems.

## API Architecture Overview

### 1. Edge Function Structure

#### Core Edge Functions
```typescript
// 1. temporary-chat-mcp (MCP Tool Interface)
supabase/functions/temporary-chat-mcp/index.ts

// 2. temporary-chat-api (Public API Interface)  
supabase/functions/temporary-chat-api/index.ts

// 3. temporary-chat-events (Real-time SSE)
supabase/functions/temporary-chat-events/index.ts

// 4. temporary-chat-handler (Message Processing)
supabase/functions/temporary-chat-handler/index.ts
```

### 2. MCP Tool Integration

#### Tool Registration in Universal Tool Executor
```typescript
// Add to TOOL_ROUTING_MAP in universal-tool-executor.ts
const TOOL_ROUTING_MAP = {
  // ... existing tools ...
  
  // Temporary Chat Tools
  'create_temporary_chat_link': 'temporary-chat-mcp',
  'list_temporary_chat_links': 'temporary-chat-mcp', 
  'update_temporary_chat_link': 'temporary-chat-mcp',
  'delete_temporary_chat_link': 'temporary-chat-mcp',
  'get_temporary_chat_analytics': 'temporary-chat-mcp',
  'manage_temporary_chat_session': 'temporary-chat-mcp'
};
```

#### MCP Tool Definitions
```typescript
// temporary-chat-mcp/index.ts
export const TEMPORARY_CHAT_TOOLS = [
  {
    name: 'create_temporary_chat_link',
    description: 'Create a temporary chat link for an agent',
    inputSchema: {
      type: 'object',
      properties: {
        agent_id: { type: 'string', format: 'uuid' },
        title: { type: 'string', maxLength: 200 },
        description: { type: 'string', maxLength: 1000 },
        welcome_message: { type: 'string', maxLength: 2000 },
        expires_in_hours: { type: 'number', minimum: 1, maximum: 168 }, // 1 hour to 7 days
        max_sessions: { type: 'number', minimum: 1, maximum: 50 },
        max_messages_per_session: { type: 'number', minimum: 1, maximum: 1000 },
        session_timeout_minutes: { type: 'number', minimum: 5, maximum: 1440 },
        rate_limit_per_minute: { type: 'number', minimum: 1, maximum: 100 },
        allowed_domains: { type: 'array', items: { type: 'string' } },
        ui_customization: { type: 'object' }
      },
      required: ['agent_id', 'title', 'expires_in_hours']
    }
  },
  {
    name: 'list_temporary_chat_links',
    description: 'List temporary chat links for user or agent',
    inputSchema: {
      type: 'object',
      properties: {
        agent_id: { type: 'string', format: 'uuid' },
        include_inactive: { type: 'boolean', default: false },
        limit: { type: 'number', minimum: 1, maximum: 100, default: 20 },
        offset: { type: 'number', minimum: 0, default: 0 }
      }
    }
  },
  {
    name: 'get_temporary_chat_analytics',
    description: 'Get analytics for temporary chat links',
    inputSchema: {
      type: 'object',
      properties: {
        agent_id: { type: 'string', format: 'uuid' },
        days_back: { type: 'number', minimum: 1, maximum: 365, default: 30 },
        include_session_details: { type: 'boolean', default: false }
      }
    }
  }
];
```

### 3. Public API Endpoints

#### temporary-chat-api Edge Function
```typescript
// supabase/functions/temporary-chat-api/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
};

interface ValidateSessionRequest {
  session_token: string;
}

interface CreateSessionRequest {
  link_token: string;
  participant_identifier?: string;
  participant_name?: string;
  metadata?: Record<string, any>;
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const url = new URL(req.url);
    const path = url.pathname;

    // Route handling
    switch (path) {
      case '/validate':
        return await handleValidateSession(req, supabase);
      
      case '/create-session':
        return await handleCreateSession(req, supabase);
      
      case '/end-session':
        return await handleEndSession(req, supabase);
      
      default:
        return new Response('Not Found', { 
          status: 404, 
          headers: corsHeaders 
        });
    }
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }), 
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  }
});

async function handleValidateSession(req: Request, supabase: any) {
  const { session_token }: ValidateSessionRequest = await req.json();
  
  const { data, error } = await supabase.rpc('validate_temp_chat_session', {
    p_session_token: session_token
  });

  if (error) {
    return new Response(
      JSON.stringify({ error: 'Session validation failed' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  if (!data || data.length === 0 || !data[0].is_valid) {
    return new Response(
      JSON.stringify({ error: 'Invalid or expired session' }),
      { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  const sessionInfo = data[0];
  
  return new Response(
    JSON.stringify({
      session_id: sessionInfo.session_id,
      agent_id: sessionInfo.agent_id,
      agent_name: sessionInfo.agent_name,
      conversation_id: sessionInfo.conversation_id,
      title: sessionInfo.title,
      description: sessionInfo.description,
      welcome_message: sessionInfo.welcome_message,
      max_messages: sessionInfo.max_messages_per_session,
      current_messages: sessionInfo.current_message_count,
      rate_limit: sessionInfo.rate_limit_per_minute,
      expires_at: sessionInfo.expires_at
    }),
    { 
      status: 200, 
      headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
    }
  );
}

async function handleCreateSession(req: Request, supabase: any) {
  const { 
    link_token, 
    participant_identifier, 
    participant_name,
    metadata = {}
  }: CreateSessionRequest = await req.json();
  
  // Get client IP and user agent for security
  const clientIP = req.headers.get('cf-connecting-ip') || 
                   req.headers.get('x-forwarded-for') || 
                   'unknown';
  const userAgent = req.headers.get('user-agent') || '';
  const referrer = req.headers.get('referer') || '';

  const { data, error } = await supabase.rpc('create_temp_chat_session', {
    p_link_token: link_token,
    p_participant_identifier: participant_identifier,
    p_participant_name: participant_name,
    p_ip_address: clientIP,
    p_user_agent: userAgent,
    p_referrer: referrer
  });

  if (error || !data || data.length === 0) {
    return new Response(
      JSON.stringify({ 
        error: data?.[0]?.error_message || 'Failed to create session' 
      }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  const sessionData = data[0];
  
  if (!sessionData.is_valid) {
    return new Response(
      JSON.stringify({ error: sessionData.error_message }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  return new Response(
    JSON.stringify({
      session_id: sessionData.session_id,
      session_token: sessionData.session_token,
      conversation_id: sessionData.conversation_id,
      agent_id: sessionData.agent_id,
      agent_name: sessionData.agent_name
    }),
    { 
      status: 201, 
      headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
    }
  );
}
```

### 4. Real-time Events (SSE)

#### temporary-chat-events Edge Function
```typescript
// supabase/functions/temporary-chat-events/index.ts
serve(async (req) => {
  const url = new URL(req.url);
  const sessionToken = url.searchParams.get('session_token');
  
  if (!sessionToken) {
    return new Response('Missing session token', { status: 400 });
  }

  // Validate session
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  const { data: sessionData } = await supabase.rpc('validate_temp_chat_session', {
    p_session_token: sessionToken
  });

  if (!sessionData?.[0]?.is_valid) {
    return new Response('Invalid session', { status: 401 });
  }

  const conversationId = sessionData[0].conversation_id;

  // Set up SSE stream
  const stream = new ReadableStream({
    start(controller) {
      // Send initial connection event
      const encoder = new TextEncoder();
      controller.enqueue(encoder.encode(`data: ${JSON.stringify({
        type: 'connected',
        timestamp: new Date().toISOString()
      })}\n\n`));

      // Set up Supabase real-time subscription (service role can access)
      const channel = supabase
        .channel(`temp-chat-${conversationId}`)
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'chat_messages_v2',
            filter: `conversation_id=eq.${conversationId}`,
          },
          (payload) => {
            const message = payload.new;
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({
              type: 'message',
              message: {
                id: message.id,
                role: message.role,
                content: message.content,
                timestamp: message.created_at
              }
            })}\n\n`));
          }
        )
        .subscribe();

      // Cleanup on disconnect
      const cleanup = () => {
        supabase.removeChannel(channel);
      };

      // Handle client disconnect
      req.signal?.addEventListener('abort', cleanup);
      
      // Periodic heartbeat
      const heartbeat = setInterval(() => {
        try {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({
            type: 'heartbeat',
            timestamp: new Date().toISOString()
          })}\n\n`));
        } catch {
          clearInterval(heartbeat);
          cleanup();
        }
      }, 30000); // 30 second heartbeat
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    }
  });
});
```

### 5. Message Processing

#### temporary-chat-handler Edge Function
```typescript
// supabase/functions/temporary-chat-handler/index.ts
interface SendMessageRequest {
  session_token: string;
  message: string;
  message_type?: 'text' | 'file';
  metadata?: Record<string, any>;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  const { session_token, message, message_type = 'text', metadata = {} }: SendMessageRequest = await req.json();

  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  // Validate session and get info
  const { data: sessionData } = await supabase.rpc('validate_temp_chat_session', {
    p_session_token: session_token
  });

  if (!sessionData?.[0]?.is_valid) {
    return new Response(
      JSON.stringify({ error: 'Invalid or expired session' }),
      { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  const session = sessionData[0];

  // Rate limiting check
  const now = new Date();
  const { data: recentMessages } = await supabase
    .from('temporary_chat_sessions')
    .select('messages_in_current_minute, last_message_at')
    .eq('session_token', session_token)
    .single();

  if (recentMessages) {
    const lastMessageTime = new Date(recentMessages.last_message_at);
    const timeDiff = (now.getTime() - lastMessageTime.getTime()) / 1000 / 60; // minutes

    if (timeDiff < 1 && recentMessages.messages_in_current_minute >= session.rate_limit) {
      return new Response(
        JSON.stringify({ error: 'Rate limit exceeded' }),
        { status: 429, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
  }

  // Save user message to chat_messages_v2
  const { data: userMessage, error: userMessageError } = await supabase
    .from('chat_messages_v2')
    .insert({
      conversation_id: session.conversation_id,
      role: 'user',
      content: { text: message, type: message_type, metadata },
      sender_user_id: null, // Anonymous user
      sender_agent_id: null
    })
    .select()
    .single();

  if (userMessageError) {
    return new Response(
      JSON.stringify({ error: 'Failed to save message' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  // Update session metrics
  await supabase
    .from('temporary_chat_sessions')
    .update({
      message_count: session.current_message_count + 1,
      last_activity_at: now.toISOString(),
      last_message_at: now.toISOString(),
      messages_in_current_minute: recentMessages?.messages_in_current_minute + 1 || 1,
      total_characters_sent: (session.total_characters_sent || 0) + message.length
    })
    .eq('session_token', session_token);

  // Process with agent (call chat function)
  try {
    const { data: chatResponse } = await supabase.functions.invoke('chat', {
      body: {
        message,
        conversationId: session.conversation_id,
        agentId: session.agent_id,
        sessionType: 'temporary_chat',
        sessionToken: session_token
      }
    });

    return new Response(
      JSON.stringify({ 
        success: true,
        message_id: userMessage.id,
        conversation_id: session.conversation_id
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: 'Failed to process message with agent' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

## Integration Points

### 1. Universal Tool Executor Updates
- Add temporary chat tools to `TOOL_ROUTING_MAP`
- Update tool authorization logic for temporary chat context

### 2. Chat Function Integration
- Modify existing `chat` Edge Function to handle temporary sessions
- Add session type discrimination
- Ensure proper message attribution

### 3. Supabase Configuration
- Update `config.toml` for new Edge Functions
- Configure `verify_jwt = false` for public endpoints

## Security Considerations

### 1. Token Validation
- Cryptographic token generation
- Expiration time validation
- Rate limiting per token/IP
- Session isolation

### 2. Input Sanitization
- Message content validation
- File upload restrictions
- Metadata size limits
- SQL injection prevention

### 3. Resource Protection
- Connection limits per IP
- Memory usage monitoring
- CPU time limits
- Storage quota enforcement

This API endpoint design provides a comprehensive, secure, and scalable foundation for temporary chat links functionality.


