# Authentication and Security Research for Temporary Chat Links

## Research Summary

This document analyzes the current authentication and security architecture in Agentopia to understand how to implement secure public access for temporary chat links while maintaining system security and preventing abuse.

## Current Authentication Architecture

### 1. Frontend Authentication (`AuthContext`)
- **Supabase Auth Integration**: Uses `@supabase/auth-helpers-react`
- **JWT Token Management**: Automatic token refresh and validation
- **Route Protection**: Three levels - 'public', 'protected', 'admin'
- **Session Management**: Persistent sessions with automatic renewal

### 2. Route Protection System

#### Route Configuration (`routeConfig.tsx`)
```typescript
export type ProtectionType = 'public' | 'protected' | 'admin';

// Examples of public routes
{ path: '/login', element: LoginPage, protection: 'public', layout: false },
{ path: '/register', element: RegisterPage, protection: 'public', layout: false },
{ path: '/unauthorized', element: UnauthorizedPage, protection: 'public', layout: false },
```

#### Router Implementation (`AppRouter.tsx`)
- **Public Route Handling**: Redirects authenticated users away from login/register
- **Protected Route Enforcement**: Requires authentication for protected routes
- **Admin Route Validation**: Additional admin role checking

### 3. Edge Function Authentication Patterns

#### JWT Verification Configuration (`supabase/config.toml`)
```toml
[functions.chat]
enabled = true
verify_jwt = false  # Allows bypassing JWT for CORS and public access
entrypoint = "./functions/chat/index.ts"

[functions.task-executor]
enabled = true
verify_jwt = false  # Runtime auth validation instead
entrypoint = "./functions/task-executor/index.ts"
```

#### Authentication Patterns in Edge Functions

##### Pattern 1: Required Authentication
```typescript
// Most edge functions require authentication
const authHeader = req.headers.get('Authorization');
if (!authHeader) {
  throw new Error('Missing authorization header');
}

const { data: { user }, error: authError } = await supabase.auth.getUser(
  authHeader.replace('Bearer ', '')
);

if (authError || !user) {
  throw new Error('Invalid authentication token');
}
```

##### Pattern 2: Optional Authentication with Service Role Fallback
```typescript
// Universal Tool Executor pattern
if (authToken && authToken.trim().length > 0) {
  invokeOptions.headers = {
    'Authorization': `Bearer ${authToken}`
  };
} else {
  // Uses service role by default
  console.log('No valid auth token provided - using service role');
}
```

##### Pattern 3: Public Access with Validation
```typescript
// Handle CORS without authentication
if (req.method === 'OPTIONS') {
  return new Response('ok', { headers: corsHeaders });
}

// Then validate specific parameters or tokens
```

## RLS (Row Level Security) Architecture

### Current RLS Patterns

#### 1. User-Scoped Policies
```sql
-- Users can only access their own data
CREATE POLICY "Users can view their own agents" ON agents
  FOR SELECT USING (auth.uid() = user_id);
```

#### 2. Service Role Bypass
```sql
-- Service role has full access for system operations
CREATE POLICY "Service role full access" ON table_name
  FOR ALL USING (auth.role() = 'service_role');
```

#### 3. Agent-Based Permissions
```sql
-- Users can access data through their agents
CREATE POLICY "Users access via agents" ON some_table
  FOR SELECT USING (
    agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
  );
```

## Security Implementation Strategy for Temporary Chat Links

### 1. Public Route Implementation

#### Frontend Route Addition
```typescript
// Add to routeConfig.tsx
{ 
  path: '/temp-chat/:token', 
  element: TempChatPage, 
  protection: 'public', 
  layout: false 
}
```

#### No Authentication Required
- Public access without login
- No JWT token validation
- Lightweight chat interface

### 2. Edge Function Security Model

#### Create Public Chat Handler
```typescript
// supabase/functions/temporary-chat-handler/index.ts
serve(async (req: Request) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  // No authentication required - validate session token instead
  const { session_token, message, action } = await req.json();
  
  // Validate session token against temporary_chat_sessions table
  const session = await validateSessionToken(session_token);
  if (!session) {
    return new Response(JSON.stringify({ error: 'Invalid session' }), 
      { status: 401 });
  }

  // Process chat message with service role
  return await processChatMessage(session, message);
});
```

#### Configure Edge Function
```toml
# supabase/config.toml
[functions.temporary-chat-handler]
enabled = true
verify_jwt = false  # Public access
entrypoint = "./functions/temporary-chat-handler/index.ts"

[functions.temporary-chat-api]
enabled = true
verify_jwt = false  # Public access for session management
entrypoint = "./functions/temporary-chat-api/index.ts"
```

### 3. Database Security Model

#### Session Token Validation
Instead of user authentication, use session token validation:

```sql
-- Validate session token and return session info
CREATE OR REPLACE FUNCTION validate_temp_chat_session(
  p_session_token TEXT
) RETURNS TABLE (
  session_id UUID,
  link_id UUID,
  agent_id UUID,
  is_active BOOLEAN,
  expires_at TIMESTAMPTZ
) 
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    tcs.id,
    tcs.link_id,
    tcl.agent_id,
    (tcs.status = 'active' AND tcl.is_active AND tcl.expires_at > NOW()) as is_active,
    tcl.expires_at
  FROM temporary_chat_sessions tcs
  JOIN temporary_chat_links tcl ON tcs.link_id = tcl.id
  WHERE tcs.session_token = p_session_token;
END;
$$ LANGUAGE plpgsql;
```

#### RLS Policies for Temporary Tables

```sql
-- Temporary chat links - user access only
CREATE POLICY "Users manage own temp links" ON temporary_chat_links
  FOR ALL USING (user_id = auth.uid());

-- Service role full access
CREATE POLICY "Service role full access temp links" ON temporary_chat_links
  FOR ALL USING (auth.role() = 'service_role');

-- Temporary chat sessions - service role only (no user access)
CREATE POLICY "Service role only temp sessions" ON temporary_chat_sessions
  FOR ALL USING (auth.role() = 'service_role');
```

#### Message Storage Security
```sql
-- Chat messages for temporary sessions
CREATE POLICY "Temp chat messages service role only" ON chat_messages_v2
  FOR ALL USING (
    auth.role() = 'service_role' OR
    (sender_user_id = auth.uid()) OR  -- Regular user messages
    (sender_agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid()))  -- Agent messages
  );
```

### 4. Rate Limiting and Abuse Prevention

#### Session-Level Rate Limiting
```typescript
interface RateLimitConfig {
  maxMessagesPerMinute: number;
  maxMessagesPerSession: number;
  maxSessionDuration: number;
  cooldownPeriod: number;
}

async function checkRateLimit(sessionId: string, config: RateLimitConfig): Promise<boolean> {
  // Check message frequency
  // Check total messages
  // Check session duration
  // Implement IP-based limiting
}
```

#### IP-Based Protection
```typescript
async function validateIPAccess(ipAddress: string, linkId: string): Promise<boolean> {
  // Check IP against allowed domains (if configured)
  // Check IP rate limiting
  // Check for blocked IPs
  return true;
}
```

#### Content Filtering
```typescript
async function validateMessageContent(content: string): Promise<boolean> {
  // Basic spam detection
  // Profanity filtering
  // Length validation
  // Pattern matching for abuse
  return true;
}
```

### 5. Session Management Security

#### Secure Token Generation
```typescript
function generateSecureToken(): string {
  // Use crypto.randomUUID() for session tokens
  // Use crypto.getRandomValues() for additional entropy
  return crypto.randomUUID() + '-' + Date.now().toString(36);
}
```

#### Session Lifecycle Management
```typescript
interface SessionSecurity {
  maxIdleTime: number;        // 30 minutes default
  absoluteTimeout: number;    // 24 hours max
  requiresHeartbeat: boolean; // Keep-alive mechanism
  autoCleanup: boolean;       // Automatic cleanup
}
```

#### Secure Session Storage
```sql
-- Session table with security fields
CREATE TABLE temporary_chat_sessions (
  -- ... other fields ...
  
  -- Security tracking
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_activity_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Rate limiting
  message_count INTEGER DEFAULT 0,
  last_message_at TIMESTAMPTZ,
  
  -- Status tracking
  status TEXT DEFAULT 'active',
  end_reason TEXT,
  security_flags JSONB DEFAULT '{}'
);
```

### 6. Data Privacy and Cleanup

#### Automatic Data Cleanup
```sql
-- Cleanup function for expired sessions
CREATE OR REPLACE FUNCTION cleanup_expired_temp_sessions()
RETURNS void AS $$
BEGIN
  -- Mark expired sessions
  UPDATE temporary_chat_sessions 
  SET status = 'expired', ended_at = NOW()
  WHERE status = 'active' 
    AND (last_activity_at < NOW() - INTERVAL '30 minutes'
         OR created_at < NOW() - INTERVAL '24 hours');
  
  -- Archive old messages (optional)
  -- DELETE FROM chat_messages_v2 WHERE conversation_id IN (...)
END;
$$ LANGUAGE plpgsql;
```

#### Scheduled Cleanup
```sql
-- pg_cron job for regular cleanup
SELECT cron.schedule('cleanup-temp-sessions', '*/15 * * * *', 'SELECT cleanup_expired_temp_sessions();');
```

### 7. Audit and Monitoring

#### Security Event Logging
```typescript
interface SecurityEvent {
  event_type: 'session_created' | 'session_expired' | 'rate_limit_hit' | 'invalid_token';
  session_id?: string;
  ip_address: string;
  user_agent: string;
  metadata: Record<string, any>;
  timestamp: Date;
}

async function logSecurityEvent(event: SecurityEvent): Promise<void> {
  // Log to database or external service
  // Could use Supabase Edge Functions logging
}
```

#### Monitoring Metrics
- Active session count
- Message rate per session
- Failed authentication attempts
- Unusual IP patterns
- Session duration statistics

### 8. Integration with Existing Security

#### Leverage Existing Infrastructure
- **CORS Handling**: Use existing `corsHeaders` patterns
- **Error Handling**: Follow existing error response patterns
- **Logging**: Use existing logging infrastructure
- **Rate Limiting**: Extend existing rate limiting patterns

#### Service Role Usage
```typescript
// Initialize with service role for public endpoints
const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const supabase = createClient(supabaseUrl, supabaseServiceKey);
```

## Security Risks and Mitigation

### 1. Denial of Service (DoS)
- **Risk**: Flooding with chat requests
- **Mitigation**: Rate limiting, session limits, IP blocking

### 2. Data Exposure
- **Risk**: Unauthorized access to agent data
- **Mitigation**: Strict RLS policies, session validation, no user data exposure

### 3. Session Hijacking
- **Risk**: Session token theft or reuse
- **Mitigation**: Secure token generation, IP validation, session expiration

### 4. Content Abuse
- **Risk**: Spam, inappropriate content
- **Mitigation**: Content filtering, rate limiting, session termination

### 5. Resource Exhaustion
- **Risk**: High compute/storage usage
- **Mitigation**: Session limits, message limits, automatic cleanup

## Implementation Recommendations

### Phase 1: Core Security
1. **Create public routes** with no authentication
2. **Implement session token validation** system
3. **Add basic rate limiting** and abuse prevention
4. **Set up automatic cleanup** processes

### Phase 2: Enhanced Security
1. **Add IP-based restrictions** and monitoring
2. **Implement content filtering** and validation
3. **Add comprehensive audit logging**
4. **Create security monitoring dashboard**

### Phase 3: Advanced Features
1. **Add domain-based restrictions**
2. **Implement advanced threat detection**
3. **Add real-time security monitoring**
4. **Create automated response systems**

## File Dependencies for Implementation

### New Security Files:
- `supabase/functions/temporary-chat-handler/security.ts`
- `supabase/functions/temporary-chat-api/validation.ts`
- `supabase/functions/_shared/temp-chat-security.ts`

### Modified Security Files:
- `src/routing/routeConfig.tsx` (add public routes)
- `supabase/config.toml` (add public edge functions)

### Database Security:
- Migration files with RLS policies
- Security functions for validation
- Cleanup and monitoring procedures

## Backup Requirements

Before implementing:
- Backup current RLS policies
- Backup existing edge function configurations
- Test security model on development environment
- Document all security assumptions and limitations
