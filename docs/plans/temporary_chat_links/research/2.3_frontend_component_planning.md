# Frontend Component Planning for Temporary Chat Links

## Planning Summary

This document outlines the comprehensive frontend component architecture for temporary chat links, including both the management interface for authenticated users and the public chat interface for anonymous users.

## Component Architecture Overview

### 1. Management Interface Components (Authenticated)

#### Core Management Components
```typescript
// Component hierarchy for authenticated users
src/components/temporary-chat/
├── management/
│   ├── TempChatLinkManager.tsx        // Main management interface
│   ├── TempChatLinkCard.tsx          // Individual link display
│   ├── CreateTempChatModal.tsx       // Link creation modal
│   ├── EditTempChatModal.tsx         // Link editing modal
│   ├── TempChatAnalytics.tsx         // Analytics dashboard
│   ├── TempChatSessionList.tsx       // Active sessions list
│   └── TempChatSettings.tsx          // Link configuration
├── public/
│   ├── TempChatInterface.tsx         // Public chat interface
│   ├── TempChatHeader.tsx           // Public chat header
│   ├── TempChatMessages.tsx         // Message display
│   ├── TempChatInput.tsx            // Message input
│   └── TempChatStatus.tsx           // Connection status
└── shared/
    ├── TempChatTypes.ts             // TypeScript definitions
    ├── TempChatHooks.ts             // Custom hooks
    └── TempChatUtils.ts             // Utility functions
```

#### TempChatLinkManager Component
```typescript
// src/components/temporary-chat/management/TempChatLinkManager.tsx
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Plus, Settings, BarChart3, ExternalLink, Copy, Trash2 } from 'lucide-react';
import { TempChatLinkCard } from './TempChatLinkCard';
import { CreateTempChatModal } from './CreateTempChatModal';
import { TempChatAnalytics } from './TempChatAnalytics';

interface TempChatLink {
  id: string;
  agent_id: string;
  agent_name: string;
  title: string;
  description?: string;
  link_token: string;
  expires_at: string;
  is_active: boolean;
  session_count: number;
  total_messages: number;
  max_sessions: number;
  created_at: string;
  last_accessed_at?: string;
}

export function TempChatLinkManager({ agentId }: { agentId?: string }) {
  const [links, setLinks] = useState<TempChatLink[]>([]);
  const [loading, setLoading] = useState(true);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showAnalytics, setShowAnalytics] = useState(false);
  const [selectedAgent, setSelectedAgent] = useState<string | undefined>(agentId);

  useEffect(() => {
    loadTempChatLinks();
  }, [selectedAgent]);

  const loadTempChatLinks = async () => {
    setLoading(true);
    try {
      // Call MCP tool to list temporary chat links
      const response = await fetch('/api/agent-tools/execute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tool_name: 'list_temporary_chat_links',
          parameters: {
            agent_id: selectedAgent,
            include_inactive: false
          }
        })
      });

      const result = await response.json();
      if (result.success) {
        setLinks(result.data.links || []);
      }
    } catch (error) {
      console.error('Failed to load temporary chat links:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateLink = async (linkData: any) => {
    try {
      const response = await fetch('/api/agent-tools/execute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tool_name: 'create_temporary_chat_link',
          parameters: {
            agent_id: selectedAgent,
            ...linkData
          }
        })
      });

      const result = await response.json();
      if (result.success) {
        await loadTempChatLinks(); // Refresh list
        setShowCreateModal(false);
      }
    } catch (error) {
      console.error('Failed to create temporary chat link:', error);
    }
  };

  const copyLinkToClipboard = async (token: string) => {
    const fullUrl = `${window.location.origin}/temp-chat/${token}`;
    await navigator.clipboard.writeText(fullUrl);
    // Show toast notification
  };

  const getStatusBadge = (link: TempChatLink) => {
    const now = new Date();
    const expires = new Date(link.expires_at);
    
    if (!link.is_active) {
      return <Badge variant="secondary">Inactive</Badge>;
    } else if (expires < now) {
      return <Badge variant="destructive">Expired</Badge>;
    } else if (link.session_count >= link.max_sessions) {
      return <Badge variant="outline">Full</Badge>;
    } else {
      return <Badge variant="default">Active</Badge>;
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold">Temporary Chat Links</h2>
          <p className="text-muted-foreground">
            Create and manage temporary chat links for your agents
          </p>
        </div>
        <div className="flex items-center space-x-2">
          <Button 
            variant="outline" 
            onClick={() => setShowAnalytics(true)}
          >
            <BarChart3 className="h-4 w-4 mr-2" />
            Analytics
          </Button>
          <Button onClick={() => setShowCreateModal(true)}>
            <Plus className="h-4 w-4 mr-2" />
            Create Link
          </Button>
        </div>
      </div>

      {/* Links Grid */}
      {links.length === 0 ? (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <ExternalLink className="h-12 w-12 text-muted-foreground mb-4" />
            <h3 className="text-lg font-semibold mb-2">No temporary chat links</h3>
            <p className="text-muted-foreground text-center mb-4">
              Create your first temporary chat link to allow others to chat with your agent
            </p>
            <Button onClick={() => setShowCreateModal(true)}>
              <Plus className="h-4 w-4 mr-2" />
              Create Link
            </Button>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {links.map((link) => (
            <TempChatLinkCard 
              key={link.id} 
              link={link}
              onCopyLink={() => copyLinkToClipboard(link.link_token)}
              onRefresh={loadTempChatLinks}
            />
          ))}
        </div>
      )}

      {/* Modals */}
      <CreateTempChatModal
        isOpen={showCreateModal}
        onClose={() => setShowCreateModal(false)}
        onSubmit={handleCreateLink}
        agentId={selectedAgent}
      />

      <TempChatAnalytics
        isOpen={showAnalytics}
        onClose={() => setShowAnalytics(false)}
        agentId={selectedAgent}
      />
    </div>
  );
}
```

#### CreateTempChatModal Component
```typescript
// src/components/temporary-chat/management/CreateTempChatModal.tsx
import React, { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

interface CreateTempChatModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: any) => Promise<void>;
  agentId?: string;
}

export function CreateTempChatModal({ isOpen, onClose, onSubmit, agentId }: CreateTempChatModalProps) {
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    welcome_message: '',
    expires_in_hours: 24,
    max_sessions: 1,
    max_messages_per_session: 100,
    session_timeout_minutes: 30,
    rate_limit_per_minute: 10,
    allowed_domains: [] as string[],
    ui_customization: {}
  });
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    
    try {
      await onSubmit({
        ...formData,
        agent_id: agentId
      });
    } finally {
      setLoading(false);
    }
  };

  const presetConfigs = [
    {
      name: 'Quick Support Chat',
      config: {
        title: 'Customer Support Chat',
        description: 'Get help with your questions',
        expires_in_hours: 2,
        max_sessions: 5,
        max_messages_per_session: 50,
        session_timeout_minutes: 15
      }
    },
    {
      name: 'Daily Check-in',
      config: {
        title: 'Daily Planning Session',
        description: 'Share your plans for today',
        expires_in_hours: 4,
        max_sessions: 1,
        max_messages_per_session: 20,
        session_timeout_minutes: 30
      }
    },
    {
      name: 'Feedback Collection',
      config: {
        title: 'Share Your Feedback',
        description: 'Help us improve by sharing your thoughts',
        expires_in_hours: 168, // 7 days
        max_sessions: 100,
        max_messages_per_session: 25,
        session_timeout_minutes: 20
      }
    }
  ];

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Create Temporary Chat Link</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Quick Presets */}
          <Card>
            <CardHeader>
              <CardTitle className="text-sm">Quick Presets</CardTitle>
              <CardDescription>Start with a common configuration</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
                {presetConfigs.map((preset) => (
                  <Button
                    key={preset.name}
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => setFormData({ ...formData, ...preset.config })}
                  >
                    {preset.name}
                  </Button>
                ))}
              </div>
            </CardContent>
          </Card>

          {/* Basic Information */}
          <div className="grid grid-cols-1 gap-4">
            <div>
              <Label htmlFor="title">Title *</Label>
              <Input
                id="title"
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                placeholder="e.g., Customer Support Chat"
                maxLength={200}
                required
              />
            </div>

            <div>
              <Label htmlFor="description">Description</Label>
              <Input
                id="description"
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                placeholder="Brief description of this chat's purpose"
                maxLength={1000}
              />
            </div>

            <div>
              <Label htmlFor="welcome_message">Welcome Message</Label>
              <Textarea
                id="welcome_message"
                value={formData.welcome_message}
                onChange={(e) => setFormData({ ...formData, welcome_message: e.target.value })}
                placeholder="Optional welcome message shown to users"
                maxLength={2000}
                rows={3}
              />
            </div>
          </div>

          {/* Configuration */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="expires_in_hours">Expires In (Hours) *</Label>
              <Select 
                value={formData.expires_in_hours.toString()}
                onValueChange={(value) => setFormData({ ...formData, expires_in_hours: parseInt(value) })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="1">1 Hour</SelectItem>
                  <SelectItem value="2">2 Hours</SelectItem>
                  <SelectItem value="4">4 Hours</SelectItem>
                  <SelectItem value="8">8 Hours</SelectItem>
                  <SelectItem value="24">1 Day</SelectItem>
                  <SelectItem value="72">3 Days</SelectItem>
                  <SelectItem value="168">1 Week</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div>
              <Label htmlFor="max_sessions">Max Concurrent Sessions</Label>
              <Input
                id="max_sessions"
                type="number"
                min="1"
                max="50"
                value={formData.max_sessions}
                onChange={(e) => setFormData({ ...formData, max_sessions: parseInt(e.target.value) })}
              />
            </div>

            <div>
              <Label htmlFor="max_messages">Max Messages Per Session</Label>
              <Input
                id="max_messages"
                type="number"
                min="1"
                max="1000"
                value={formData.max_messages_per_session}
                onChange={(e) => setFormData({ ...formData, max_messages_per_session: parseInt(e.target.value) })}
              />
            </div>

            <div>
              <Label htmlFor="session_timeout">Session Timeout (Minutes)</Label>
              <Input
                id="session_timeout"
                type="number"
                min="5"
                max="1440"
                value={formData.session_timeout_minutes}
                onChange={(e) => setFormData({ ...formData, session_timeout_minutes: parseInt(e.target.value) })}
              />
            </div>
          </div>

          {/* Advanced Settings */}
          <Card>
            <CardHeader>
              <CardTitle className="text-sm">Advanced Settings</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label htmlFor="rate_limit">Rate Limit (Messages per Minute)</Label>
                <Input
                  id="rate_limit"
                  type="number"
                  min="1"
                  max="100"
                  value={formData.rate_limit_per_minute}
                  onChange={(e) => setFormData({ ...formData, rate_limit_per_minute: parseInt(e.target.value) })}
                />
              </div>
            </CardContent>
          </Card>

          {/* Actions */}
          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit" disabled={loading || !formData.title}>
              {loading ? 'Creating...' : 'Create Link'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
```

### 2. Public Chat Interface Components

#### TempChatInterface Component
```typescript
// src/components/temporary-chat/public/TempChatInterface.tsx
import React, { useState, useEffect, useRef } from 'react';
import { TempChatHeader } from './TempChatHeader';
import { TempChatMessages } from './TempChatMessages';
import { TempChatInput } from './TempChatInput';
import { TempChatStatus } from './TempChatStatus';
import { useTempChatSession } from '../shared/TempChatHooks';

interface TempChatSession {
  session_id: string;
  agent_id: string;
  agent_name: string;
  conversation_id: string;
  title: string;
  description?: string;
  welcome_message?: string;
  max_messages: number;
  current_messages: number;
  rate_limit: number;
  expires_at: string;
}

interface TempChatInterfaceProps {
  session: TempChatSession;
}

export function TempChatInterface({ session }: TempChatInterfaceProps) {
  const [messages, setMessages] = useState<any[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  
  const {
    sendMessage,
    isLoading,
    error: sessionError,
    sessionToken
  } = useTempChatSession(session.session_id);

  // Set up Server-Sent Events for real-time messages
  useEffect(() => {
    if (!sessionToken) return;

    const eventSource = new EventSource(
      `/api/temp-chat/events?session_token=${sessionToken}`
    );

    eventSource.onopen = () => {
      setIsConnected(true);
      setConnectionError(null);
    };

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      switch (data.type) {
        case 'connected':
          setIsConnected(true);
          break;
          
        case 'message':
          setMessages(prev => [...prev, data.message]);
          break;
          
        case 'heartbeat':
          // Keep connection alive
          break;
          
        default:
          console.log('Unknown event type:', data.type);
      }
    };

    eventSource.onerror = (error) => {
      setIsConnected(false);
      setConnectionError('Connection lost. Trying to reconnect...');
    };

    return () => {
      eventSource.close();
    };
  }, [sessionToken]);

  // Auto-scroll to bottom on new messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Add welcome message if provided
  useEffect(() => {
    if (session.welcome_message && messages.length === 0) {
      setMessages([{
        id: 'welcome',
        role: 'assistant',
        content: session.welcome_message,
        timestamp: new Date().toISOString()
      }]);
    }
  }, [session.welcome_message]);

  const handleSendMessage = async (message: string) => {
    // Add user message immediately for better UX
    const userMessage = {
      id: `temp-${Date.now()}`,
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    };
    setMessages(prev => [...prev, userMessage]);

    try {
      await sendMessage(message);
    } catch (error) {
      console.error('Failed to send message:', error);
      // Remove the optimistic message on error
      setMessages(prev => prev.filter(m => m.id !== userMessage.id));
    }
  };

  const remainingMessages = session.max_messages - session.current_messages;
  const isSessionLimitReached = remainingMessages <= 0;

  return (
    <div className="flex flex-col h-screen bg-background">
      {/* Header */}
      <TempChatHeader 
        session={session}
        isConnected={isConnected}
      />

      {/* Connection Status */}
      <TempChatStatus 
        isConnected={isConnected}
        error={connectionError || sessionError}
        remainingMessages={remainingMessages}
      />

      {/* Messages Area */}
      <div className="flex-1 overflow-y-auto px-4 py-6">
        <div className="max-w-3xl mx-auto">
          <TempChatMessages messages={messages} />
          <div ref={messagesEndRef} />
        </div>
      </div>

      {/* Input Area */}
      {!isSessionLimitReached && (
        <div className="border-t bg-card px-4 py-4">
          <div className="max-w-3xl mx-auto">
            <TempChatInput
              onSendMessage={handleSendMessage}
              isLoading={isLoading}
              disabled={!isConnected}
              placeholder={
                isConnected 
                  ? "Type your message..." 
                  : "Connecting..."
              }
            />
          </div>
        </div>
      )}

      {/* Session Ended Message */}
      {isSessionLimitReached && (
        <div className="border-t bg-muted/50 px-4 py-6">
          <div className="max-w-3xl mx-auto text-center">
            <p className="text-muted-foreground">
              This chat session has reached its message limit.
            </p>
          </div>
        </div>
      )}
    </div>
  );
}
```

#### TempChatMessages Component
```typescript
// src/components/temporary-chat/public/TempChatMessages.tsx
import React from 'react';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Card, CardContent } from '@/components/ui/card';
import { Bot, User } from 'lucide-react';
import ReactMarkdown from 'react-markdown';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

interface TempChatMessagesProps {
  messages: Message[];
}

export function TempChatMessages({ messages }: TempChatMessagesProps) {
  const formatTimestamp = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString([], { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
  };

  return (
    <div className="space-y-4">
      {messages.map((message) => (
        <div
          key={message.id}
          className={`flex items-start space-x-3 ${
            message.role === 'user' ? 'justify-end' : 'justify-start'
          }`}
        >
          {message.role === 'assistant' && (
            <Avatar className="w-8 h-8 mt-1">
              <AvatarFallback>
                <Bot className="w-4 h-4" />
              </AvatarFallback>
            </Avatar>
          )}
          
          <div className={`max-w-[70%] ${message.role === 'user' ? 'order-1' : ''}`}>
            <Card className={`${
              message.role === 'user' 
                ? 'bg-primary text-primary-foreground' 
                : 'bg-muted'
            }`}>
              <CardContent className="p-3">
                {message.role === 'assistant' ? (
                  <ReactMarkdown 
                    className="prose prose-sm dark:prose-invert max-w-none"
                    components={{
                      p: ({ children }) => <p className="mb-2 last:mb-0">{children}</p>,
                      ul: ({ children }) => <ul className="list-disc ml-4 mb-2">{children}</ul>,
                      ol: ({ children }) => <ol className="list-decimal ml-4 mb-2">{children}</ol>,
                      code: ({ children }) => (
                        <code className="bg-muted px-1 py-0.5 rounded text-sm font-mono">
                          {children}
                        </code>
                      ),
                    }}
                  >
                    {message.content}
                  </ReactMarkdown>
                ) : (
                  <p className="text-sm">{message.content}</p>
                )}
              </CardContent>
            </Card>
            
            <p className={`text-xs text-muted-foreground mt-1 ${
              message.role === 'user' ? 'text-right' : 'text-left'
            }`}>
              {formatTimestamp(message.timestamp)}
            </p>
          </div>

          {message.role === 'user' && (
            <Avatar className="w-8 h-8 mt-1 order-2">
              <AvatarFallback>
                <User className="w-4 h-4" />
              </AvatarFallback>
            </Avatar>
          )}
        </div>
      ))}
    </div>
  );
}
```

### 3. Custom Hooks

#### useTempChatSession Hook
```typescript
// src/components/temporary-chat/shared/TempChatHooks.ts
import { useState, useCallback } from 'react';

export function useTempChatSession(sessionId: string) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [sessionToken, setSessionToken] = useState<string | null>(null);

  const sendMessage = useCallback(async (message: string) => {
    if (!sessionToken) {
      throw new Error('No active session');
    }

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/temp-chat/send-message', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_token: sessionToken,
          message,
          message_type: 'text'
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to send message');
      }

      const result = await response.json();
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [sessionToken]);

  return {
    sendMessage,
    isLoading,
    error,
    sessionToken,
    setSessionToken
  };
}

export function useTempChatValidation() {
  const [isValidating, setIsValidating] = useState(false);
  const [validationError, setValidationError] = useState<string | null>(null);

  const validateSession = useCallback(async (token: string) => {
    setIsValidating(true);
    setValidationError(null);

    try {
      const response = await fetch('/api/temp-chat/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_token: token })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Session validation failed');
      }

      const sessionData = await response.json();
      return sessionData;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Validation failed';
      setValidationError(errorMessage);
      throw err;
    } finally {
      setIsValidating(false);
    }
  }, []);

  return {
    validateSession,
    isValidating,
    validationError
  };
}
```

### 4. Page Components

#### TempChatPage
```typescript
// src/pages/TempChatPage.tsx
import React, { useState, useEffect } from 'react';
import { useParams, Navigate } from 'react-router-dom';
import { TempChatInterface } from '../components/temporary-chat/public/TempChatInterface';
import { useTempChatValidation } from '../components/temporary-chat/shared/TempChatHooks';
import { LoadingSpinner } from '../components/LoadingSpinner';

export function TempChatPage() {
  const { token } = useParams<{ token: string }>();
  const [session, setSession] = useState<any>(null);
  const { validateSession, isValidating, validationError } = useTempChatValidation();

  useEffect(() => {
    if (!token) return;

    const initializeSession = async () => {
      try {
        const sessionData = await validateSession(token);
        setSession(sessionData);
      } catch (error) {
        console.error('Session validation failed:', error);
      }
    };

    initializeSession();
  }, [token, validateSession]);

  if (!token) {
    return <Navigate to="/" replace />;
  }

  if (isValidating) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner className="mx-auto mb-4" />
          <p className="text-muted-foreground">Validating chat session...</p>
        </div>
      </div>
    );
  }

  if (validationError) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center max-w-md mx-auto p-6">
          <div className="text-destructive text-6xl mb-4">⚠️</div>
          <h1 className="text-2xl font-bold mb-2">Chat Unavailable</h1>
          <p className="text-muted-foreground mb-4">{validationError}</p>
          <p className="text-sm text-muted-foreground">
            This chat link may have expired or is no longer active.
          </p>
        </div>
      </div>
    );
  }

  if (!session) {
    return <Navigate to="/" replace />;
  }

  return <TempChatInterface session={session} />;
}
```

## Integration Points

### 1. Routing Integration
- Add TempChatPage to lazy components
- Update routeConfig.tsx with public route
- Ensure proper error boundaries

### 2. UI Component Integration  
- Leverage existing shadcn/ui components
- Maintain consistent styling with main app
- Responsive design for mobile users

### 3. State Management
- Custom hooks for session management
- Error handling and recovery
- Real-time connection management

## Mobile Optimization

### 1. Responsive Design
- Mobile-first approach for public interface
- Touch-friendly input controls
- Optimized message display

### 2. Performance Considerations
- Lazy loading of components
- Efficient re-rendering
- Connection management for mobile networks

This comprehensive frontend component planning provides a complete user experience for both management and public chat interfaces.
