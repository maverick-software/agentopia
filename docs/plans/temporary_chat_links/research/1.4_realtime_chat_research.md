# Real-time Chat System Research for Temporary Chat Links

## Research Summary

This document analyzes the current real-time chat system in Agentopia to understand how to implement real-time messaging for temporary chat sessions without authentication while maintaining the same user experience.

## Current Real-time Architecture

### 1. Supabase Real-time Integration

#### Core Implementation Pattern
The system uses Supabase's real-time subscriptions to listen for new messages in `chat_messages_v2` table:

```typescript
// From AgentChatPage.tsx
const [messageSubscription, setMessageSubscription] = useState<RealtimeChannel | null>(null);

const channel = supabase
  .channel(`chat-messages-${selectedConversationId}`)
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'chat_messages_v2',
      filter: `conversation_id=eq.${selectedConversationId}`,
    },
    (payload) => {
      console.log('New message received via realtime:', payload);
      const newMessage = payload.new as any;
      
      // Convert database message to frontend Message format
      const message: Message = {
        role: newMessage.role,
        content: typeof newMessage.content === 'string' ? newMessage.content : newMessage.content?.text || '',
        timestamp: new Date(newMessage.created_at),
        userId: newMessage.sender_user_id,
        agentId: newMessage.sender_agent_id,
        id: newMessage.id,
      };
      
      // Add to messages if not already present
      setMessages(prev => {
        const exists = prev.some(msg => msg.id === message.id);
        if (exists) return prev;
        return [...prev, message].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
      });
    }
  )
  .subscribe();
```

#### Subscription Management
- **Channel Naming**: Uses conversation-specific channel names (`chat-messages-${conversationId}`)
- **Filter-based**: Filters messages by `conversation_id` for efficiency
- **Lifecycle Management**: Proper cleanup on component unmount and conversation change
- **Duplicate Prevention**: Checks for existing messages to avoid duplicates
- **Error Handling**: Comprehensive status monitoring and reconnection

### 2. Message Flow Architecture

#### Message Storage
- **Primary Table**: `chat_messages_v2` with JSONB content structure
- **Real-time Enabled**: Table configured for real-time subscriptions
- **RLS Policies**: Row Level Security controls access based on user/agent ownership

#### Message Processing
1. **User sends message** → Edge function processes → Database insert
2. **Database insert triggers** → Real-time notification
3. **Real-time subscription receives** → UI updates immediately
4. **AI response generated** → Another database insert → Real-time update

#### Conversation Context
- **Conversation Sessions**: Tracked in `conversation_sessions` table
- **Session Management**: Active session tracking with metrics
- **Message Ordering**: Timestamp-based sorting for chronological display

### 3. Authentication and Security

#### Current Security Model
- **Authenticated Users**: Real-time subscriptions work with authenticated Supabase clients
- **RLS Integration**: Real-time respects Row Level Security policies
- **User-Scoped Access**: Users only receive messages for their conversations

#### Authentication Requirements
```typescript
// Current pattern requires authenticated supabase client
const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true
  }
});
```

## Implementation Strategy for Temporary Chat Links

### 1. Public Real-time Access Challenge

#### Problem: Authentication Requirement
- Supabase real-time subscriptions typically require authentication
- Anonymous users cannot subscribe to real-time updates
- RLS policies prevent unauthorized access to chat messages

#### Solution: Service-Mediated Real-time

Instead of direct client subscriptions, use a service-mediated approach:

1. **Public clients connect to custom WebSocket endpoint**
2. **Service validates session tokens**
3. **Service maintains real-time subscriptions internally**
4. **Service forwards messages to authenticated public clients**

### 2. Custom WebSocket Implementation

#### WebSocket Server Architecture
```typescript
// supabase/functions/temporary-chat-websocket/index.ts
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';

interface WebSocketConnection {
  sessionToken: string;
  conversationId: string;
  socket: WebSocket;
  lastActivity: Date;
}

const connections = new Map<string, WebSocketConnection>();

serve(async (req) => {
  if (req.headers.get('upgrade') !== 'websocket') {
    return new Response('Expected WebSocket', { status: 400 });
  }

  const { socket, response } = Deno.upgradeWebSocket(req);
  
  socket.onopen = () => {
    console.log('WebSocket connection opened');
  };

  socket.onmessage = async (event) => {
    const data = JSON.parse(event.data);
    
    if (data.type === 'authenticate') {
      await handleAuthentication(socket, data.sessionToken);
    } else if (data.type === 'message') {
      await handleMessage(socket, data);
    }
  };

  socket.onclose = () => {
    handleDisconnection(socket);
  };

  return response;
});
```

#### Session-based Authentication
```typescript
async function handleAuthentication(socket: WebSocket, sessionToken: string) {
  // Validate session token
  const session = await validateTempChatSession(sessionToken);
  
  if (!session) {
    socket.send(JSON.stringify({ type: 'error', message: 'Invalid session' }));
    socket.close();
    return;
  }

  // Store connection
  connections.set(sessionToken, {
    sessionToken,
    conversationId: session.conversation_id,
    socket,
    lastActivity: new Date()
  });

  // Set up internal real-time subscription for this conversation
  await setupInternalSubscription(session.conversation_id);
}
```

### 3. Alternative Approach: Server-Sent Events (SSE)

#### SSE Implementation (Simpler Alternative)
```typescript
// supabase/functions/temporary-chat-events/index.ts
serve(async (req) => {
  const url = new URL(req.url);
  const sessionToken = url.searchParams.get('session_token');
  
  if (!sessionToken) {
    return new Response('Missing session token', { status: 400 });
  }

  // Validate session
  const session = await validateTempChatSession(sessionToken);
  if (!session) {
    return new Response('Invalid session', { status: 401 });
  }

  // Create SSE stream
  const stream = new ReadableStream({
    start(controller) {
      // Set up real-time subscription
      const channel = supabase
        .channel(`temp-chat-${session.conversation_id}`)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'chat_messages_v2',
          filter: `conversation_id=eq.${session.conversation_id}`
        }, (payload) => {
          const message = formatMessageForSSE(payload.new);
          controller.enqueue(`data: ${JSON.stringify(message)}\n\n`);
        })
        .subscribe();

      // Cleanup on close
      const cleanup = () => {
        supabase.removeChannel(channel);
        controller.close();
      };

      // Set cleanup timer
      setTimeout(cleanup, 30 * 60 * 1000); // 30 minutes max
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*'
    }
  });
});
```

### 4. Frontend Implementation for Temporary Chat

#### Public Chat Component with Real-time
```typescript
// src/components/temporary-chat/TempChatInterface.tsx
export function TempChatInterface({ sessionToken }: { sessionToken: string }) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    // Option 1: WebSocket connection
    const connectWebSocket = () => {
      const ws = new WebSocket(`${WS_BASE_URL}/temporary-chat-websocket`);
      
      ws.onopen = () => {
        ws.send(JSON.stringify({
          type: 'authenticate',
          sessionToken
        }));
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        
        if (data.type === 'authenticated') {
          setConnected(true);
        } else if (data.type === 'message') {
          setMessages(prev => [...prev, data.message]);
        }
      };

      return ws;
    };

    // Option 2: Server-Sent Events (Simpler)
    const connectSSE = () => {
      const eventSource = new EventSource(
        `${API_BASE_URL}/temporary-chat-events?session_token=${sessionToken}`
      );

      eventSource.onopen = () => {
        setConnected(true);
      };

      eventSource.onmessage = (event) => {
        const message = JSON.parse(event.data);
        setMessages(prev => [...prev, message]);
      };

      eventSource.onerror = () => {
        setConnected(false);
        // Implement reconnection logic
      };

      return eventSource;
    };

    const connection = connectSSE(); // Use SSE for simplicity

    return () => {
      connection.close();
    };
  }, [sessionToken]);

  // Rest of component implementation...
}
```

### 5. Message Sending for Anonymous Users

#### Anonymous Message Submission
```typescript
async function sendMessage(content: string, sessionToken: string) {
  try {
    const response = await fetch(`${API_BASE_URL}/temporary-chat-handler`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        action: 'send_message',
        session_token: sessionToken,
        message: content
      })
    });

    if (!response.ok) {
      throw new Error('Failed to send message');
    }

    // Message will be received via real-time subscription
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
}
```

### 6. Database Configuration for Real-time

#### Enable Real-time on Temporary Tables
```sql
-- Enable real-time for chat messages (already enabled)
ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_messages_v2;

-- Enable real-time for temporary sessions (for status updates)
ALTER PUBLICATION supabase_realtime ADD TABLE public.temporary_chat_sessions;
```

#### RLS Policies for Real-time Access
```sql
-- Service role can access all messages for real-time forwarding
CREATE POLICY "Service role realtime access" ON chat_messages_v2
  FOR SELECT USING (auth.role() = 'service_role');

-- No direct user access to temporary session messages
-- All access mediated through service functions
```

### 7. Performance and Scalability

#### Connection Management
- **Connection Limits**: Maximum concurrent connections per session
- **Cleanup Strategy**: Automatic cleanup of idle connections
- **Resource Monitoring**: Track WebSocket/SSE connection count

#### Message Delivery Optimization
- **Message Batching**: Group rapid messages for efficiency
- **Selective Updates**: Only send relevant messages to each connection
- **Compression**: Use message compression for large payloads

### 8. Error Handling and Reliability

#### Connection Recovery
```typescript
class TempChatConnection {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;

  private reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, this.reconnectDelay * Math.pow(2, this.reconnectAttempts));
  }

  private connect() {
    // Connection implementation with error handling
  }
}
```

#### Fallback Mechanisms
- **Polling Fallback**: If real-time fails, fall back to periodic polling
- **Message Recovery**: Fetch missed messages on reconnection
- **Status Indicators**: Show connection status to users

## Implementation Recommendations

### Phase 1: SSE Implementation (Recommended Start)
1. **Create SSE endpoint** for real-time message delivery
2. **Implement session token validation**
3. **Set up internal Supabase subscriptions**
4. **Create public chat interface** with SSE connection

### Phase 2: Enhanced Real-time
1. **Add WebSocket support** for bidirectional communication
2. **Implement connection management** and cleanup
3. **Add message delivery confirmation**
4. **Optimize for performance and scalability**

### Phase 3: Advanced Features
1. **Add typing indicators**
2. **Implement message status tracking**
3. **Add connection quality monitoring**
4. **Create admin dashboard for connection monitoring**

## Security Considerations

### 1. Session Validation
- Validate session tokens on every connection
- Check session expiration and limits
- Implement rate limiting per session

### 2. Message Filtering
- Ensure messages only go to authorized sessions
- Prevent cross-session message leakage
- Validate message content and format

### 3. Resource Protection
- Limit concurrent connections per session
- Implement connection timeout and cleanup
- Monitor and prevent abuse

## File Dependencies for Implementation

### New Real-time Files:
- `supabase/functions/temporary-chat-events/index.ts` (SSE endpoint)
- `supabase/functions/temporary-chat-websocket/index.ts` (WebSocket endpoint - optional)
- `src/components/temporary-chat/TempChatConnection.ts` (Connection management)
- `src/hooks/useTempChatRealtime.ts` (Real-time hook for temporary chat)

### Modified Files:
- `supabase/config.toml` (Add new edge functions)
- Database migrations for real-time table configuration

### Utility Files:
- `src/utils/tempChatConnection.ts` (Connection utilities)
- `supabase/functions/_shared/temp-chat-realtime.ts` (Shared real-time utilities)

## Testing Strategy

### 1. Connection Testing
- Test SSE/WebSocket connection establishment
- Test connection recovery and reconnection
- Test concurrent connection limits

### 2. Message Delivery Testing
- Test real-time message delivery
- Test message ordering and deduplication
- Test delivery under network conditions

### 3. Security Testing
- Test session validation
- Test unauthorized access prevention
- Test rate limiting and abuse prevention

This implementation will provide real-time messaging capabilities for temporary chat sessions while maintaining security and performance standards consistent with the existing authenticated chat system.
