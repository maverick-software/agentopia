# Security & Rate Limiting Planning for Temporary Chat Links

## Security Architecture Overview

This document outlines comprehensive security measures, rate limiting strategies, and abuse prevention mechanisms for the temporary chat links system.

## 1. Token Security

### Token Generation Strategy
```typescript
// Cryptographically secure token generation
function generateSecureToken(): string {
  const uuid = crypto.randomUUID();
  const timestamp = Date.now().toString(36);
  const entropy = crypto.getRandomValues(new Uint8Array(16));
  const entropyB64 = btoa(String.fromCharCode(...entropy));
  
  const combined = `${uuid}-${timestamp}-${entropyB64}`;
  const hash = btoa(combined).replace(/[+/]/g, c => c === '+' ? '-' : '_').replace(/=+$/, '');
  
  return hash;
}
```

### Token Validation
- **Format Validation**: URL-safe base64 pattern
- **Expiration Check**: Database-level timestamp validation  
- **Single-Use Options**: Optional one-time token consumption
- **Checksum Verification**: Prevent token tampering

## 2. Rate Limiting Architecture

### Multi-Layer Rate Limiting
```typescript
// Rate limiting configuration
const RATE_LIMITS = {
  // Per session token
  SESSION_MESSAGES: {
    window: 60_000, // 1 minute
    max: 10 // configurable per link
  },
  
  // Per IP address
  IP_VALIDATION: {
    window: 60_000, // 1 minute  
    max: 20 // validation attempts
  },
  
  // Per IP session creation
  IP_SESSIONS: {
    window: 3600_000, // 1 hour
    max: 5 // new sessions
  },
  
  // Global system protection
  GLOBAL_SESSIONS: {
    window: 60_000, // 1 minute
    max: 100 // concurrent new sessions
  }
};
```

### Database-Level Rate Limiting
```sql
-- Rate limiting tracking in temporary_chat_sessions
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_session_token TEXT,
  p_ip_address INET,
  p_limit_type TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  v_current_count INTEGER;
  v_limit INTEGER;
  v_window_start TIMESTAMPTZ;
BEGIN
  v_window_start := NOW() - INTERVAL '1 minute';
  
  CASE p_limit_type
    WHEN 'session_messages' THEN
      SELECT messages_in_current_minute, rate_limit_per_minute
      INTO v_current_count, v_limit
      FROM temporary_chat_sessions tcs
      JOIN temporary_chat_links tcl ON tcs.link_id = tcl.id
      WHERE tcs.session_token = p_session_token;
      
    WHEN 'ip_validation' THEN
      v_limit := 20;
      SELECT COUNT(*) INTO v_current_count
      FROM temp_chat_rate_limits
      WHERE ip_address = p_ip_address 
        AND action_type = 'validation'
        AND created_at >= v_window_start;
        
    WHEN 'ip_sessions' THEN
      v_limit := 5;
      SELECT COUNT(*) INTO v_current_count
      FROM temporary_chat_sessions
      WHERE ip_address = p_ip_address
        AND created_at >= NOW() - INTERVAL '1 hour';
  END CASE;
  
  RETURN COALESCE(v_current_count, 0) < COALESCE(v_limit, 999);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## 3. Input Validation & Sanitization

### Message Content Validation
```typescript
// Comprehensive input validation
interface MessageValidationRules {
  maxLength: number;
  allowedTypes: string[];
  forbiddenPatterns: RegExp[];
  requiredSanitization: boolean;
}

const MESSAGE_VALIDATION: MessageValidationRules = {
  maxLength: 4000, // 4KB per message
  allowedTypes: ['text', 'file'],
  forbiddenPatterns: [
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, // Script tags
    /javascript:/gi, // JavaScript URLs
    /data:text\/html/gi, // HTML data URLs
    /vbscript:/gi, // VBScript URLs
  ],
  requiredSanitization: true
};

function validateAndSanitizeMessage(content: string): { 
  isValid: boolean; 
  sanitized: string; 
  errors: string[] 
} {
  const errors: string[] = [];
  
  // Length validation
  if (content.length > MESSAGE_VALIDATION.maxLength) {
    errors.push(`Message too long (max ${MESSAGE_VALIDATION.maxLength} characters)`);
  }
  
  // Pattern validation
  for (const pattern of MESSAGE_VALIDATION.forbiddenPatterns) {
    if (pattern.test(content)) {
      errors.push('Message contains forbidden content');
      break;
    }
  }
  
  // Sanitization
  let sanitized = content;
  if (MESSAGE_VALIDATION.requiredSanitization) {
    sanitized = DOMPurify.sanitize(content, {
      ALLOWED_TAGS: [], // No HTML tags allowed
      ALLOWED_ATTR: []
    });
  }
  
  return {
    isValid: errors.length === 0,
    sanitized,
    errors
  };
}
```

### Parameter Validation
```typescript
// API parameter validation schemas
const VALIDATION_SCHEMAS = {
  createLink: {
    title: { type: 'string', minLength: 1, maxLength: 200, required: true },
    description: { type: 'string', maxLength: 1000 },
    expires_in_hours: { type: 'number', min: 1, max: 168, required: true },
    max_sessions: { type: 'number', min: 1, max: 50 },
    max_messages_per_session: { type: 'number', min: 1, max: 1000 },
    session_timeout_minutes: { type: 'number', min: 5, max: 1440 },
    rate_limit_per_minute: { type: 'number', min: 1, max: 100 }
  },
  
  sendMessage: {
    session_token: { type: 'string', pattern: /^[A-Za-z0-9_-]+$/, required: true },
    message: { type: 'string', minLength: 1, maxLength: 4000, required: true },
    message_type: { type: 'string', enum: ['text', 'file'] }
  }
};
```

## 4. Session Security

### Session Isolation
```sql
-- Ensure complete session isolation
CREATE POLICY "session_isolation" ON chat_messages_v2
  FOR ALL USING (
    -- Regular authenticated users can only see their own messages
    (auth.uid() IS NOT NULL AND (
      sender_user_id = auth.uid() OR
      conversation_id IN (
        SELECT conversation_id FROM conversation_sessions 
        WHERE user_id = auth.uid()
      )
    )) OR
    -- Service role can access all (for temporary chat processing)
    (auth.role() = 'service_role')
  );

-- Temporary chat sessions are completely isolated
CREATE POLICY "temp_chat_isolation" ON temporary_chat_sessions
  FOR ALL USING (
    -- Only service role can access temporary sessions
    auth.role() = 'service_role' OR
    -- Users can only see sessions for their own links
    (auth.uid() IS NOT NULL AND link_id IN (
      SELECT id FROM temporary_chat_links WHERE user_id = auth.uid()
    ))
  );
```

### Connection Security
```typescript
// Secure connection validation
async function validateConnection(req: Request): Promise<{
  isValid: boolean;
  clientInfo: ClientInfo;
  securityFlags: SecurityFlags;
}> {
  const clientIP = getClientIP(req);
  const userAgent = req.headers.get('user-agent') || '';
  const origin = req.headers.get('origin');
  
  const securityFlags = {
    suspiciousUserAgent: isSuspiciousUserAgent(userAgent),
    rateLimited: await isRateLimited(clientIP),
    geoBlocked: await isGeoBlocked(clientIP),
    knownBot: isKnownBot(userAgent),
    invalidOrigin: origin && !isAllowedOrigin(origin)
  };
  
  const isValid = !Object.values(securityFlags).some(flag => flag);
  
  return {
    isValid,
    clientInfo: { ip: clientIP, userAgent, origin },
    securityFlags
  };
}
```

## 5. Abuse Prevention

### Automated Monitoring
```typescript
// Abuse detection patterns
const ABUSE_PATTERNS = {
  // Rapid session creation from same IP
  SESSION_SPAM: {
    threshold: 10,
    window: 300_000, // 5 minutes
    action: 'temporary_block'
  },
  
  // Identical messages across sessions
  MESSAGE_SPAM: {
    threshold: 5,
    window: 600_000, // 10 minutes  
    action: 'content_filter'
  },
  
  // Excessive validation attempts
  TOKEN_ENUMERATION: {
    threshold: 50,
    window: 3600_000, // 1 hour
    action: 'ip_block'
  },
  
  // Suspicious content patterns
  MALICIOUS_CONTENT: {
    patterns: [
      /(?:password|login|credential)/gi,
      /(?:phishing|scam|fraud)/gi,
      /(?:malware|virus|trojan)/gi
    ],
    action: 'content_block'
  }
};

async function detectAbuse(
  clientIP: string, 
  content: string, 
  sessionToken: string
): Promise<AbuseDetectionResult> {
  const violations: string[] = [];
  const actions: string[] = [];
  
  // Check for session spam
  const recentSessions = await getRecentSessions(clientIP, 300_000);
  if (recentSessions.length >= ABUSE_PATTERNS.SESSION_SPAM.threshold) {
    violations.push('session_spam');
    actions.push('temporary_block');
  }
  
  // Check for content patterns
  for (const pattern of ABUSE_PATTERNS.MALICIOUS_CONTENT.patterns) {
    if (pattern.test(content)) {
      violations.push('malicious_content');
      actions.push('content_block');
      break;
    }
  }
  
  return { violations, actions, severity: calculateSeverity(violations) };
}
```

### Cleanup and Monitoring
```sql
-- Automated cleanup procedures
CREATE OR REPLACE FUNCTION security_cleanup()
RETURNS TABLE (
  expired_blocks INTEGER,
  cleaned_sessions INTEGER,
  archived_logs INTEGER
) AS $$
DECLARE
  v_expired_blocks INTEGER := 0;
  v_cleaned_sessions INTEGER := 0;  
  v_archived_logs INTEGER := 0;
BEGIN
  -- Remove expired IP blocks
  DELETE FROM temp_chat_ip_blocks 
  WHERE expires_at < NOW();
  GET DIAGNOSTICS v_expired_blocks = ROW_COUNT;
  
  -- Clean up old inactive sessions
  DELETE FROM temporary_chat_sessions 
  WHERE status != 'active' 
    AND updated_at < NOW() - INTERVAL '7 days';
  GET DIAGNOSTICS v_cleaned_sessions = ROW_COUNT;
  
  -- Archive old security logs
  INSERT INTO temp_chat_security_logs_archive 
  SELECT * FROM temp_chat_security_logs 
  WHERE created_at < NOW() - INTERVAL '30 days';
  GET DIAGNOSTICS v_archived_logs = ROW_COUNT;
  
  DELETE FROM temp_chat_security_logs 
  WHERE created_at < NOW() - INTERVAL '30 days';
  
  RETURN QUERY SELECT v_expired_blocks, v_cleaned_sessions, v_archived_logs;
END;
$$ LANGUAGE plpgsql;

-- Schedule security cleanup
SELECT cron.schedule(
  'security-cleanup',
  '0 2 * * *', -- Daily at 2 AM
  'SELECT security_cleanup();'
);
```

## 6. Monitoring and Alerting

### Security Event Logging
```sql
-- Security events tracking
CREATE TABLE IF NOT EXISTS temp_chat_security_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type TEXT NOT NULL CHECK (event_type IN (
    'rate_limit_exceeded', 'invalid_token', 'abuse_detected', 
    'geo_block', 'content_filter', 'session_terminated'
  )),
  severity TEXT NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  client_ip INET,
  user_agent TEXT,
  session_token TEXT,
  link_id UUID REFERENCES temporary_chat_links(id),
  event_data JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_security_logs_type_severity ON temp_chat_security_logs(event_type, severity);
CREATE INDEX idx_security_logs_ip ON temp_chat_security_logs(client_ip);
CREATE INDEX idx_security_logs_created ON temp_chat_security_logs(created_at DESC);
```

### Real-time Monitoring
```typescript
// Security monitoring dashboard
async function getSecurityMetrics(timeRange: string = '24h') {
  const supabase = createClient(/* service role */);
  
  const { data: metrics } = await supabase.rpc('get_security_metrics', {
    hours_back: timeRange === '24h' ? 24 : timeRange === '7d' ? 168 : 1
  });
  
  return {
    totalEvents: metrics?.total_events || 0,
    criticalEvents: metrics?.critical_events || 0,
    blockedIPs: metrics?.blocked_ips || 0,
    rateLimitViolations: metrics?.rate_limit_violations || 0,
    suspiciousPatterns: metrics?.suspicious_patterns || 0,
    topThreats: metrics?.top_threats || []
  };
}
```

## 7. Compliance and Privacy

### Data Protection
- **Minimal Data Collection**: Only necessary data for functionality
- **Automatic Expiration**: All temporary data expires automatically  
- **No Persistent Tracking**: Anonymous usage without personal identification
- **Secure Deletion**: Cryptographic erasure of expired data

### Audit Trail
```sql
-- Audit trail for compliance
CREATE TABLE IF NOT EXISTS temp_chat_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  action TEXT NOT NULL,
  resource_type TEXT NOT NULL,
  resource_id UUID,
  user_id UUID REFERENCES auth.users(id),
  ip_address INET,
  changes JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

## Implementation Priority

### Phase 1: Core Security (High Priority)
1. **Token generation and validation**
2. **Basic rate limiting**  
3. **Input sanitization**
4. **Session isolation**

### Phase 2: Advanced Protection (Medium Priority)
1. **Abuse detection**
2. **IP blocking**
3. **Content filtering**
4. **Security monitoring**

### Phase 3: Compliance & Analytics (Lower Priority)
1. **Audit logging**
2. **Security dashboard**
3. **Compliance reporting**
4. **Advanced analytics**

This comprehensive security and rate limiting plan ensures the temporary chat links system is protected against abuse while maintaining usability and performance.
