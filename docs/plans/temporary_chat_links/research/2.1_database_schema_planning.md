# Database Schema Planning for Temporary Chat Links

## Planning Summary

Based on the database architecture research, this document provides detailed planning for the database schema implementation, including specific table designs, migration strategies, and integration with existing systems.

## Database Implementation Plan

### 1. Migration File Structure

#### Migration Sequence
```sql
-- Migration 1: Service provider and tool catalog
20250918000001_add_temporary_chat_service_provider.sql

-- Migration 2: Core tables
20250918000002_create_temporary_chat_links.sql

-- Migration 3: Session management  
20250918000003_create_temporary_chat_sessions.sql

-- Migration 4: Indexes and performance
20250918000004_create_temporary_chat_indexes.sql

-- Migration 5: RLS policies
20250918000005_create_temporary_chat_rls.sql

-- Migration 6: Functions and cleanup
20250918000006_create_temporary_chat_functions.sql
```

### 2. Service Provider and Tool Catalog Setup

#### Service Provider Registration
```sql
-- Migration: 20250918000001_add_temporary_chat_service_provider.sql

-- Add temporary chat links service provider
INSERT INTO service_providers (
  name,
  display_name,
  provider_type,
  configuration_metadata,
  is_active
) VALUES (
  'temporary_chat_internal',
  'Temporary Chat Links',
  'internal',
  '{
    "internal_service": true,
    "requires_user_credentials": false,
    "supports_public_access": true,
    "rate_limits": {
      "links_per_user_per_day": 100,
      "sessions_per_link": 50,
      "messages_per_session": 1000
    },
    "security_features": {
      "token_encryption": true,
      "session_isolation": true,
      "automatic_cleanup": true
    }
  }'::jsonb,
  true
);

-- Add temporary chat tools to tool catalog
INSERT INTO tool_catalog (
  tool_name,
  tool_display_name,
  tool_description,
  service_provider_id,
  tool_schema,
  is_active
) VALUES 
(
  'create_temporary_chat_link',
  'Create Temporary Chat Link',
  'Create a time-limited public chat link for an agent',
  (SELECT id FROM service_providers WHERE name = 'temporary_chat_internal'),
  '{
    "type": "function",
    "function": {
      "name": "create_temporary_chat_link",
      "description": "Create a temporary chat link for an agent",
      "parameters": {
        "type": "object",
        "properties": {
          "agent_id": {"type": "string", "format": "uuid"},
          "title": {"type": "string", "maxLength": 200},
          "description": {"type": "string", "maxLength": 1000},
          "expires_in_hours": {"type": "number", "minimum": 1, "maximum": 168},
          "max_sessions": {"type": "number", "minimum": 1, "maximum": 50},
          "max_messages_per_session": {"type": "number", "minimum": 1, "maximum": 1000},
          "welcome_message": {"type": "string", "maxLength": 2000}
        },
        "required": ["agent_id", "title", "expires_in_hours"]
      }
    }
  }'::jsonb,
  true
),
(
  'list_temporary_chat_links',
  'List Temporary Chat Links',
  'List temporary chat links for user or agent',
  (SELECT id FROM service_providers WHERE name = 'temporary_chat_internal'),
  '{
    "type": "function",
    "function": {
      "name": "list_temporary_chat_links",
      "description": "List temporary chat links for user or agent",
      "parameters": {
        "type": "object",
        "properties": {
          "agent_id": {"type": "string", "format": "uuid"},
          "include_inactive": {"type": "boolean", "default": false},
          "limit": {"type": "number", "minimum": 1, "maximum": 100, "default": 20}
        }
      }
    }
  }'::jsonb,
  true
),
(
  'get_temporary_chat_analytics',
  'Get Temporary Chat Analytics',
  'Get analytics for temporary chat links',
  (SELECT id FROM service_providers WHERE name = 'temporary_chat_internal'),
  '{
    "type": "function",
    "function": {
      "name": "get_temporary_chat_analytics",
      "description": "Get analytics for temporary chat links",
      "parameters": {
        "type": "object",
        "properties": {
          "agent_id": {"type": "string", "format": "uuid"},
          "days_back": {"type": "number", "minimum": 1, "maximum": 365, "default": 30}
        }
      }
    }
  }'::jsonb,
  true
);
```

### 3. Detailed Table Schemas

#### `temporary_chat_links` Table
```sql
-- Migration: 20250918000002_create_temporary_chat_links.sql
CREATE TABLE IF NOT EXISTS temporary_chat_links (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Ownership and agent relationship
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Link identification and access (using Vault for security)
  vault_link_token_id TEXT NOT NULL UNIQUE REFERENCES vault.secrets(id),
  short_code TEXT UNIQUE, -- Optional: for shorter URLs like /tc/ABC123
  
  -- Configuration and display
  title TEXT NOT NULL CHECK (LENGTH(title) BETWEEN 1 AND 200),
  description TEXT CHECK (LENGTH(description) <= 1000),
  welcome_message TEXT CHECK (LENGTH(welcome_message) <= 2000),
  
  -- Access control and limits
  expires_at TIMESTAMPTZ NOT NULL,
  max_sessions INTEGER NOT NULL DEFAULT 1 CHECK (max_sessions BETWEEN 1 AND 50),
  max_messages_per_session INTEGER NOT NULL DEFAULT 100 CHECK (max_messages_per_session BETWEEN 1 AND 1000),
  session_timeout_minutes INTEGER NOT NULL DEFAULT 30 CHECK (session_timeout_minutes BETWEEN 5 AND 1440), -- 5 min to 24 hours
  
  -- Usage tracking
  session_count INTEGER NOT NULL DEFAULT 0,
  total_messages INTEGER NOT NULL DEFAULT 0,
  last_accessed_at TIMESTAMPTZ,
  
  -- Status and control
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  
  -- Security and restrictions
  allowed_domains TEXT[], -- Optional: restrict to specific domains
  allowed_ips INET[], -- Optional: IP whitelist
  rate_limit_per_minute INTEGER NOT NULL DEFAULT 10 CHECK (rate_limit_per_minute BETWEEN 1 AND 100),
  
  -- Metadata and customization
  link_metadata JSONB NOT NULL DEFAULT '{}',
  ui_customization JSONB NOT NULL DEFAULT '{}', -- Theme, colors, etc.
  
  -- Audit timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_expiration CHECK (expires_at > created_at),
  CONSTRAINT valid_title CHECK (title ~ '^[[:print:][:space:]]+$') -- Printable characters only
);
```

#### `temporary_chat_sessions` Table
```sql
-- Migration: 20250918000002_create_temporary_chat_sessions.sql
CREATE TABLE IF NOT EXISTS temporary_chat_sessions (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Link relationship
  link_id UUID NOT NULL REFERENCES temporary_chat_links(id) ON DELETE CASCADE,
  
  -- Session identification (using Vault for security)
  vault_session_token_id TEXT NOT NULL UNIQUE REFERENCES vault.secrets(id),
  
  -- Integration with existing chat system
  conversation_id UUID NOT NULL, -- Links to conversation_sessions via conversation_id
  conversation_session_id UUID REFERENCES conversation_sessions(id) ON DELETE SET NULL,
  
  -- Participant information (anonymous)
  participant_identifier TEXT, -- Optional: email, phone, or provided name
  participant_name TEXT CHECK (LENGTH(participant_name) <= 100),
  participant_metadata JSONB NOT NULL DEFAULT '{}',
  
  -- Session lifecycle
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_activity_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  
  -- Usage metrics
  message_count INTEGER NOT NULL DEFAULT 0,
  session_duration_seconds INTEGER,
  total_characters_sent INTEGER NOT NULL DEFAULT 0,
  
  -- Status tracking
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'ended', 'expired', 'terminated', 'error')),
  end_reason TEXT CHECK (end_reason IN ('completed', 'timeout', 'expired', 'terminated', 'error', 'max_messages', 'max_duration')),
  
  -- Security and monitoring
  ip_address INET,
  user_agent TEXT,
  referrer TEXT,
  country_code TEXT, -- Optional: for analytics
  
  -- Rate limiting tracking
  last_message_at TIMESTAMPTZ,
  messages_in_current_minute INTEGER NOT NULL DEFAULT 0,
  rate_limit_violations INTEGER NOT NULL DEFAULT 0,
  
  -- Quality metrics
  satisfaction_rating INTEGER CHECK (satisfaction_rating BETWEEN 1 AND 5),
  feedback_text TEXT CHECK (LENGTH(feedback_text) <= 1000),
  
  -- Session metadata
  session_metadata JSONB NOT NULL DEFAULT '{}',
  
  -- Audit timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_session_duration CHECK (
    (ended_at IS NULL) OR (ended_at >= started_at)
  )
);
```

### 3. Performance Indexes

#### `temporary_chat_links` Indexes
```sql
-- Migration: 20250918000003_create_temporary_chat_indexes.sql

-- Primary access patterns
CREATE INDEX idx_temp_links_vault_token ON temporary_chat_links(vault_link_token_id) WHERE is_active = TRUE;
CREATE INDEX idx_temp_links_short_code ON temporary_chat_links(short_code) WHERE short_code IS NOT NULL AND is_active = TRUE;

-- Ownership queries
CREATE INDEX idx_temp_links_agent ON temporary_chat_links(agent_id) WHERE is_active = TRUE;
CREATE INDEX idx_temp_links_user ON temporary_chat_links(user_id);

-- Expiration and cleanup
CREATE INDEX idx_temp_links_expires ON temporary_chat_links(expires_at) WHERE is_active = TRUE;
CREATE INDEX idx_temp_links_cleanup ON temporary_chat_links(expires_at, is_active) WHERE expires_at < NOW();

-- Usage analytics
CREATE INDEX idx_temp_links_activity ON temporary_chat_links(last_accessed_at DESC) WHERE is_active = TRUE;
CREATE INDEX idx_temp_links_created ON temporary_chat_links(created_at DESC);

-- Metadata queries
CREATE INDEX idx_temp_links_metadata_gin ON temporary_chat_links USING GIN(link_metadata);
```

#### `temporary_chat_sessions` Indexes
```sql
-- Session access patterns
CREATE INDEX idx_temp_sessions_vault_token ON temporary_chat_sessions(vault_session_token_id) WHERE status = 'active';
CREATE INDEX idx_temp_sessions_link ON temporary_chat_sessions(link_id);

-- Conversation integration
CREATE INDEX idx_temp_sessions_conversation ON temporary_chat_sessions(conversation_id);
CREATE INDEX idx_temp_sessions_conv_session ON temporary_chat_sessions(conversation_session_id) WHERE conversation_session_id IS NOT NULL;

-- Status and cleanup queries
CREATE INDEX idx_temp_sessions_status ON temporary_chat_sessions(status, last_activity_at);
CREATE INDEX idx_temp_sessions_cleanup ON temporary_chat_sessions(status, last_activity_at) 
  WHERE status = 'active' AND last_activity_at < NOW() - INTERVAL '30 minutes';

-- Analytics and monitoring
CREATE INDEX idx_temp_sessions_activity ON temporary_chat_sessions(last_activity_at DESC);
CREATE INDEX idx_temp_sessions_ip ON temporary_chat_sessions(ip_address) WHERE ip_address IS NOT NULL;
CREATE INDEX idx_temp_sessions_created ON temporary_chat_sessions(created_at DESC);

-- Performance for rate limiting
CREATE INDEX idx_temp_sessions_rate_limit ON temporary_chat_sessions(vault_session_token_id, last_message_at) 
  WHERE status = 'active';
```

### 4. Row Level Security Policies

#### `temporary_chat_links` RLS Policies
```sql
-- Migration: 20250918000005_create_temporary_chat_rls.sql

-- Enable RLS
ALTER TABLE temporary_chat_links ENABLE ROW LEVEL SECURITY;

-- Policy 1: User isolation - users can only access their own links
CREATE POLICY "temp_links_user_isolation" ON temporary_chat_links
  FOR ALL USING (
    (auth.uid() IS NOT NULL AND user_id = auth.uid()) OR
    (auth.role() = 'service_role')
  );

-- Policy 2: Agent ownership - users can access links for their agents
CREATE POLICY "temp_links_agent_ownership" ON temporary_chat_links
  FOR ALL USING (
    (auth.uid() IS NOT NULL AND agent_id IN (
      SELECT id FROM agents WHERE user_id = auth.uid()
    )) OR
    (auth.role() = 'service_role')
  );
```

#### `temporary_chat_sessions` RLS Policies
```sql
-- Enable RLS
ALTER TABLE temporary_chat_sessions ENABLE ROW LEVEL SECURITY;

-- Policy 1: Service role has full access for system operations
CREATE POLICY "temp_sessions_service_role" ON temporary_chat_sessions
  FOR ALL USING (auth.role() = 'service_role');

-- Policy 2: Users can view sessions for their own links (management interface)
CREATE POLICY "temp_sessions_link_ownership" ON temporary_chat_sessions
  FOR SELECT USING (
    auth.uid() IS NOT NULL AND
    link_id IN (
      SELECT id FROM temporary_chat_links 
      WHERE user_id = auth.uid()
    )
  );
```

### 5. Database Functions

#### Core Utility Functions
```sql
-- Migration: 20250918000006_create_temporary_chat_functions.sql

-- Function: Generate secure link token and store in Vault
CREATE OR REPLACE FUNCTION generate_temp_chat_token()
RETURNS TEXT AS $$
DECLARE
  token_uuid UUID;
  timestamp_part TEXT;
  random_part TEXT;
  final_token TEXT;
  vault_secret_id TEXT;
BEGIN
  -- Generate components
  token_uuid := gen_random_uuid();
  timestamp_part := EXTRACT(EPOCH FROM NOW())::BIGINT::TEXT;
  random_part := encode(gen_random_bytes(16), 'base64');
  
  -- Clean up base64 for URL safety
  random_part := replace(replace(random_part, '+', '-'), '/', '_');
  random_part := rtrim(random_part, '=');
  
  -- Combine components for final token
  final_token := encode(
    (token_uuid::TEXT || '-' || timestamp_part || '-' || random_part)::BYTEA,
    'base64'
  );
  
  -- Make URL safe
  final_token := replace(replace(final_token, '+', '-'), '/', '_');
  final_token := rtrim(final_token, '=');
  
  -- Store token in Vault and return the vault secret ID
  vault_secret_id := vault.create_secret(final_token);
  
  RETURN vault_secret_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Generate session token and store in Vault
CREATE OR REPLACE FUNCTION generate_session_token()
RETURNS TEXT AS $$
DECLARE
  session_uuid UUID;
  timestamp_part TEXT;
  final_token TEXT;
  vault_secret_id TEXT;
BEGIN
  session_uuid := gen_random_uuid();
  timestamp_part := EXTRACT(EPOCH FROM NOW())::BIGINT::TEXT;
  
  final_token := encode(
    (session_uuid::TEXT || '-' || timestamp_part)::BYTEA,
    'base64'
  );
  
  -- Make URL safe
  final_token := replace(replace(final_token, '+', '-'), '/', '_');
  final_token := rtrim(final_token, '=');
  
  -- Store token in Vault and return the vault secret ID
  vault_secret_id := vault.create_secret(final_token);
  
  RETURN vault_secret_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Validate and get temporary chat session using Vault
CREATE OR REPLACE FUNCTION validate_temp_chat_session(
  p_session_token TEXT
) RETURNS TABLE (
  session_id UUID,
  link_id UUID,
  agent_id UUID,
  agent_name TEXT,
  conversation_id UUID,
  is_valid BOOLEAN,
  expires_at TIMESTAMPTZ,
  title TEXT,
  description TEXT,
  welcome_message TEXT,
  max_messages_per_session INTEGER,
  current_message_count INTEGER,
  rate_limit_per_minute INTEGER
) 
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    tcs.id as session_id,
    tcs.link_id,
    tcl.agent_id,
    a.name as agent_name,
    tcs.conversation_id,
    (
      tcs.status = 'active' 
      AND tcl.is_active = TRUE 
      AND tcl.expires_at > NOW()
      AND tcs.message_count < tcl.max_messages_per_session
    ) as is_valid,
    tcl.expires_at,
    tcl.title,
    tcl.description,
    tcl.welcome_message,
    tcl.max_messages_per_session,
    tcs.message_count as current_message_count,
    tcl.rate_limit_per_minute
  FROM temporary_chat_sessions tcs
  JOIN temporary_chat_links tcl ON tcs.link_id = tcl.id
  JOIN agents a ON tcl.agent_id = a.id
  WHERE vault.decrypt_secret(tcs.vault_session_token_id) = p_session_token;
END;
$$ LANGUAGE plpgsql;

-- Function: Create temporary chat session
CREATE OR REPLACE FUNCTION create_temp_chat_session(
  p_link_token TEXT,
  p_participant_identifier TEXT DEFAULT NULL,
  p_participant_name TEXT DEFAULT NULL,
  p_ip_address INET DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL,
  p_referrer TEXT DEFAULT NULL
) RETURNS TABLE (
  session_id UUID,
  session_token TEXT,
  conversation_id UUID,
  agent_id UUID,
  agent_name TEXT,
  is_valid BOOLEAN,
  error_message TEXT
)
SECURITY DEFINER
AS $$
DECLARE
  v_link_id UUID;
  v_agent_id UUID;
  v_agent_name TEXT;
  v_new_session_id UUID;
  v_new_session_token TEXT;
  v_new_conversation_id UUID;
  v_conversation_session_id UUID;
  v_current_sessions INTEGER;
  v_max_sessions INTEGER;
  v_is_active BOOLEAN;
  v_expires_at TIMESTAMPTZ;
BEGIN
  -- Validate link token and get link info
  SELECT tcl.id, tcl.agent_id, a.name, tcl.max_sessions, tcl.is_active, tcl.expires_at
  INTO v_link_id, v_agent_id, v_agent_name, v_max_sessions, v_is_active, v_expires_at
  FROM temporary_chat_links tcl
  JOIN agents a ON tcl.agent_id = a.id
  WHERE tcl.link_token = p_link_token;
  
  -- Check if link exists
  IF v_link_id IS NULL THEN
    RETURN QUERY SELECT NULL::UUID, ''::TEXT, NULL::UUID, NULL::UUID, ''::TEXT, FALSE, 'Invalid chat link'::TEXT;
    RETURN;
  END IF;
  
  -- Check if link is active and not expired
  IF NOT v_is_active OR v_expires_at <= NOW() THEN
    RETURN QUERY SELECT NULL::UUID, ''::TEXT, NULL::UUID, NULL::UUID, ''::TEXT, FALSE, 'Chat link has expired'::TEXT;
    RETURN;
  END IF;
  
  -- Check current active sessions count
  SELECT COUNT(*) INTO v_current_sessions
  FROM temporary_chat_sessions
  WHERE link_id = v_link_id AND status = 'active';
  
  -- Check session limit
  IF v_current_sessions >= v_max_sessions THEN
    RETURN QUERY SELECT NULL::UUID, ''::TEXT, NULL::UUID, NULL::UUID, ''::TEXT, FALSE, 'Maximum sessions reached'::TEXT;
    RETURN;
  END IF;
  
  -- Generate new session
  v_new_session_id := gen_random_uuid();
  v_new_session_token := generate_session_token();
  v_new_conversation_id := gen_random_uuid();
  
  -- Create conversation session in existing table
  INSERT INTO conversation_sessions (
    id, conversation_id, agent_id, status, started_at
  ) VALUES (
    gen_random_uuid(), v_new_conversation_id, v_agent_id, 'active', NOW()
  ) RETURNING id INTO v_conversation_session_id;
  
  -- Create temporary chat session
  INSERT INTO temporary_chat_sessions (
    id, link_id, session_token, conversation_id, conversation_session_id,
    participant_identifier, participant_name, ip_address, user_agent, referrer
  ) VALUES (
    v_new_session_id, v_link_id, v_new_session_token, v_new_conversation_id, v_conversation_session_id,
    p_participant_identifier, p_participant_name, p_ip_address, p_user_agent, p_referrer
  );
  
  -- Update link usage count
  UPDATE temporary_chat_links 
  SET session_count = session_count + 1, last_accessed_at = NOW()
  WHERE id = v_link_id;
  
  -- Return success
  RETURN QUERY SELECT 
    v_new_session_id, v_new_session_token, v_new_conversation_id, 
    v_agent_id, v_agent_name, TRUE, ''::TEXT;
END;
$$ LANGUAGE plpgsql;
```

#### Cleanup Functions
```sql
-- Function: Cleanup expired temporary chats
CREATE OR REPLACE FUNCTION cleanup_expired_temp_chats()
RETURNS TABLE (
  expired_links INTEGER,
  expired_sessions INTEGER,
  archived_messages INTEGER
) AS $$
DECLARE
  v_expired_links INTEGER := 0;
  v_expired_sessions INTEGER := 0;
  v_archived_messages INTEGER := 0;
BEGIN
  -- Mark expired links as inactive
  UPDATE temporary_chat_links 
  SET is_active = FALSE, updated_at = NOW()
  WHERE expires_at < NOW() AND is_active = TRUE;
  
  GET DIAGNOSTICS v_expired_links = ROW_COUNT;
  
  -- End expired sessions
  UPDATE temporary_chat_sessions 
  SET status = 'expired', ended_at = NOW(), updated_at = NOW()
  WHERE status = 'active' 
    AND (
      last_activity_at < NOW() - INTERVAL '30 minutes' OR
      link_id IN (SELECT id FROM temporary_chat_links WHERE is_active = FALSE)
    );
  
  GET DIAGNOSTICS v_expired_sessions = ROW_COUNT;
  
  -- Optional: Archive old messages (configurable retention)
  -- This could be expanded based on retention requirements
  
  RETURN QUERY SELECT v_expired_links, v_expired_sessions, v_archived_messages;
END;
$$ LANGUAGE plpgsql;

-- Function: Get temporary chat analytics
CREATE OR REPLACE FUNCTION get_temp_chat_analytics(
  p_agent_id UUID DEFAULT NULL,
  p_user_id UUID DEFAULT NULL,
  p_days_back INTEGER DEFAULT 30
) RETURNS TABLE (
  total_links INTEGER,
  active_links INTEGER,
  total_sessions INTEGER,
  active_sessions INTEGER,
  total_messages INTEGER,
  avg_session_duration INTERVAL,
  top_countries TEXT[]
) 
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH link_stats AS (
    SELECT 
      COUNT(*) as total_links,
      COUNT(*) FILTER (WHERE is_active = TRUE AND expires_at > NOW()) as active_links
    FROM temporary_chat_links tcl
    WHERE (p_agent_id IS NULL OR tcl.agent_id = p_agent_id)
      AND (p_user_id IS NULL OR tcl.user_id = p_user_id)
      AND tcl.created_at >= NOW() - (p_days_back || ' days')::INTERVAL
  ),
  session_stats AS (
    SELECT 
      COUNT(*) as total_sessions,
      COUNT(*) FILTER (WHERE tcs.status = 'active') as active_sessions,
      SUM(tcs.message_count) as total_messages,
      AVG(EXTRACT(EPOCH FROM (COALESCE(tcs.ended_at, NOW()) - tcs.started_at)) * INTERVAL '1 second') as avg_duration,
      ARRAY_AGG(DISTINCT tcs.country_code) FILTER (WHERE tcs.country_code IS NOT NULL) as countries
    FROM temporary_chat_sessions tcs
    JOIN temporary_chat_links tcl ON tcs.link_id = tcl.id
    WHERE (p_agent_id IS NULL OR tcl.agent_id = p_agent_id)
      AND (p_user_id IS NULL OR tcl.user_id = p_user_id)
      AND tcs.created_at >= NOW() - (p_days_back || ' days')::INTERVAL
  )
  SELECT 
    ls.total_links::INTEGER,
    ls.active_links::INTEGER,
    COALESCE(ss.total_sessions, 0)::INTEGER,
    COALESCE(ss.active_sessions, 0)::INTEGER,
    COALESCE(ss.total_messages, 0)::INTEGER,
    COALESCE(ss.avg_duration, '0 seconds'::INTERVAL),
    COALESCE(ss.countries, ARRAY[]::TEXT[])
  FROM link_stats ls
  CROSS JOIN session_stats ss;
END;
$$ LANGUAGE plpgsql;
```

### 6. Triggers and Automation

#### Update Triggers
```sql
-- Update timestamp triggers
CREATE OR REPLACE FUNCTION update_temp_chat_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER temp_links_updated_at 
  BEFORE UPDATE ON temporary_chat_links
  FOR EACH ROW EXECUTE FUNCTION update_temp_chat_updated_at();

CREATE TRIGGER temp_sessions_updated_at 
  BEFORE UPDATE ON temporary_chat_sessions
  FOR EACH ROW EXECUTE FUNCTION update_temp_chat_updated_at();

-- Activity tracking trigger
CREATE OR REPLACE FUNCTION update_session_activity()
RETURNS TRIGGER AS $$
BEGIN
  -- Update last_activity_at when session is modified
  IF TG_OP = 'UPDATE' AND OLD.message_count != NEW.message_count THEN
    NEW.last_activity_at = NOW();
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER temp_sessions_activity 
  BEFORE UPDATE ON temporary_chat_sessions
  FOR EACH ROW EXECUTE FUNCTION update_session_activity();
```

### 7. Scheduled Cleanup Jobs

#### pg_cron Integration
```sql
-- Schedule cleanup job to run every 15 minutes
SELECT cron.schedule(
  'cleanup-temp-chats',
  '*/15 * * * *',
  'SELECT cleanup_expired_temp_chats();'
);

-- Schedule analytics refresh (if needed)
SELECT cron.schedule(
  'temp-chat-analytics',
  '0 */6 * * *', -- Every 6 hours
  'REFRESH MATERIALIZED VIEW IF EXISTS temp_chat_analytics_summary;'
);
```

## Migration Execution Strategy

### 1. Pre-Migration Checklist
- [ ] Backup current database schema
- [ ] Test migrations on shadow database
- [ ] Verify existing chat system compatibility
- [ ] Check RLS policy impacts

### 2. Migration Order
1. **Create core tables** (links and sessions)
2. **Add performance indexes**
3. **Enable RLS policies**
4. **Create utility functions**
5. **Set up cleanup automation**

### 3. Rollback Plan
- Each migration includes corresponding DOWN migration
- Test rollback procedures on development environment
- Document data recovery procedures

### 4. Post-Migration Validation
- [ ] Verify table creation and constraints
- [ ] Test RLS policies with different user roles
- [ ] Validate function execution
- [ ] Confirm cleanup job scheduling

## Performance Considerations

### 1. Query Optimization
- **Partial indexes** for active records only
- **Composite indexes** for common query patterns
- **GIN indexes** for JSONB metadata searches

### 2. Storage Efficiency
- **Appropriate data types** for space efficiency
- **Constraint validation** to prevent data bloat
- **Regular cleanup** of expired data

### 3. Scalability Planning
- **Partitioning strategy** for high-volume scenarios
- **Archive strategy** for historical data
- **Monitoring queries** for performance tracking

This database schema planning provides a solid foundation for implementing temporary chat links with proper security, performance, and maintainability considerations.
