# MCP Tool Infrastructure Research for Temporary Chat Links

## Research Summary

This document analyzes the current MCP (Model Context Protocol) tool infrastructure in Agentopia to understand how to implement temporary chat link tools that agents can use to generate and manage temporary chat sessions.

## Current MCP Architecture

### Universal Tool Executor Pattern

The system uses a centralized **Universal Tool Executor** (`supabase/functions/chat/function_calling/universal-tool-executor.ts`) that routes tool calls to appropriate edge functions:

#### Key Components:

1. **Tool Routing Map**: Configuration mapping tool name prefixes to edge functions
2. **Action Mapping**: Maps specific tool names to edge function actions
3. **Parameter Mapping**: Transforms tool parameters for edge function consumption
4. **Tool Status Checking**: Validates tool availability before execution

#### Example Tool Registration Pattern:
```typescript
const TOOL_ROUTING_MAP: Record<string, {
  edgeFunction: string;
  actionMapping: (toolName: string) => string;
  parameterMapping?: (params: Record<string, any>, context?: any) => Record<string, any>;
}> = {
  'contact_': {
    edgeFunction: 'contact-mcp-tools',
    actionMapping: () => 'search_contacts',
    parameterMapping: (params: Record<string, any>, context: any) => ({
      action: 'search_contacts',
      agent_id: context.agentId,
      user_id: context.userId,
      ...params
    })
  }
};
```

### Tool Discovery and Registration

#### 1. `get-agent-tools` Edge Function
- **Purpose**: Returns authorized tools for an agent based on permissions
- **Process**: 
  1. Queries `agent_integration_permissions` table
  2. Maps OAuth scopes to tool capabilities
  3. Generates OpenAI-compatible function schemas
  4. Returns list of available tools with parameters

#### 2. Tool Schema Generation (`tool-generator.ts`)
- **Purpose**: Generates JSON Schema parameters for different tool types
- **Pattern**: Tool name-based parameter generation
- **Example**:
```typescript
export function generateParametersForCapability(toolName: string) {
  if (toolName.includes('_send_email')) {
    return {
      type: 'object',
      properties: {
        to: { type: 'string', description: 'Recipient email address' },
        subject: { type: 'string', description: 'Email subject' },
        body: { type: 'string', description: 'Email body content' }
      },
      required: ['to', 'subject', 'body']
    };
  }
  // ... other tool patterns
}
```

#### 3. Scope Mapping (`scope-mapper.ts`)
- **Purpose**: Maps OAuth scopes to tool capabilities
- **Features**: Normalizes tool names for OpenAI compatibility
- **Pattern**: Provider-specific capability mapping

## Integration Strategy for Temporary Chat Links

### 1. Tool Registration Approach

#### Option A: Add to Universal Tool Executor (Recommended)
Add temporary chat link tools to the existing `TOOL_ROUTING_MAP`:

```typescript
'temp_chat_': {
  edgeFunction: 'temporary-chat-mcp',
  actionMapping: (toolName: string) => {
    const actionMap: Record<string, string> = {
      'temp_chat_create_link': 'create_link',
      'temp_chat_list_links': 'list_links',
      'temp_chat_revoke_link': 'revoke_link',
      'temp_chat_get_sessions': 'get_sessions'
    };
    return actionMap[toolName] || 'create_link';
  },
  parameterMapping: (params: Record<string, any>, context: any) => ({
    action: context.toolName.replace('temp_chat_', ''),
    agent_id: context.agentId,
    user_id: context.userId,
    params: params
  })
}
```

#### Option B: Create Dedicated MCP Server (Alternative)
- Create standalone MCP server for temporary chat functionality
- Register with existing MCP infrastructure
- More complex but provides better isolation

### 2. Tool Schema Definitions

#### `temp_chat_create_link` Tool
```typescript
{
  name: 'temp_chat_create_link',
  description: 'Create a temporary chat link for external users to chat with this agent',
  parameters: {
    type: 'object',
    properties: {
      title: { 
        type: 'string', 
        description: 'Display title for the temporary chat session' 
      },
      description: { 
        type: 'string', 
        description: 'Description of the chat purpose (optional)' 
      },
      expires_in_hours: { 
        type: 'number', 
        description: 'Number of hours until the link expires',
        minimum: 1,
        maximum: 168 // 7 days max
      },
      max_sessions: { 
        type: 'number', 
        description: 'Maximum number of concurrent sessions (default: 1)',
        minimum: 1,
        maximum: 10
      },
      welcome_message: {
        type: 'string',
        description: 'Custom welcome message for users (optional)'
      }
    },
    required: ['title', 'expires_in_hours']
  }
}
```

#### `temp_chat_list_links` Tool
```typescript
{
  name: 'temp_chat_list_links',
  description: 'List all active temporary chat links for this agent',
  parameters: {
    type: 'object',
    properties: {
      include_expired: {
        type: 'boolean',
        description: 'Include expired links in the results (default: false)'
      }
    },
    required: []
  }
}
```

#### `temp_chat_revoke_link` Tool
```typescript
{
  name: 'temp_chat_revoke_link',
  description: 'Immediately deactivate a temporary chat link',
  parameters: {
    type: 'object',
    properties: {
      link_id: {
        type: 'string',
        description: 'UUID of the link to revoke'
      }
    },
    required: ['link_id']
  }
}
```

### 3. Edge Function Implementation

#### Create `temporary-chat-mcp` Edge Function
- **Location**: `supabase/functions/temporary-chat-mcp/index.ts`
- **Purpose**: Handle all temporary chat link operations
- **Actions**: create_link, list_links, revoke_link, get_sessions

#### Edge Function Structure:
```typescript
serve(async (req: Request) => {
  const { action, agent_id, user_id, params } = await req.json();
  
  switch (action) {
    case 'create_link':
      return await createTemporaryLink(agent_id, user_id, params);
    case 'list_links':
      return await listTemporaryLinks(agent_id, user_id, params);
    case 'revoke_link':
      return await revokeTemporaryLink(agent_id, user_id, params);
    case 'get_sessions':
      return await getActiveSessions(agent_id, user_id, params);
    default:
      return new Response(JSON.stringify({ error: 'Unknown action' }), { status: 400 });
  }
});
```

### 4. Permission and Authorization

#### Agent Permission Model
- **No Special Permissions Required**: All agents can create temporary chat links
- **User-Scoped**: Users can only manage links for their own agents
- **Rate Limiting**: Prevent abuse through reasonable limits

#### RLS Integration
- Leverage existing RLS patterns
- Service role access for edge functions
- User-scoped data access

### 5. Tool Registration Process

#### Automatic Registration
Since temporary chat tools don't require external OAuth or API keys, they can be automatically available to all agents:

1. **Add to tool-generator.ts**: Include parameter generation for temp_chat_ tools
2. **Add to scope-mapper.ts**: Map internal capability to tool names
3. **Update database-service.ts**: Include temp chat tools in agent permissions
4. **Register in universal-tool-executor.ts**: Add routing configuration

#### Alternative: Database-Driven Registration
- Add entries to `service_providers` table for internal tools
- Create agent permissions automatically
- More flexible but requires database changes

## Implementation Approach

### Phase 1: Edge Function Development
1. Create `temporary-chat-mcp` edge function
2. Implement core CRUD operations for temporary links
3. Add proper error handling and validation

### Phase 2: Tool Registration
1. Add tool definitions to `tool-generator.ts`
2. Update `universal-tool-executor.ts` routing map
3. Test tool discovery through `get-agent-tools`

### Phase 3: Integration Testing
1. Test tool execution through chat interface
2. Validate parameter passing and response handling
3. Ensure proper error messages for LLM retry mechanism

## Security Considerations

### 1. Rate Limiting
- Limit number of active links per agent
- Limit link creation frequency
- Prevent abuse through reasonable defaults

### 2. Data Validation
- Validate all input parameters
- Sanitize user-provided content
- Enforce business rules (max expiration, session limits)

### 3. Access Control
- Agent can only manage their own links
- User can only access their agent's links
- Proper RLS policy enforcement

## Error Handling Strategy

Following existing patterns from other MCP tools:

### 1. Structured Error Responses
```typescript
return {
  success: false,
  error: 'Link creation failed: Maximum active links exceeded (5)',
  metadata: {
    current_active_links: 5,
    max_allowed: 5,
    suggestion: 'Please revoke an existing link before creating a new one'
  }
};
```

### 2. LLM-Friendly Error Enhancement
- Clear, actionable error messages
- Suggestions for resolution
- Context about current state

## Performance Considerations

### 1. Database Queries
- Efficient indexing on frequently queried fields
- Minimize database round trips
- Use prepared statements where possible

### 2. Caching Strategy
- Cache active link status
- Cache agent permissions
- Use Supabase real-time for updates

### 3. Cleanup Operations
- Scheduled cleanup of expired links
- Automatic session termination
- Efficient bulk operations

## Integration Points

### 1. Existing Chat System
- Use current `chat_messages_v2` for message storage
- Leverage `conversation_sessions` for session tracking
- Maintain compatibility with real-time subscriptions

### 2. Agent Management
- Integrate with existing agent settings
- Use current agent permission system
- Maintain agent-user relationship model

### 3. Notification System
- Integrate with existing email/SMS providers
- Use current task scheduler for automated link sharing
- Leverage existing template system

## Next Steps

1. **Create edge function skeleton** with basic CRUD operations
2. **Add tool definitions** to existing tool generation system
3. **Test tool registration** through get-agent-tools endpoint
4. **Implement parameter validation** and error handling
5. **Add to universal tool executor** routing configuration

## File Dependencies for Implementation

### New Files:
- `supabase/functions/temporary-chat-mcp/index.ts`
- `supabase/functions/temporary-chat-mcp/handlers.ts`
- `supabase/functions/temporary-chat-mcp/validation.ts`

### Modified Files:
- `supabase/functions/chat/function_calling/universal-tool-executor.ts`
- `supabase/functions/get-agent-tools/tool-generator.ts`
- `supabase/functions/get-agent-tools/scope-mapper.ts` (optional)

## Backup Requirements

Before implementing:
- Backup `universal-tool-executor.ts`
- Backup `tool-generator.ts`
- Test tool registration on development environment first
