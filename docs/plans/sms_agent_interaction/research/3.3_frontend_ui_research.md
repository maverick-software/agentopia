# Frontend UI Research for SMS Agent Interaction

## Current ChannelsTab Structure Analysis

### Component Architecture
The `ChannelsTab` component follows a clear pattern for managing communication channels:

**State Management:**
```typescript
interface ChannelSettings {
  email_enabled: boolean;
  sms_enabled: boolean;
  slack_enabled: boolean;
  discord_enabled: boolean;
  telegram_enabled: boolean;
  whatsapp_enabled: boolean;
}

const [settings, setSettings] = useState<ChannelSettings>({
  email_enabled: false,
  sms_enabled: false,
  // ... other channels
});
```

**Channel Configuration Pattern:**
```typescript
const channels = [
  {
    id: 'sms_enabled' as keyof ChannelSettings,
    name: 'SMS',
    description: 'Send and receive text messages',
    icon: Phone,
    enabled: settings.sms_enabled,
    requiresAuth: 'API',
    providers: getConnectedProviders('sms'),
    status: settings.sms_enabled ? 'configured' : 'not_configured'
  },
  // ... other channels
];
```

### SMS Provider Modal Implementation
The current SMS provider selection uses `openSmsProviderModal()`:

```typescript
const openSmsProviderModal = async () => {
  const { data: credentials } = await supabase
    .from('user_integration_credentials')
    .select(`*, service_providers!inner(name, display_name)`)
    .eq('user_id', user?.id)
    .in('connection_status', ['active', 'connected'])
    .in('service_providers.name', ['twilio', 'aws_sns', 'clicksend_sms']);

  setCredentialModal({
    isOpen: true,
    channelType: 'sms',
    selectedProvider: '',
    availableProviders: [
      { 
        id: 'clicksend_sms', 
        name: 'ClickSend SMS', 
        description: 'ClickSend SMS/MMS service',
        requiresApiKey: true, 
        requiresOAuth: false, 
        authType: 'api_key' 
      },
      // ... other providers
    ],
    availableCredentials: credentials || []
  });
};
```

### UI Component Structure
**Card Layout Pattern:**
```tsx
<Card key={channel.id}>
  <CardContent className="p-6">
    <div className="flex items-start justify-between">
      <div className="flex items-start gap-4">
        <div className={`p-2 rounded-lg ${iconStyles}`}>
          <Icon className="w-5 h-5" />
        </div>
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-1">
            <h4 className="font-medium">{channel.name}</h4>
            {/* Status badges */}
          </div>
          <p className="text-sm text-muted-foreground mb-2">
            {channel.description}
          </p>
          <div className="flex items-center gap-2">
            {/* Provider badges */}
          </div>
        </div>
      </div>
      <div className="flex items-center gap-3">
        {/* Configure button and toggle switch */}
      </div>
    </div>
  </CardContent>
</Card>
```

## SMS Interaction Enhancement Design

### New State Requirements
We need to extend the current state to include SMS interaction settings:

```typescript
interface SmsInteractionSettings {
  sms_interaction_enabled: boolean;
  auto_respond: boolean;
  welcome_message: string;
  response_timeout_minutes: number;
  max_daily_conversations: number;
}

const [smsSettings, setSmsSettings] = useState<SmsInteractionSettings>({
  sms_interaction_enabled: false,
  auto_respond: true,
  welcome_message: 'Hello! I\'m an AI agent. How can I help you today?',
  response_timeout_minutes: 30,
  max_daily_conversations: 50
});
```

### Enhanced SMS Channel Card
The SMS channel card needs additional UI elements for interaction configuration:

```tsx
// Enhanced SMS channel configuration
{channel.id === 'sms_enabled' && channel.enabled && (
  <div className="mt-4 pt-4 border-t">
    <div className="flex items-center justify-between mb-3">
      <div>
        <h5 className="font-medium text-sm">SMS Interaction</h5>
        <p className="text-xs text-muted-foreground">
          Allow users to send SMS messages and receive responses
        </p>
      </div>
      <Select
        value={smsSettings.sms_interaction_enabled ? 'enabled' : 'disabled'}
        onValueChange={(value) => handleSmsInteractionToggle(value === 'enabled')}
      >
        <SelectTrigger className="w-32">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="disabled">Disabled</SelectItem>
          <SelectItem value="enabled">Enabled</SelectItem>
        </SelectContent>
      </Select>
    </div>
    
    {smsSettings.sms_interaction_enabled && (
      <div className="space-y-3">
        <div className="flex items-center justify-between">
          <Label htmlFor="auto-respond" className="text-sm">
            Auto-respond to messages
          </Label>
          <Switch
            id="auto-respond"
            checked={smsSettings.auto_respond}
            onCheckedChange={(checked) => 
              setSmsSettings(prev => ({ ...prev, auto_respond: checked }))
            }
          />
        </div>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={() => setShowSmsSettingsModal(true)}
        >
          <Settings className="w-4 h-4 mr-2" />
          Configure Settings
        </Button>
      </div>
    )}
  </div>
)}
```

### SMS Settings Modal Component
A dedicated modal for detailed SMS interaction configuration:

```tsx
// New component: SmsInteractionSettings.tsx
interface SmsSettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
  agentId: string;
  settings: SmsInteractionSettings;
  onSettingsChange: (settings: SmsInteractionSettings) => void;
}

export function SmsSettingsModal({
  isOpen,
  onClose,
  agentId,
  settings,
  onSettingsChange
}: SmsSettingsModalProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[600px] max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>SMS Interaction Settings</DialogTitle>
          <DialogDescription>
            Configure how your agent handles SMS conversations
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-6 py-4">
          {/* Welcome Message */}
          <div className="space-y-2">
            <Label htmlFor="welcome-message">Welcome Message</Label>
            <textarea
              id="welcome-message"
              value={settings.welcome_message}
              onChange={(e) => onSettingsChange({
                ...settings,
                welcome_message: e.target.value
              })}
              className="w-full p-3 border rounded-md resize-none"
              rows={3}
              placeholder="Hello! I'm an AI agent. How can I help you today?"
            />
            <p className="text-xs text-muted-foreground">
              This message is sent when a new SMS conversation starts
            </p>
          </div>
          
          {/* Response Timeout */}
          <div className="space-y-2">
            <Label htmlFor="timeout">Response Timeout (minutes)</Label>
            <Select
              value={settings.response_timeout_minutes.toString()}
              onValueChange={(value) => onSettingsChange({
                ...settings,
                response_timeout_minutes: parseInt(value)
              })}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="15">15 minutes</SelectItem>
                <SelectItem value="30">30 minutes</SelectItem>
                <SelectItem value="60">1 hour</SelectItem>
                <SelectItem value="120">2 hours</SelectItem>
                <SelectItem value="240">4 hours</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Daily Conversation Limit */}
          <div className="space-y-2">
            <Label htmlFor="daily-limit">Max Daily Conversations</Label>
            <Select
              value={settings.max_daily_conversations.toString()}
              onValueChange={(value) => onSettingsChange({
                ...settings,
                max_daily_conversations: parseInt(value)
              })}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="10">10 conversations</SelectItem>
                <SelectItem value="25">25 conversations</SelectItem>
                <SelectItem value="50">50 conversations</SelectItem>
                <SelectItem value="100">100 conversations</SelectItem>
                <SelectItem value="200">200 conversations</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Auto-respond Toggle */}
          <div className="flex items-center justify-between">
            <div>
              <Label htmlFor="auto-respond-modal">Auto-respond to messages</Label>
              <p className="text-xs text-muted-foreground">
                Agent automatically responds to incoming SMS messages
              </p>
            </div>
            <Switch
              id="auto-respond-modal"
              checked={settings.auto_respond}
              onCheckedChange={(checked) => onSettingsChange({
                ...settings,
                auto_respond: checked
              })}
            />
          </div>
        </div>
        
        <div className="flex justify-end gap-2">
          <Button variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button onClick={handleSaveSettings}>
            Save Settings
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

## SMS Conversation Management UI

### Active SMS Conversations Component
A component to display and manage active SMS conversations:

```tsx
// New component: SmsConversationList.tsx
interface SmsConversation {
  id: string;
  phone_number: string;
  last_message_at: string;
  message_count: number;
  is_active: boolean;
}

export function SmsConversationList({ agentId }: { agentId: string }) {
  const [conversations, setConversations] = useState<SmsConversation[]>([]);
  
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <MessageSquare className="w-5 h-5" />
          Active SMS Conversations
        </CardTitle>
        <CardDescription>
          Manage ongoing SMS conversations with users
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          {conversations.map((conversation) => (
            <div 
              key={conversation.id}
              className="flex items-center justify-between p-3 border rounded-lg"
            >
              <div>
                <p className="font-medium">{conversation.phone_number}</p>
                <p className="text-sm text-muted-foreground">
                  {conversation.message_count} messages • 
                  Last: {formatRelativeTime(conversation.last_message_at)}
                </p>
              </div>
              <div className="flex items-center gap-2">
                <Badge variant={conversation.is_active ? "default" : "secondary"}>
                  {conversation.is_active ? "Active" : "Inactive"}
                </Badge>
                <Button variant="outline" size="sm">
                  View Chat
                </Button>
              </div>
            </div>
          ))}
          
          {conversations.length === 0 && (
            <div className="text-center py-8 text-muted-foreground">
              <MessageSquare className="w-12 h-12 mx-auto mb-4 opacity-50" />
              <p>No active SMS conversations</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

## Chat Interface Enhancements

### SMS Channel Indicator
Components to show SMS channel context in chat messages:

```tsx
// New component: SmsChannelIndicator.tsx
interface SmsChannelIndicatorProps {
  phoneNumber: string;
  isInbound: boolean;
}

export function SmsChannelIndicator({ phoneNumber, isInbound }: SmsChannelIndicatorProps) {
  return (
    <div className="flex items-center gap-1 text-xs text-muted-foreground">
      <Phone className="w-3 h-3" />
      <span>SMS</span>
      <span>•</span>
      <span>{phoneNumber}</span>
      {isInbound && (
        <>
          <span>•</span>
          <Badge variant="outline" className="text-xs">
            Inbound
          </Badge>
        </>
      )}
    </div>
  );
}

// New component: SmsMessageBadge.tsx
interface SmsMessageBadgeProps {
  message: ChatMessage;
}

export function SmsMessageBadge({ message }: SmsMessageBadgeProps) {
  if (message.metadata?.channel !== 'sms') return null;
  
  return (
    <div className="flex items-center gap-1 mb-1">
      <Badge variant="secondary" className="text-xs">
        <Phone className="w-3 h-3 mr-1" />
        SMS
      </Badge>
      {message.metadata?.inbound && (
        <Badge variant="outline" className="text-xs">
          From {message.metadata.phone_number}
        </Badge>
      )}
    </div>
  );
}
```

## Hooks and Services Design

### SMS Conversation Hook
```tsx
// New hook: useSmsConversations.ts
export function useSmsConversations(agentId: string) {
  const [conversations, setConversations] = useState<SmsConversation[]>([]);
  const [loading, setLoading] = useState(true);
  const supabase = useSupabaseClient();
  
  const fetchConversations = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from('sms_conversations')
        .select('*')
        .eq('agent_id', agentId)
        .eq('is_active', true)
        .order('last_message_at', { ascending: false });
      
      if (error) throw error;
      setConversations(data || []);
    } catch (error) {
      console.error('Error fetching SMS conversations:', error);
    } finally {
      setLoading(false);
    }
  }, [agentId, supabase]);
  
  useEffect(() => {
    fetchConversations();
  }, [fetchConversations]);
  
  return {
    conversations,
    loading,
    refetch: fetchConversations
  };
}
```

### SMS Settings Hook
```tsx
// New hook: useSmsSettings.ts
export function useSmsSettings(agentId: string) {
  const [settings, setSettings] = useState<SmsInteractionSettings | null>(null);
  const [loading, setLoading] = useState(true);
  const supabase = useSupabaseClient();
  
  const fetchSettings = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from('agent_sms_settings')
        .select('*')
        .eq('agent_id', agentId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      
      setSettings(data || {
        sms_interaction_enabled: false,
        auto_respond: true,
        welcome_message: 'Hello! I\'m an AI agent. How can I help you today?',
        response_timeout_minutes: 30,
        max_daily_conversations: 50
      });
    } catch (error) {
      console.error('Error fetching SMS settings:', error);
    } finally {
      setLoading(false);
    }
  }, [agentId, supabase]);
  
  const updateSettings = useCallback(async (newSettings: Partial<SmsInteractionSettings>) => {
    try {
      const { error } = await supabase
        .from('agent_sms_settings')
        .upsert({
          agent_id: agentId,
          ...newSettings,
          updated_at: new Date().toISOString()
        });
      
      if (error) throw error;
      
      setSettings(prev => prev ? { ...prev, ...newSettings } : null);
      return { success: true };
    } catch (error) {
      console.error('Error updating SMS settings:', error);
      return { success: false, error };
    }
  }, [agentId, supabase]);
  
  return {
    settings,
    loading,
    updateSettings,
    refetch: fetchSettings
  };
}
```

## File Structure Summary

### New Components
```
src/components/modals/agent-settings/sms/
├── SmsInteractionSettings.tsx    # SMS configuration modal (250 lines)
├── SmsConversationList.tsx       # Active conversations display (200 lines)
└── types.ts                      # TypeScript interfaces (50 lines)

src/components/chat/
├── SmsChannelIndicator.tsx       # SMS channel indicator (100 lines)
└── SmsMessageBadge.tsx          # SMS message styling (75 lines)
```

### Enhanced Components
```
src/components/modals/agent-settings/
└── ChannelsTab.tsx              # Enhanced with SMS interaction dropdown (existing + 100 lines)
```

### New Hooks and Services
```
src/hooks/
├── useSmsConversations.ts       # SMS conversation management (150 lines)
└── useSmsSettings.ts            # SMS settings management (100 lines)

src/services/
└── smsService.ts                # SMS-related API calls (200 lines)
```

## Integration Strategy

### Phase 1: Basic Toggle
1. Add SMS interaction toggle to existing SMS channel card
2. Simple enabled/disabled dropdown
3. Basic settings persistence

### Phase 2: Detailed Configuration
1. Add SMS settings modal with full configuration
2. Implement conversation management UI
3. Add chat interface indicators

### Phase 3: Advanced Features
1. Real-time conversation updates
2. Conversation analytics
3. Advanced SMS routing options

This research provides the foundation for implementing a comprehensive SMS interaction UI that integrates seamlessly with the existing ChannelsTab architecture while providing intuitive configuration and management capabilities.
