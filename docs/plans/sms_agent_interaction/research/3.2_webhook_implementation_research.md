# Webhook Implementation Research for ClickSend SMS

## Current Edge Function Patterns Analysis

### Standard Edge Function Structure
Based on analysis of existing edge functions (stripe-webhook, clicksend-api, admin-stripe-config), Agentopia follows these patterns:

**Import Structure:**
```typescript
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
import { createClient } from 'npm:@supabase/supabase-js@2.39.7';
```

**CORS Headers:**
```typescript
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};
```

**Main Handler Pattern:**
```typescript
serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Request validation
    // Authentication (optional for webhooks)
    // Processing logic
    // Response
  } catch (error) {
    // Error handling
  }
});
```

## ClickSend Webhook Specifics

### Expected Webhook Data Format
Based on ClickSend documentation, webhooks send `application/x-www-form-urlencoded` data:

```typescript
interface ClickSendWebhookData {
  message_id: string;      // Unique message identifier
  from: string;           // Sender's phone number (+1234567890)
  to: string;             // Recipient number (our ClickSend number)
  body: string;           // Message content
  timestamp: string;      // Unix timestamp or ISO string
  keyword?: string;       // Keyword matching (if configured)
}
```

### Request Parsing
```typescript
// Parse form data instead of JSON
const formData = await req.formData();
const webhookData: ClickSendWebhookData = {
  message_id: formData.get('message_id') as string,
  from: formData.get('from') as string,
  to: formData.get('to') as string,
  body: formData.get('body') as string,
  timestamp: formData.get('timestamp') as string,
  keyword: formData.get('keyword') as string || undefined,
};
```

## Security Implementation

### Webhook Validation Strategy
Unlike Stripe which provides signature verification, ClickSend webhook security relies on:

1. **IP Whitelist**: Verify requests come from ClickSend IPs
2. **HTTPS Only**: Supabase Edge Functions provide this automatically
3. **Rate Limiting**: Prevent abuse and spam
4. **Data Validation**: Strict input validation

**IP Validation Example:**
```typescript
const CLICKSEND_IPS = [
  '103.16.199.0/24',
  '103.16.198.0/24',
  // Add ClickSend IP ranges
];

function validateClickSendIP(req: Request): boolean {
  const clientIP = req.headers.get('cf-connecting-ip') || 
                   req.headers.get('x-forwarded-for') || 
                   req.headers.get('x-real-ip');
  
  if (!clientIP) return false;
  
  // Check if IP is in allowed ranges
  return CLICKSEND_IPS.some(range => isIPInRange(clientIP, range));
}
```

### Rate Limiting Implementation
```typescript
interface RateLimitState {
  [phoneNumber: string]: {
    count: number;
    resetTime: number;
  };
}

const rateLimitState: RateLimitState = {};

function checkRateLimit(phoneNumber: string): boolean {
  const now = Date.now();
  const hourMs = 60 * 60 * 1000;
  
  if (!rateLimitState[phoneNumber]) {
    rateLimitState[phoneNumber] = { count: 1, resetTime: now + hourMs };
    return true;
  }
  
  const state = rateLimitState[phoneNumber];
  
  if (now > state.resetTime) {
    state.count = 1;
    state.resetTime = now + hourMs;
    return true;
  }
  
  if (state.count >= 10) { // 10 messages per hour limit
    return false;
  }
  
  state.count++;
  return true;
}
```

## Message Processing Architecture

### Processing Flow
1. **Validate Request**: IP, rate limits, data format
2. **Parse Phone Number**: Normalize to international format
3. **Find/Create Conversation**: Map phone number to conversation_id
4. **Insert Message**: Add to chat_messages_v2 table
5. **Trigger Response**: Notify agent or auto-respond
6. **Return Success**: Acknowledge webhook processing

### Phone Number Normalization
```typescript
function normalizePhoneNumber(phone: string): string {
  // Remove all non-digit characters except +
  let normalized = phone.replace(/[^\d+]/g, '');
  
  // Add + if missing
  if (!normalized.startsWith('+')) {
    normalized = '+' + normalized;
  }
  
  // Validate international format
  if (!/^\+[1-9]\d{1,14}$/.test(normalized)) {
    throw new Error(`Invalid phone number format: ${phone}`);
  }
  
  return normalized;
}
```

### Conversation Management
```typescript
async function findOrCreateConversation(
  supabase: any,
  agentId: string,
  phoneNumber: string
): Promise<{ conversation_id: string; session_id: string }> {
  
  // Try to find existing conversation
  const { data: existing } = await supabase
    .from('sms_conversations')
    .select('conversation_id, session_id')
    .eq('agent_id', agentId)
    .eq('phone_number', phoneNumber)
    .eq('is_active', true)
    .single();
  
  if (existing) {
    return existing;
  }
  
  // Create new conversation
  const conversation_id = crypto.randomUUID();
  const session_id = crypto.randomUUID();
  
  const { error } = await supabase
    .from('sms_conversations')
    .insert({
      agent_id: agentId,
      phone_number: phoneNumber,
      conversation_id,
      session_id,
      is_active: true,
      message_count: 0
    });
  
  if (error) throw error;
  
  return { conversation_id, session_id };
}
```

### Message Insertion
```typescript
async function insertSMSMessage(
  supabase: any,
  conversationData: { conversation_id: string; session_id: string },
  messageData: ClickSendWebhookData
): Promise<void> {
  
  const chatMessage = {
    conversation_id: conversationData.conversation_id,
    session_id: conversationData.session_id,
    sender_user_id: null, // External SMS user
    sender_agent_id: null,
    role: 'user',
    content: {
      type: 'text',
      text: messageData.body,
      channel: 'sms'
    },
    metadata: {
      channel: 'sms',
      phone_number: messageData.from,
      clicksend_message_id: messageData.message_id,
      timestamp: messageData.timestamp,
      inbound: true
    },
    context: {
      conversation_id: conversationData.conversation_id,
      session_id: conversationData.session_id,
      channel_id: null,
      user_id: null,
      agent_id: null // Will be determined by conversation routing
    }
  };
  
  const { error } = await supabase
    .from('chat_messages_v2')
    .insert(chatMessage);
  
  if (error) throw error;
}
```

## Error Handling Patterns

### Webhook Error Responses
```typescript
interface WebhookResponse {
  success: boolean;
  message: string;
  processed_message_id?: string;
  error_code?: string;
}

// Success response
return new Response(JSON.stringify({
  success: true,
  message: 'SMS message processed successfully',
  processed_message_id: messageData.message_id
}), {
  status: 200,
  headers: { 'Content-Type': 'application/json' }
});

// Error response
return new Response(JSON.stringify({
  success: false,
  message: 'Invalid phone number format',
  error_code: 'INVALID_PHONE'
}), {
  status: 400,
  headers: { 'Content-Type': 'application/json' }
});
```

### Logging Strategy
```typescript
function logWebhookEvent(
  messageId: string,
  phoneNumber: string,
  success: boolean,
  error?: string
) {
  const logData = {
    webhook_type: 'clicksend_inbound_sms',
    message_id: messageId,
    phone_number: phoneNumber, // Consider hashing for privacy
    success,
    error,
    timestamp: new Date().toISOString()
  };
  
  console.log('[ClickSend Webhook]', JSON.stringify(logData));
}
```

## Agent Routing Logic

### Multi-Agent Support
```typescript
async function determineTargetAgent(
  supabase: any,
  phoneNumber: string,
  toNumber: string
): Promise<string | null> {
  
  // Strategy 1: Check for existing conversation
  const { data: existing } = await supabase
    .from('sms_conversations')
    .select('agent_id')
    .eq('phone_number', phoneNumber)
    .eq('is_active', true)
    .single();
  
  if (existing) {
    return existing.agent_id;
  }
  
  // Strategy 2: Round-robin among SMS-enabled agents
  const { data: enabledAgents } = await supabase
    .from('agent_sms_settings')
    .select('agent_id')
    .eq('sms_interaction_enabled', true)
    .order('created_at');
  
  if (!enabledAgents || enabledAgents.length === 0) {
    return null;
  }
  
  // Simple round-robin (could be enhanced with load balancing)
  const agentIndex = Math.abs(phoneNumber.hashCode()) % enabledAgents.length;
  return enabledAgents[agentIndex].agent_id;
}
```

## File Structure Design

### Main Webhook Handler
**File**: `supabase/functions/clicksend-inbound-webhook/index.ts` (250-300 lines)
```typescript
// Main serve() function
// Request validation and parsing
// Agent routing logic
// Response handling
```

### Validation Module
**File**: `supabase/functions/clicksend-inbound-webhook/validation.ts` (100 lines)
```typescript
// IP validation
// Rate limiting
// Data format validation
// Phone number normalization
```

### Message Processor
**File**: `supabase/functions/clicksend-inbound-webhook/message-processor.ts` (200 lines)
```typescript
// Conversation management
// Message insertion
// Auto-response logic
// Error handling
```

### Type Definitions
**File**: `supabase/functions/clicksend-inbound-webhook/types.ts` (50 lines)
```typescript
// Interface definitions
// Type guards
// Constants
```

## Testing Strategy

### Local Testing with ngrok
```bash
# Install ngrok
npm install -g ngrok

# Start local development
supabase functions serve --env-file .env.local

# Expose localhost to internet
ngrok http 54321

# Configure ClickSend webhook URL
# https://abc123.ngrok.io/functions/v1/clicksend-inbound-webhook
```

### Mock Webhook Testing
```typescript
// Test webhook payload
const mockWebhookData = {
  message_id: 'test-123',
  from: '+1234567890',
  to: '+1987654321',
  body: 'Hello agent!',
  timestamp: '1640995200',
  keyword: ''
};

// Send test request
fetch('http://localhost:54321/functions/v1/clicksend-inbound-webhook', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: new URLSearchParams(mockWebhookData)
});
```

## Performance Considerations

### Response Time Requirements
- ClickSend expects webhook response < 10 seconds
- Target: < 500ms response time
- Implement async processing for heavy operations

### Database Optimization
```typescript
// Use database transactions for consistency
const { data, error } = await supabase.rpc('process_inbound_sms', {
  p_agent_id: agentId,
  p_phone_number: phoneNumber,
  p_message_body: messageBody,
  p_message_id: messageId
});
```

## Deployment Considerations

### Environment Variables
```env
CLICKSEND_WEBHOOK_SECRET=optional_secret_key
CLICKSEND_ALLOWED_IPS=103.16.199.0/24,103.16.198.0/24
SUPABASE_URL=your_supabase_url
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
```

### ClickSend Configuration
1. Login to ClickSend Dashboard
2. Navigate to Messaging Settings > SMS & MMS > Inbound Rules
3. Add new rule:
   - Action: URL
   - URL: `https://[project].supabase.co/functions/v1/clicksend-inbound-webhook`
   - Method: POST

This research provides the foundation for implementing a secure, scalable webhook handler that integrates seamlessly with the existing Agentopia architecture while following established patterns and security best practices.
