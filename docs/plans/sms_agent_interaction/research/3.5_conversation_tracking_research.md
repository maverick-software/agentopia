# Conversation Tracking Research for SMS Agent Interaction

## The Challenge

The user asks: "Are we able to track the conversation_id across the chats, so that the inbound signal received by ClickSend contains the conversation ID and that is appended to the URL we provide somehow?"

This is a critical design challenge for maintaining conversation context across SMS interactions.

## Current Conversation System Analysis

### Agentopia Conversation Structure
Based on codebase analysis, Agentopia uses:

```sql
-- chat_messages_v2 table structure
conversation_id UUID NOT NULL,
session_id UUID NOT NULL,
sender_user_id UUID REFERENCES auth.users(id),
sender_agent_id UUID REFERENCES agents(id),
role VARCHAR(20) NOT NULL CHECK (role IN ('system', 'user', 'assistant', 'tool')),
content JSONB NOT NULL,
metadata JSONB DEFAULT '{}',
context JSONB DEFAULT '{}'
```

**Key Insight**: Every message has a `conversation_id` that links all messages in a conversation thread.

## ClickSend API Limitations & Solutions

### ClickSend Webhook Data Format
ClickSend webhooks provide:
```
message_id: Unique message identifier
from: Sender's phone number (+1234567890)
to: Recipient number (our ClickSend number)
body: Message content
timestamp: Unix timestamp or ISO string
```

**Critical Finding**: ClickSend webhooks do NOT include custom data or conversation tracking by default.

### Solution Approaches

#### Approach 1: Phone Number-Based Conversation Mapping ✅ RECOMMENDED
**Strategy**: Map phone numbers to conversation IDs in our database

```sql
-- sms_conversations table (from our design)
CREATE TABLE sms_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  phone_number TEXT NOT NULL, -- +1234567890
  conversation_id UUID NOT NULL,
  session_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_message_at TIMESTAMPTZ DEFAULT NOW(),
  is_active BOOLEAN DEFAULT true,
  UNIQUE(agent_id, phone_number)
);
```

**Workflow**:
1. **Outbound SMS**: When agent sends SMS, create/update `sms_conversations` record
2. **Inbound SMS**: Webhook handler looks up `conversation_id` by `phone_number` + `agent_id`
3. **Message Insertion**: Insert inbound message with correct `conversation_id`

#### Approach 2: ClickSend Custom String (Limited Support) ⚠️
**Research Finding**: ClickSend API supports `custom_string` parameter in outbound messages

```javascript
// ClickSend SMS payload with custom data
{
  "messages": [
    {
      "source": "agentopia",
      "from": "+1234567890",
      "to": "+0987654321", 
      "body": "Hello from agent!",
      "custom_string": "conv_12345678-1234-1234-1234-123456789012"
    }
  ]
}
```

**Limitations**:
- Only works if the inbound SMS is a REPLY to our outbound SMS
- Not reliable for new conversations initiated by users
- ClickSend webhook may not always include custom_string

#### Approach 3: Hybrid Solution ✅ BEST APPROACH
**Combine both approaches for maximum reliability**

## Recommended Implementation

### Database Design
```sql
-- Enhanced sms_conversations table
CREATE TABLE sms_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  phone_number TEXT NOT NULL,
  conversation_id UUID NOT NULL,
  session_id UUID NOT NULL,
  
  -- Conversation state
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_message_at TIMESTAMPTZ DEFAULT NOW(),
  last_outbound_message_id TEXT, -- ClickSend message ID
  is_active BOOLEAN DEFAULT true,
  message_count INTEGER DEFAULT 0,
  
  -- Constraints
  UNIQUE(agent_id, phone_number)
);

-- Index for fast lookups
CREATE INDEX idx_sms_conversations_lookup 
  ON sms_conversations(phone_number, agent_id) 
  WHERE is_active = true;
```

### Outbound SMS Enhancement
Update the ClickSend API handler to include conversation tracking:

```typescript
// Enhanced handleSendSMS function
async function handleSendSMS(client: ClickSendClient, params: any, context: any): Promise<any> {
  const { to, body, message, from, conversation_id, agent_id } = params;
  const messageText = body || message;
  
  // Validate parameters...
  
  // Send SMS with custom tracking
  const result = await client.sendSMS(to, messageText, from, {
    custom_string: conversation_id ? `conv_${conversation_id}` : undefined,
    source: 'agentopia'
  });
  
  // Update or create SMS conversation mapping
  if (conversation_id && agent_id) {
    await supabase.from('sms_conversations').upsert({
      agent_id: agent_id,
      phone_number: to,
      conversation_id: conversation_id,
      session_id: context.session_id || crypto.randomUUID(),
      last_outbound_message_id: result?.data?.messages?.[0]?.message_id,
      last_message_at: new Date().toISOString(),
      message_count: 1
    }, {
      onConflict: 'agent_id,phone_number'
    });
  }
  
  return result;
}
```

### Enhanced ClickSend Client
```typescript
class ClickSendClient {
  // Enhanced sendSMS method
  async sendSMS(to: string, body: string, from?: string, options?: {
    custom_string?: string;
    source?: string;
  }): Promise<any> {
    const payload = {
      messages: [
        {
          source: options?.source || 'agentopia',
          from: from || null,
          to: to,
          body: body,
          custom_string: options?.custom_string || undefined
        }
      ]
    };

    return await this.makeRequest('/sms/send', 'POST', payload);
  }
}
```

### Inbound Webhook Handler Logic
```typescript
// In clicksend-inbound-webhook/message-processor.ts
async function processInboundSMS(webhookData: ClickSendWebhookData, supabase: any) {
  const { from: phoneNumber, to: ourNumber, body, message_id, custom_string } = webhookData;
  
  // Strategy 1: Try to extract conversation_id from custom_string (if reply)
  let conversation_id = null;
  if (custom_string && custom_string.startsWith('conv_')) {
    conversation_id = custom_string.replace('conv_', '');
  }
  
  // Strategy 2: Look up by phone number + agent mapping
  if (!conversation_id) {
    const { data: smsConversation } = await supabase
      .from('sms_conversations')
      .select('conversation_id, session_id, agent_id')
      .eq('phone_number', phoneNumber)
      .eq('is_active', true)
      .single();
    
    if (smsConversation) {
      conversation_id = smsConversation.conversation_id;
    }
  }
  
  // Strategy 3: Create new conversation if none found
  if (!conversation_id) {
    // Determine target agent (round-robin, load balancing, etc.)
    const targetAgent = await determineTargetAgent(supabase, phoneNumber, ourNumber);
    
    if (targetAgent) {
      conversation_id = crypto.randomUUID();
      const session_id = crypto.randomUUID();
      
      // Create new SMS conversation mapping
      await supabase.from('sms_conversations').insert({
        agent_id: targetAgent.id,
        phone_number: phoneNumber,
        conversation_id,
        session_id,
        message_count: 1
      });
    }
  }
  
  // Insert message into chat system
  if (conversation_id) {
    await insertSMSMessage(supabase, {
      conversation_id,
      session_id: smsConversation?.session_id || crypto.randomUUID(),
      phone_number: phoneNumber,
      message_body: body,
      message_id,
      agent_id: smsConversation?.agent_id
    });
  }
}
```

### Chat Integration Context
When agents send SMS through the chat interface, we need to pass conversation context:

```typescript
// In chat function when calling ClickSend
const smsParameters = {
  to: phoneNumber,
  message: messageText,
  conversation_id: currentConversationId, // Pass from chat context
  agent_id: currentAgentId,
  session_id: currentSessionId
};

// This gets passed to ClickSend API handler
await UniversalToolExecutor.executeTool({
  toolName: 'clicksend_send_sms',
  parameters: smsParameters,
  agentId: currentAgentId,
  userId: currentUserId,
  // ... other context
});
```

## Agent Routing Strategy

### Multi-Agent SMS Support
```typescript
async function determineTargetAgent(supabase: any, phoneNumber: string, ourNumber: string) {
  // 1. Check for existing conversation
  const { data: existing } = await supabase
    .from('sms_conversations')
    .select('agent_id, agents!inner(*)')
    .eq('phone_number', phoneNumber)
    .eq('is_active', true)
    .single();
  
  if (existing) {
    return existing.agents;
  }
  
  // 2. Find SMS-enabled agents
  const { data: enabledAgents } = await supabase
    .from('agent_sms_settings')
    .select('agent_id, agents!inner(*)')
    .eq('sms_interaction_enabled', true)
    .order('created_at');
  
  if (!enabledAgents || enabledAgents.length === 0) {
    return null;
  }
  
  // 3. Simple round-robin (could be enhanced)
  const hash = phoneNumber.split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
  
  const index = Math.abs(hash) % enabledAgents.length;
  return enabledAgents[index].agents;
}
```

## Webhook URL Configuration

### Single Webhook URL
**URL**: `https://project.supabase.co/functions/v1/clicksend-inbound-webhook`

**No conversation-specific URLs needed** - the webhook handler determines conversation context internally through phone number mapping.

### Benefits of This Approach
1. **Single Configuration**: Users only need to configure one webhook URL
2. **Automatic Routing**: System automatically routes to correct agent/conversation
3. **Scalable**: Handles multiple agents and conversations
4. **Resilient**: Works even if custom_string is not available
5. **Context Preservation**: Maintains conversation history across SMS interactions

## Implementation Priority

### Phase 1: Basic Phone Number Mapping
1. Create `sms_conversations` table
2. Implement phone number → conversation_id mapping
3. Basic inbound message routing

### Phase 2: Enhanced Tracking
1. Add `custom_string` support to outbound SMS
2. Implement hybrid lookup strategy
3. Add conversation state management

### Phase 3: Advanced Features
1. Multi-agent routing algorithms
2. Conversation analytics
3. Advanced context preservation

## Conclusion

**Answer to the user's question**: We cannot directly append conversation_id to the ClickSend webhook URL, but we can achieve the same result through phone number-based conversation mapping combined with optional custom_string tracking. This approach is more robust and scalable than URL-based tracking.

The system will:
1. **Track conversations** via phone number mapping in the database
2. **Preserve context** across SMS interactions
3. **Route messages** to the correct agent and conversation
4. **Handle new conversations** automatically
5. **Work with a single webhook URL** that users configure once

This solution provides reliable conversation tracking without requiring conversation-specific webhook URLs.
