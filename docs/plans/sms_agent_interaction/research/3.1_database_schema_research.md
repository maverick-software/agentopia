# Database Schema Research for SMS Agent Interaction

## Current Migration Patterns Analysis

### Standard Migration Structure
Based on analysis of existing migrations, Agentopia follows these patterns:

**Migration Header Format:**
```sql
-- Migration: [Description]
-- Date: YYYY-MM-DD
-- Purpose: [Detailed purpose]
-- Dependencies: [Required tables/features]
```

**Table Creation Pattern:**
```sql
CREATE TABLE IF NOT EXISTS table_name (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  [foreign_key] UUID NOT NULL REFERENCES parent_table(id) ON DELETE CASCADE,
  [fields],
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT constraint_name CHECK (condition),
  CONSTRAINT unique_constraint UNIQUE(field1, field2)
);
```

**Index Creation Pattern:**
```sql
CREATE INDEX IF NOT EXISTS idx_table_field ON table_name(field);
CREATE INDEX IF NOT EXISTS idx_table_composite ON table_name(field1, field2);
```

**RLS Policy Pattern:**
```sql
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;

-- User access policies
CREATE POLICY "Users can view own records" ON table_name
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own records" ON table_name
  FOR ALL USING (condition) WITH CHECK (condition);

-- Service role access
CREATE POLICY "Service role full access" ON table_name
  FOR ALL USING (auth.role() = 'service_role');
```

**Trigger Pattern:**
```sql
CREATE OR REPLACE FUNCTION update_table_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_table_updated_at
  BEFORE UPDATE ON table_name
  FOR EACH ROW
  EXECUTE FUNCTION update_table_updated_at();
```

## SMS Tables Design

### Table 1: sms_conversations
**Purpose**: Map phone numbers to conversation IDs for SMS routing

```sql
CREATE TABLE IF NOT EXISTS sms_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  phone_number TEXT NOT NULL,
  conversation_id UUID NOT NULL,
  session_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_message_at TIMESTAMPTZ DEFAULT NOW(),
  message_count INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  
  -- Constraints
  CONSTRAINT unique_agent_phone UNIQUE(agent_id, phone_number),
  CONSTRAINT valid_phone_format CHECK (phone_number ~ '^\+[1-9]\d{1,14}$')
);
```

**Indexes:**
```sql
CREATE INDEX IF NOT EXISTS idx_sms_conversations_agent_id ON sms_conversations(agent_id);
CREATE INDEX IF NOT EXISTS idx_sms_conversations_phone ON sms_conversations(phone_number);
CREATE INDEX IF NOT EXISTS idx_sms_conversations_conversation ON sms_conversations(conversation_id);
CREATE INDEX IF NOT EXISTS idx_sms_conversations_active ON sms_conversations(is_active) WHERE is_active = true;
```

**RLS Policies:**
```sql
-- Users can view SMS conversations for their agents
CREATE POLICY "Users can view SMS conversations for their agents" ON sms_conversations
  FOR SELECT USING (
    agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
  );

-- Users can manage SMS conversations for their agents
CREATE POLICY "Users can manage SMS conversations for their agents" ON sms_conversations
  FOR ALL USING (
    agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
  );

-- Service role full access
CREATE POLICY "Service role full access to SMS conversations" ON sms_conversations
  FOR ALL USING (auth.role() = 'service_role');
```

### Table 2: agent_sms_settings
**Purpose**: Configure SMS interaction settings per agent

```sql
CREATE TABLE IF NOT EXISTS agent_sms_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE UNIQUE,
  sms_interaction_enabled BOOLEAN DEFAULT false,
  auto_respond BOOLEAN DEFAULT true,
  welcome_message TEXT DEFAULT 'Hello! I''m an AI agent. How can I help you today?',
  response_timeout_minutes INTEGER DEFAULT 30,
  max_daily_conversations INTEGER DEFAULT 50,
  rate_limit_per_hour INTEGER DEFAULT 10,
  blacklisted_numbers TEXT[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_timeout CHECK (response_timeout_minutes BETWEEN 1 AND 1440),
  CONSTRAINT valid_daily_limit CHECK (max_daily_conversations BETWEEN 1 AND 1000),
  CONSTRAINT valid_rate_limit CHECK (rate_limit_per_hour BETWEEN 1 AND 100)
);
```

**Indexes:**
```sql
CREATE INDEX IF NOT EXISTS idx_agent_sms_settings_agent_id ON agent_sms_settings(agent_id);
CREATE INDEX IF NOT EXISTS idx_agent_sms_settings_enabled ON agent_sms_settings(sms_interaction_enabled) WHERE sms_interaction_enabled = true;
```

**RLS Policies:**
```sql
-- Users can view SMS settings for their agents
CREATE POLICY "Users can view SMS settings for their agents" ON agent_sms_settings
  FOR SELECT USING (
    agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
  );

-- Users can manage SMS settings for their agents
CREATE POLICY "Users can manage SMS settings for their agents" ON agent_sms_settings
  FOR ALL USING (
    agent_id IN (SELECT id FROM agents WHERE user_id = auth.uid())
  );

-- Service role full access
CREATE POLICY "Service role full access to agent SMS settings" ON agent_sms_settings
  FOR ALL USING (auth.role() = 'service_role');
```

## Integration with Existing Schema

### Relationship to chat_messages_v2
SMS messages will be stored in the existing `chat_messages_v2` table with:
- `conversation_id`: Linked via `sms_conversations.conversation_id`
- `role`: 'user' for inbound SMS, 'assistant' for outbound SMS
- `content`: JSON with SMS-specific metadata
- `metadata`: Include phone number and SMS-specific flags

### Relationship to conversation_sessions
SMS conversations will create entries in `conversation_sessions` with:
- `conversation_id`: Matching the SMS conversation
- `user_id`: NULL (external SMS users)
- `agent_id`: The target agent
- `session_state`: SMS-specific state information

## Phone Number Handling

### International Format Validation
```sql
CONSTRAINT valid_phone_format CHECK (phone_number ~ '^\+[1-9]\d{1,14}$')
```

### Phone Number Normalization Function
```sql
CREATE OR REPLACE FUNCTION normalize_phone_number(input_phone TEXT)
RETURNS TEXT AS $$
BEGIN
  -- Remove all non-digit characters except +
  input_phone := regexp_replace(input_phone, '[^\d+]', '', 'g');
  
  -- Add + if missing and starts with digit
  IF input_phone ~ '^\d' THEN
    input_phone := '+' || input_phone;
  END IF;
  
  -- Validate format
  IF input_phone !~ '^\+[1-9]\d{1,14}$' THEN
    RAISE EXCEPTION 'Invalid phone number format: %', input_phone;
  END IF;
  
  RETURN input_phone;
END;
$$ LANGUAGE plpgsql;
```

## Security Considerations

### Phone Number Privacy
- Store phone numbers in normalized international format
- Consider hashing phone numbers for additional privacy
- Implement data retention policies

### Rate Limiting Schema
The `agent_sms_settings` table includes rate limiting fields:
- `rate_limit_per_hour`: Messages per hour per phone number
- `max_daily_conversations`: New conversations per day
- `blacklisted_numbers`: Array of blocked phone numbers

## Migration Dependencies

### Prerequisites
- `agents` table must exist
- `chat_messages_v2` table must exist
- `conversation_sessions` table must exist

### Migration Order
1. Create `sms_conversations` table
2. Create `agent_sms_settings` table
3. Add RLS policies for both tables
4. Create utility functions (phone normalization)
5. Grant permissions to authenticated users

## Performance Considerations

### Index Strategy
- Primary lookups: agent_id + phone_number
- Conversation routing: phone_number â†’ conversation_id
- Active conversation filtering: is_active = true
- Enabled agents: sms_interaction_enabled = true

### Query Patterns
```sql
-- Find existing conversation
SELECT conversation_id, session_id 
FROM sms_conversations 
WHERE agent_id = ? AND phone_number = ? AND is_active = true;

-- Check if agent has SMS enabled
SELECT sms_interaction_enabled, auto_respond, welcome_message
FROM agent_sms_settings
WHERE agent_id = ? AND sms_interaction_enabled = true;
```

## Backup Strategy

Files to backup before implementation:
- Current database schema dump
- Any existing SMS-related code
- ChannelsTab component (will be modified)

## Testing Requirements

### Database Testing
- Phone number validation constraints
- RLS policy enforcement
- Foreign key constraints
- Index performance
- Unique constraint handling

### Integration Testing
- Conversation creation workflow
- Message routing accuracy
- Rate limiting enforcement
- Privacy policy compliance

## Documentation Requirements

- Table schema documentation
- RLS policy explanations
- Phone number format requirements
- Rate limiting configuration guide
- Privacy and data retention policies

This research provides the foundation for implementing the database schema with consistency to existing Agentopia patterns while ensuring security, performance, and maintainability.
