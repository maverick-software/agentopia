# Security Pattern Research - Task 1.3

**Date:** August 24, 2025  
**Task:** 1.3 Security Pattern Research  
**Objective:** Research credential encryption and storage patterns

## Supabase Vault Security Architecture

### Core Security Principles

Based on the Supabase Vault Encryption Protocol, the following security principles must be followed:

#### 1. Encryption Foundation
- **NEVER** store sensitive data as plain text
- Use Supabase Vault's Authenticated Encryption with Associated Data (AEAD) based on `libsodium`
- Implement proper key management by storing secret IDs, not the secrets themselves
- Ensure all cryptographic operations are server-side only via `SECURITY DEFINER` functions

#### 2. Vault Infrastructure Security
- Vault uses Transparent Column Encryption (TCE) with AES-256 equivalent security
- Encryption keys are managed by Supabase's secured backend systems and are never stored alongside the data
- Authenticated encryption prevents tampering and forgery
- Access to the `vault.decrypted_secrets` view is the primary way to securely access decrypted data at query time

## Current Vault Implementation Patterns

### 1. Vault Integration Verification

```sql
-- Verify Vault integration is working
DO $$
DECLARE
    test_secret_id UUID;
BEGIN
    -- Test vault functionality using the correct function signature
    test_secret_id := vault.create_secret('test_secret_value', 'test_vault_functionality', 'Test secret for vault verification');
    
    -- Clean up the test secret immediately
    DELETE FROM vault.secrets WHERE id = test_secret_id;
    
    RAISE NOTICE 'Vault integration verified and functional';
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Vault test failed with error: %', SQLERRM;
    RAISE NOTICE 'Please ensure the Vault integration is enabled in your Supabase project dashboard.';
END $$;
```

### 2. Secure Metadata Storage Pattern

The current pattern stores vault references (UUIDs) in metadata tables, not the secrets themselves:

```sql
-- Example from user_oauth_connections
CREATE TABLE user_oauth_connections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    oauth_provider_id UUID NOT NULL REFERENCES oauth_providers(id),
    vault_access_token_id TEXT,  -- Reference to encrypted credential in vault
    vault_refresh_token_id TEXT, -- Reference to encrypted refresh token
    encrypted_access_token TEXT, -- Legacy fallback
    encrypted_refresh_token TEXT, -- Legacy fallback
    credential_type connection_credential_type_enum DEFAULT 'oauth',
    connection_status TEXT DEFAULT 'active',
    -- ... other metadata fields
);
```

### 3. Secure Wrapper Functions Pattern

All vault operations use `SECURITY DEFINER` functions for secure access:

```sql
-- Example vault encryption function
CREATE OR REPLACE FUNCTION vault_encrypt(
    data TEXT,
    key_name TEXT DEFAULT 'default'
) RETURNS UUID
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    secret_id UUID;
BEGIN
    -- Store data in vault and return the secret ID
    SELECT vault.create_secret(data, key_name, 'Encrypted credential')
    INTO secret_id;
    
    RETURN secret_id;
END;
$$;

-- Example vault decryption function
CREATE OR REPLACE FUNCTION vault_decrypt(
    vault_id UUID
) RETURNS TEXT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    decrypted_value TEXT;
BEGIN
    -- Retrieve decrypted value from vault
    SELECT decrypted_secret
    INTO decrypted_value
    FROM vault.decrypted_secrets
    WHERE id = vault_id;
    
    RETURN decrypted_value;
END;
$$;
```

## SMTP Security Implementation Strategy

### 1. SMTP Credential Storage

Following the established pattern, SMTP passwords should be stored using the same vault approach:

```sql
-- SMTP configuration with vault reference
CREATE TABLE smtp_configurations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    connection_name TEXT NOT NULL,
    host TEXT NOT NULL,
    port INTEGER NOT NULL DEFAULT 587,
    secure BOOLEAN NOT NULL DEFAULT false,
    username TEXT NOT NULL,
    vault_password_id TEXT NOT NULL,  -- Vault reference for SMTP password
    from_email TEXT NOT NULL,
    from_name TEXT,
    reply_to_email TEXT,
    -- ... other configuration fields
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 2. SMTP Vault Functions

Create dedicated functions for SMTP credential management:

```sql
-- Store SMTP password securely
CREATE OR REPLACE FUNCTION store_smtp_password(
    p_user_id UUID,
    p_config_name TEXT,
    p_password TEXT
) RETURNS UUID
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    vault_id UUID;
BEGIN
    -- Validate user access
    IF p_user_id != auth.uid() THEN
        RAISE EXCEPTION 'Access denied: can only store own credentials';
    END IF;
    
    -- Encrypt password in vault
    SELECT vault.create_secret(
        p_password,
        format('smtp_%s_%s', p_user_id, p_config_name),
        format('SMTP password for %s', p_config_name)
    ) INTO vault_id;
    
    RETURN vault_id;
END;
$$;

-- Retrieve SMTP password securely
CREATE OR REPLACE FUNCTION get_smtp_password(
    p_user_id UUID,
    p_vault_id TEXT
) RETURNS TEXT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    decrypted_password TEXT;
BEGIN
    -- Validate user access
    IF p_user_id != auth.uid() THEN
        RAISE EXCEPTION 'Access denied: can only access own credentials';
    END IF;
    
    -- Retrieve decrypted password
    SELECT decrypted_secret
    INTO decrypted_password
    FROM vault.decrypted_secrets
    WHERE id = p_vault_id::UUID;
    
    IF decrypted_password IS NULL THEN
        RAISE EXCEPTION 'SMTP password not found or access denied';
    END IF;
    
    RETURN decrypted_password;
END;
$$;

-- Update SMTP password
CREATE OR REPLACE FUNCTION update_smtp_password(
    p_user_id UUID,
    p_config_id UUID,
    p_new_password TEXT
) RETURNS UUID
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    old_vault_id TEXT;
    new_vault_id UUID;
    config_name TEXT;
BEGIN
    -- Validate user access and get current vault ID
    SELECT vault_password_id, connection_name
    INTO old_vault_id, config_name
    FROM smtp_configurations
    WHERE id = p_config_id AND user_id = p_user_id;
    
    IF old_vault_id IS NULL THEN
        RAISE EXCEPTION 'SMTP configuration not found or access denied';
    END IF;
    
    -- Create new encrypted password
    SELECT vault.create_secret(
        p_new_password,
        format('smtp_%s_%s', p_user_id, config_name),
        format('Updated SMTP password for %s', config_name)
    ) INTO new_vault_id;
    
    -- Update configuration with new vault ID
    UPDATE smtp_configurations
    SET vault_password_id = new_vault_id::TEXT,
        updated_at = NOW()
    WHERE id = p_config_id;
    
    -- Delete old secret from vault
    DELETE FROM vault.secrets WHERE id = old_vault_id::UUID;
    
    RETURN new_vault_id;
END;
$$;

-- Revoke SMTP credentials
CREATE OR REPLACE FUNCTION revoke_smtp_credentials(
    p_user_id UUID,
    p_config_id UUID
) RETURNS BOOLEAN
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    vault_id TEXT;
BEGIN
    -- Get vault ID for the configuration
    SELECT vault_password_id
    INTO vault_id
    FROM smtp_configurations
    WHERE id = p_config_id AND user_id = p_user_id;
    
    IF vault_id IS NULL THEN
        RAISE EXCEPTION 'SMTP configuration not found or access denied';
    END IF;
    
    -- Mark configuration as inactive
    UPDATE smtp_configurations
    SET is_active = false,
        updated_at = NOW()
    WHERE id = p_config_id;
    
    -- Delete secret from vault
    DELETE FROM vault.secrets WHERE id = vault_id::UUID;
    
    RETURN true;
END;
$$;
```

### 3. Edge Function Security Pattern

For secure access from Edge Functions:

```typescript
// supabase/functions/smtp-api/index.ts
async function getDecryptedSMTPConfig(
  supabase: SupabaseClient,
  configId: string,
  userId: string
): Promise<SMTPConfiguration> {
  // Get SMTP configuration with user validation
  const { data: config, error } = await supabase
    .from('smtp_configurations')
    .select('*')
    .eq('id', configId)
    .eq('user_id', userId)
    .eq('is_active', true)
    .single();
    
  if (error || !config) {
    throw new Error('SMTP configuration not found or access denied');
  }
  
  // Decrypt password using secure function
  const { data: decryptedPassword, error: vaultError } = await supabase
    .rpc('get_smtp_password', { 
      p_user_id: userId, 
      p_vault_id: config.vault_password_id 
    });
    
  if (vaultError || !decryptedPassword) {
    throw new Error('Failed to decrypt SMTP password: ' + (vaultError?.message || 'Unknown error'));
  }
  
  return {
    host: config.host,
    port: config.port,
    secure: config.secure,
    auth: {
      user: config.username,
      pass: decryptedPassword,
    },
    connectionTimeout: config.connection_timeout,
    greetingTimeout: config.greeting_timeout,
    socketTimeout: config.socket_timeout,
  };
}
```

### 4. Row Level Security (RLS) Policies

Implement comprehensive RLS policies for SMTP tables:

```sql
-- Enable RLS on SMTP tables
ALTER TABLE smtp_configurations ENABLE ROW LEVEL SECURITY;
ALTER TABLE agent_smtp_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE smtp_operation_logs ENABLE ROW LEVEL SECURITY;

-- SMTP configurations policies
CREATE POLICY "Users can manage their own SMTP configs" ON smtp_configurations
    FOR ALL USING (user_id = auth.uid());

-- Agent SMTP permissions policies
CREATE POLICY "Users can manage permissions for their agents" ON agent_smtp_permissions
    FOR ALL USING (
        granted_by = auth.uid() OR 
        EXISTS (
            SELECT 1 FROM agents 
            WHERE id = agent_smtp_permissions.agent_id 
            AND user_id = auth.uid()
        )
    );

-- SMTP operation logs policies
CREATE POLICY "Users can view their own SMTP logs" ON smtp_operation_logs
    FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Service role can insert SMTP logs" ON smtp_operation_logs
    FOR INSERT TO service_role WITH CHECK (true);
```

### 5. Input Validation and Sanitization

Implement comprehensive input validation:

```typescript
// Input validation functions
function validateSMTPConfiguration(config: any): SMTPConfiguration {
  const errors: string[] = [];
  
  // Validate host
  if (!config.host || typeof config.host !== 'string') {
    errors.push('Host is required and must be a string');
  }
  
  // Validate port
  if (!config.port || !Number.isInteger(config.port) || config.port < 1 || config.port > 65535) {
    errors.push('Port must be an integer between 1 and 65535');
  }
  
  // Validate username
  if (!config.username || typeof config.username !== 'string') {
    errors.push('Username is required and must be a string');
  }
  
  // Validate password
  if (!config.password || typeof config.password !== 'string') {
    errors.push('Password is required and must be a string');
  }
  
  // Validate email addresses
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(config.from_email)) {
    errors.push('Invalid from_email address');
  }
  
  if (config.reply_to_email && !emailRegex.test(config.reply_to_email)) {
    errors.push('Invalid reply_to_email address');
  }
  
  if (errors.length > 0) {
    throw new Error('Validation errors: ' + errors.join(', '));
  }
  
  return {
    host: config.host.trim(),
    port: parseInt(config.port),
    secure: Boolean(config.secure),
    username: config.username.trim(),
    password: config.password,
    from_email: config.from_email.trim().toLowerCase(),
    reply_to_email: config.reply_to_email?.trim().toLowerCase(),
    connection_timeout: config.connection_timeout || 60000,
    greeting_timeout: config.greeting_timeout || 30000,
    socket_timeout: config.socket_timeout || 60000,
  };
}

function validateEmailParameters(params: any): EmailParameters {
  const errors: string[] = [];
  
  // Validate required fields
  if (!params.to || typeof params.to !== 'string') {
    errors.push('Recipient (to) is required');
  }
  
  if (!params.subject || typeof params.subject !== 'string') {
    errors.push('Subject is required');
  }
  
  if (!params.body || typeof params.body !== 'string') {
    errors.push('Body is required');
  }
  
  // Validate email addresses
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  const validateEmailList = (emails: string, fieldName: string) => {
    const emailList = emails.split(',').map(e => e.trim());
    for (const email of emailList) {
      if (!emailRegex.test(email)) {
        errors.push(`Invalid email in ${fieldName}: ${email}`);
      }
    }
  };
  
  if (params.to && !emailRegex.test(params.to.trim())) {
    errors.push('Invalid recipient email address');
  }
  
  if (params.cc) {
    validateEmailList(params.cc, 'CC');
  }
  
  if (params.bcc) {
    validateEmailList(params.bcc, 'BCC');
  }
  
  // Validate content length
  if (params.subject.length > 200) {
    errors.push('Subject must be 200 characters or less');
  }
  
  if (params.body.length > 1000000) { // 1MB limit
    errors.push('Body must be 1MB or less');
  }
  
  if (errors.length > 0) {
    throw new Error('Validation errors: ' + errors.join(', '));
  }
  
  return {
    to: params.to.trim().toLowerCase(),
    subject: params.subject.trim(),
    body: params.body,
    cc: params.cc ? params.cc.split(',').map(e => e.trim().toLowerCase()) : undefined,
    bcc: params.bcc ? params.bcc.split(',').map(e => e.trim().toLowerCase()) : undefined,
    html: Boolean(params.html),
  };
}
```

### 6. Audit Logging and Monitoring

Implement comprehensive audit logging:

```sql
-- Enhanced SMTP operation logging
CREATE OR REPLACE FUNCTION log_smtp_operation(
    p_user_id UUID,
    p_agent_id UUID,
    p_smtp_config_id UUID,
    p_operation_type TEXT,
    p_operation_params JSONB DEFAULT NULL,
    p_operation_result JSONB DEFAULT NULL,
    p_status TEXT DEFAULT 'success',
    p_error_message TEXT DEFAULT NULL,
    p_recipients_count INTEGER DEFAULT 0,
    p_execution_time_ms INTEGER DEFAULT 0,
    p_client_ip INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
) RETURNS UUID
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    log_id UUID;
BEGIN
    INSERT INTO smtp_operation_logs (
        user_id,
        agent_id,
        smtp_config_id,
        operation_type,
        operation_params,
        operation_result,
        status,
        error_message,
        recipients_count,
        execution_time_ms,
        client_ip,
        user_agent,
        created_at
    ) VALUES (
        p_user_id,
        p_agent_id,
        p_smtp_config_id,
        p_operation_type,
        p_operation_params,
        p_operation_result,
        p_status,
        p_error_message,
        p_recipients_count,
        p_execution_time_ms,
        p_client_ip,
        p_user_agent,
        NOW()
    ) RETURNING id INTO log_id;
    
    RETURN log_id;
END;
$$;
```

### 7. Rate Limiting and Abuse Prevention

Implement rate limiting at multiple levels:

```sql
-- Rate limiting function
CREATE OR REPLACE FUNCTION check_smtp_rate_limit(
    p_user_id UUID,
    p_agent_id UUID,
    p_smtp_config_id UUID
) RETURNS BOOLEAN
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
    daily_count INTEGER;
    hourly_count INTEGER;
    config_daily_limit INTEGER;
    agent_daily_limit INTEGER;
BEGIN
    -- Get configuration limits
    SELECT max_emails_per_day
    INTO config_daily_limit
    FROM smtp_configurations
    WHERE id = p_smtp_config_id AND user_id = p_user_id;
    
    -- Get agent-specific limits
    SELECT daily_email_limit
    INTO agent_daily_limit
    FROM agent_smtp_permissions
    WHERE agent_id = p_agent_id AND smtp_config_id = p_smtp_config_id;
    
    -- Use the more restrictive limit
    config_daily_limit := LEAST(
        COALESCE(config_daily_limit, 100),
        COALESCE(agent_daily_limit, 100)
    );
    
    -- Check daily limit
    SELECT COUNT(*)
    INTO daily_count
    FROM smtp_operation_logs
    WHERE user_id = p_user_id
    AND agent_id = p_agent_id
    AND smtp_config_id = p_smtp_config_id
    AND operation_type = 'send_email'
    AND status = 'success'
    AND created_at >= CURRENT_DATE;
    
    IF daily_count >= config_daily_limit THEN
        RAISE EXCEPTION 'Daily email limit exceeded: % emails sent, limit is %', 
            daily_count, config_daily_limit;
    END IF;
    
    -- Check hourly limit (10% of daily limit per hour)
    SELECT COUNT(*)
    INTO hourly_count
    FROM smtp_operation_logs
    WHERE user_id = p_user_id
    AND agent_id = p_agent_id
    AND smtp_config_id = p_smtp_config_id
    AND operation_type = 'send_email'
    AND status = 'success'
    AND created_at >= NOW() - INTERVAL '1 hour';
    
    IF hourly_count >= (config_daily_limit * 0.1) THEN
        RAISE EXCEPTION 'Hourly email limit exceeded: % emails sent in last hour', 
            hourly_count;
    END IF;
    
    RETURN true;
END;
$$;
```

## Security Best Practices Summary

### 1. Credential Protection
- All SMTP passwords encrypted using Supabase Vault
- No plain text credentials stored anywhere in the system
- Vault references (UUIDs) stored in metadata tables
- Secure wrapper functions with `SECURITY DEFINER`

### 2. Access Control
- Comprehensive RLS policies on all SMTP tables
- User-based access validation in all functions
- Agent-specific permission system
- Service role isolation for Edge Functions

### 3. Input Validation
- Comprehensive validation of all SMTP configuration parameters
- Email address format validation
- Content length and size limits
- SQL injection prevention

### 4. Audit and Monitoring
- Complete audit trail for all SMTP operations
- Rate limiting at user, agent, and configuration levels
- Error logging and monitoring
- Client IP and user agent tracking

### 5. Network Security
- TLS/SSL enforcement for SMTP connections
- Certificate validation
- Connection timeout limits
- Retry logic with exponential backoff

This security implementation provides enterprise-grade protection for SMTP credentials and operations while maintaining usability and performance.
