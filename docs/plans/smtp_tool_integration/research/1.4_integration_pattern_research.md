# Integration Pattern Research - Task 1.4

**Date:** August 24, 2025  
**Task:** 1.4 Integration Pattern Research  
**Objective:** Research function calling integration patterns

## Function Calling Manager Architecture

### Core Integration Pattern

The `FunctionCallingManager` in `supabase/functions/chat/function_calling.ts` follows a consistent pattern for integrating new tools:

#### 1. Tool Definition Structure

Each tool provider defines its tools using the `MCPTool` interface:

```typescript
// Example from existing integrations
export const GMAIL_MCP_TOOLS: Record<string, MCPTool> = {
  send_email: {
    name: 'send_email',
    description: 'Send an email through Gmail',
    inputSchema: {
      type: 'object',
      properties: {
        to: { type: 'string', description: 'Recipient email address' },
        subject: { type: 'string', description: 'Email subject' },
        body: { type: 'string', description: 'Email body content' },
        cc: { type: 'string', description: 'CC recipients (optional)' },
        bcc: { type: 'string', description: 'BCC recipients (optional)' }
      },
      required: ['to', 'subject', 'body']
    },
    required_scopes: ['gmail.send']
  }
};

export const WEB_SEARCH_MCP_TOOLS: Record<string, MCPTool> = {
  web_search: {
    name: 'web_search',
    description: 'Search the web for information',
    inputSchema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search query' },
        num_results: { type: 'number', description: 'Number of results to return' }
      },
      required: ['query']
    },
    required_scopes: ['web_search']
  }
};
```

#### 2. Tool Discovery in getAvailableTools()

The `getAvailableTools()` method queries each provider and combines their tools:

```typescript
async getAvailableTools(agentId: string, userId: string): Promise<OpenAIFunction[]> {
  const allTools: OpenAIFunction[] = [];
  
  try {
    // Get Gmail tools
    const gmailTools = await this.getGmailTools(agentId, userId);
    allTools.push(...gmailTools);
    
    // Get web search tools
    const webSearchTools = await this.getWebSearchTools(agentId, userId);
    allTools.push(...webSearchTools);
    
    // Get SendGrid tools
    const sendgridTools = await this.getSendgridTools(agentId, userId);
    allTools.push(...sendgridTools);
    
    // Get Mailgun tools
    const mailgunTools = await this.getMailgunTools(agentId, userId);
    allTools.push(...mailgunTools);
    
    // Get MCP tools (dynamic)
    const mcpTools = await this.getMCPTools(agentId, userId);
    allTools.push(...mcpTools);
    
    return allTools;
  } catch (error) {
    console.error('[FunctionCalling] Error getting available tools:', error);
    return [];
  }
}
```

#### 3. Provider-Specific Tool Retrieval

Each provider has its own method to check permissions and return available tools:

```typescript
// Example: Gmail tools
private async getGmailTools(agentId: string, userId: string): Promise<OpenAIFunction[]> {
  try {
    // Check if agent has Gmail permissions
    const { data: permissions } = await this.supabaseClient
      .from('agent_oauth_permissions')
      .select(`
        allowed_scopes,
        user_oauth_connections!inner(
          oauth_providers!inner(name),
          connection_status
        )
      `)
      .eq('agent_id', agentId)
      .eq('user_oauth_connections.user_id', userId)
      .eq('user_oauth_connections.oauth_providers.name', 'gmail')
      .eq('user_oauth_connections.connection_status', 'active')
      .eq('is_active', true);

    if (!permissions || permissions.length === 0) {
      return [];
    }

    const allowedScopes = permissions[0].allowed_scopes || [];
    const availableTools: OpenAIFunction[] = [];

    // Check each tool's required scopes
    for (const [toolName, toolDef] of Object.entries(GMAIL_MCP_TOOLS)) {
      const hasRequiredScopes = toolDef.required_scopes.every(scope => 
        allowedScopes.includes(scope)
      );
      
      if (hasRequiredScopes) {
        availableTools.push({
          name: toolDef.name,
          description: toolDef.description,
          parameters: toolDef.inputSchema
        });
      }
    }

    return availableTools;
  } catch (error) {
    console.error('[FunctionCalling] Error getting Gmail tools:', error);
    return [];
  }
}
```

#### 4. Function Execution Routing

The `executeFunction()` method routes function calls to the appropriate provider:

```typescript
async executeFunction(
  agentId: string,
  userId: string,
  functionName: string,
  parameters: Record<string, any>
): Promise<MCPToolResult> {
  const startTime = Date.now();
  
  try {
    console.log(`[FunctionCalling] Executing function ${functionName} for agent ${agentId}`);
    
    // Route to appropriate tool provider
    if (Object.keys(GMAIL_MCP_TOOLS).includes(functionName)) {
      return await this.executeGmailTool(agentId, userId, functionName, parameters);
    }
    
    if (Object.keys(WEB_SEARCH_MCP_TOOLS).includes(functionName)) {
      return await this.executeWebSearchTool(agentId, userId, functionName, parameters);
    }
    
    if (Object.keys(SENDGRID_MCP_TOOLS).includes(functionName)) {
      return await this.executeSendgridTool(agentId, userId, functionName, parameters);
    }
    
    if (Object.keys(MAILGUN_MCP_TOOLS).includes(functionName)) {
      return await this.executeMailgunTool(agentId, userId, functionName, parameters);
    }
    
    // Check if this is an MCP tool using the metadata map
    const mcpMetadata = this.mcpToolMetadata.get(functionName);
    if (mcpMetadata) {
      return await this.executeMCPTool(agentId, userId, mcpMetadata.connectionId, mcpMetadata.toolName, parameters);
    }
    
    return {
      success: false,
      error: `Unknown function: ${functionName}`,
      metadata: { execution_time_ms: Date.now() - startTime }
    };
  } catch (error) {
    console.error(`[FunctionCalling] Error executing function ${functionName}:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Function execution failed',
      metadata: { execution_time_ms: Date.now() - startTime }
    };
  }
}
```

#### 5. Provider-Specific Execution Methods

Each provider has its own execution method that calls the appropriate Edge Function:

```typescript
// Example: SendGrid tool execution
private async executeSendgridTool(
  agentId: string,
  userId: string,
  toolName: string,
  parameters: Record<string, any>
): Promise<MCPToolResult> {
  const start = Date.now();
  try {
    // Validate permissions
    const { data: permissions } = await this.supabaseClient
      .from('agent_oauth_permissions')
      .select(`
        *,
        user_oauth_connections!inner(
          oauth_providers!inner(name),
          credential_type
        )
      `)
      .eq('agent_id', agentId)
      .eq('user_oauth_connections.user_id', userId)
      .eq('user_oauth_connections.oauth_providers.name', 'sendgrid')
      .eq('user_oauth_connections.credential_type', 'api_key')
      .eq('is_active', true)
      .single();

    if (!permissions) {
      return { 
        success: false, 
        error: 'SendGrid not connected', 
        metadata: { execution_time_ms: Date.now() - start } 
      };
    }

    // Call the Edge Function
    const { data, error } = await this.supabaseClient.functions.invoke('sendgrid-api', {
      body: { 
        action: toolName, 
        agent_id: agentId, 
        params: parameters 
      },
      headers: { 'Authorization': `Bearer ${this.authToken}` },
    });
    
    if (error) throw new Error(error.message);
    if (data && !data.success && data.error) throw new Error(data.error);
    
    return { 
      success: true, 
      data: data?.data || data, 
      metadata: { execution_time_ms: Date.now() - start } 
    };
  } catch (err: any) {
    return { 
      success: false, 
      error: err?.message || 'SendGrid tool failed', 
      metadata: { execution_time_ms: Date.now() - start } 
    };
  }
}
```

## SMTP Integration Pattern

### 1. SMTP Tool Definitions

Following the established pattern, SMTP tools should be defined as:

```typescript
// supabase/functions/chat/smtp-tools.ts
export const SMTP_MCP_TOOLS: Record<string, MCPTool> = {
  send_email: {
    name: 'send_email',
    description: 'Send an email via SMTP',
    inputSchema: {
      type: 'object',
      properties: {
        to: { 
          type: 'string', 
          description: 'Recipient email address' 
        },
        subject: { 
          type: 'string', 
          description: 'Email subject line' 
        },
        body: { 
          type: 'string', 
          description: 'Email body content (plain text or HTML)' 
        },
        cc: { 
          type: 'string', 
          description: 'CC recipients (comma-separated email addresses)' 
        },
        bcc: { 
          type: 'string', 
          description: 'BCC recipients (comma-separated email addresses)' 
        },
        html: { 
          type: 'boolean', 
          description: 'Whether the body content is HTML (default: false)' 
        },
        smtp_config_id: {
          type: 'string',
          description: 'ID of the SMTP configuration to use'
        }
      },
      required: ['to', 'subject', 'body', 'smtp_config_id']
    },
    required_scopes: ['send_email']
  },
  test_connection: {
    name: 'test_connection',
    description: 'Test SMTP server connection',
    inputSchema: {
      type: 'object',
      properties: {
        smtp_config_id: {
          type: 'string',
          description: 'ID of the SMTP configuration to test'
        }
      },
      required: ['smtp_config_id']
    },
    required_scopes: ['test_connection']
  }
};
```

### 2. SMTP Tool Discovery

Add SMTP tool discovery to `FunctionCallingManager`:

```typescript
// In function_calling.ts - import SMTP tools
import { SMTP_MCP_TOOLS } from './smtp-tools.ts';

// In getAvailableTools() method - add SMTP tools
async getAvailableTools(agentId: string, userId: string): Promise<OpenAIFunction[]> {
  const allTools: OpenAIFunction[] = [];
  
  try {
    // ... existing tool providers ...
    
    // Get SMTP tools
    const smtpTools = await this.getSMTPTools(agentId, userId);
    allTools.push(...smtpTools);
    
    return allTools;
  } catch (error) {
    console.error('[FunctionCalling] Error getting available tools:', error);
    return [];
  }
}

// SMTP tool discovery method
private async getSMTPTools(agentId: string, userId: string): Promise<OpenAIFunction[]> {
  try {
    // Check if agent has SMTP permissions
    const { data: permissions } = await this.supabaseClient
      .from('agent_smtp_permissions')
      .select(`
        *,
        smtp_configurations!inner(
          id,
          connection_name,
          is_active
        )
      `)
      .eq('agent_id', agentId)
      .eq('smtp_configurations.user_id', userId)
      .eq('smtp_configurations.is_active', true)
      .eq('is_active', true);

    if (!permissions || permissions.length === 0) {
      return [];
    }

    const availableTools: OpenAIFunction[] = [];

    // Add available SMTP tools based on permissions
    for (const permission of permissions) {
      for (const [toolName, toolDef] of Object.entries(SMTP_MCP_TOOLS)) {
        // Check if agent has permission for this tool
        const hasPermission = this.checkSMTPPermission(permission, toolName);
        
        if (hasPermission) {
          availableTools.push({
            name: toolDef.name,
            description: `${toolDef.description} (via ${permission.smtp_configurations.connection_name})`,
            parameters: toolDef.inputSchema
          });
        }
      }
    }

    return availableTools;
  } catch (error) {
    console.error('[FunctionCalling] Error getting SMTP tools:', error);
    return [];
  }
}

private checkSMTPPermission(permission: any, toolName: string): boolean {
  switch (toolName) {
    case 'send_email':
      return permission.can_send_email === true;
    case 'test_connection':
      return true; // All agents can test their connections
    default:
      return false;
  }
}
```

### 3. SMTP Function Execution

Add SMTP execution routing and method:

```typescript
// In executeFunction() method - add SMTP routing
async executeFunction(
  agentId: string,
  userId: string,
  functionName: string,
  parameters: Record<string, any>
): Promise<MCPToolResult> {
  const startTime = Date.now();
  
  try {
    // ... existing routing ...
    
    if (Object.keys(SMTP_MCP_TOOLS).includes(functionName)) {
      return await this.executeSMTPTool(agentId, userId, functionName, parameters);
    }
    
    // ... rest of routing ...
  } catch (error) {
    // ... error handling ...
  }
}

// SMTP tool execution method
private async executeSMTPTool(
  agentId: string,
  userId: string,
  toolName: string,
  parameters: Record<string, any>
): Promise<MCPToolResult> {
  const start = Date.now();
  
  try {
    // Validate SMTP configuration access
    const { data: permission, error: permError } = await this.supabaseClient
      .from('agent_smtp_permissions')
      .select(`
        *,
        smtp_configurations!inner(
          id,
          connection_name,
          is_active,
          user_id
        )
      `)
      .eq('agent_id', agentId)
      .eq('smtp_config_id', parameters.smtp_config_id)
      .eq('smtp_configurations.user_id', userId)
      .eq('smtp_configurations.is_active', true)
      .eq('is_active', true)
      .single();

    if (permError || !permission) {
      return {
        success: false,
        error: 'SMTP configuration not found or access denied',
        metadata: { execution_time_ms: Date.now() - start }
      };
    }

    // Check specific tool permission
    if (toolName === 'send_email' && !permission.can_send_email) {
      return {
        success: false,
        error: 'Agent does not have permission to send emails',
        metadata: { execution_time_ms: Date.now() - start }
      };
    }

    // Call the SMTP Edge Function
    const { data, error } = await this.supabaseClient.functions.invoke('smtp-api', {
      body: {
        action: toolName,
        agent_id: agentId,
        user_id: userId,
        params: parameters
      },
      headers: { 'Authorization': `Bearer ${this.authToken}` }
    });

    if (error) {
      throw new Error(error.message);
    }

    if (data && !data.success && data.error) {
      throw new Error(data.error);
    }

    return {
      success: true,
      data: data?.data || data,
      metadata: { execution_time_ms: Date.now() - start }
    };

  } catch (err: any) {
    return {
      success: false,
      error: err?.message || 'SMTP tool execution failed',
      metadata: { execution_time_ms: Date.now() - start }
    };
  }
}
```

### 4. Message Processing Integration

The message processing system in `processor/handlers.ts` automatically handles tool execution through the `FunctionCallingManager`. No changes are needed there - the SMTP tools will be automatically available once integrated into the `FunctionCallingManager`.

### 5. Tool Result Formatting

The `formatFunctionResult()` method handles tool result formatting:

```typescript
// In FunctionCallingManager class
formatFunctionResult(result: MCPToolResult, functionName: string): string {
  if (result.success) {
    switch (functionName) {
      case 'send_email':
        return `Email sent successfully. Message ID: ${result.data?.messageId || 'N/A'}`;
      case 'test_connection':
        return `SMTP connection test ${result.data?.success ? 'passed' : 'failed'}. ${result.data?.message || ''}`;
      default:
        return `Tool ${functionName} executed successfully: ${JSON.stringify(result.data)}`;
    }
  } else {
    return `Tool ${functionName} failed: ${result.error}`;
  }
}
```

## Integration Checklist

### Required Changes to FunctionCallingManager

1. **Import SMTP tools**: `import { SMTP_MCP_TOOLS } from './smtp-tools.ts';`
2. **Add getSMTPTools() method**: Query agent SMTP permissions and return available tools
3. **Add SMTP routing**: Add SMTP check in `executeFunction()` method
4. **Add executeSMTPTool() method**: Handle SMTP tool execution via Edge Function
5. **Update formatFunctionResult()**: Add SMTP-specific result formatting

### Database Integration Requirements

1. **Permission queries**: Query `agent_smtp_permissions` and `smtp_configurations` tables
2. **Access validation**: Ensure agent has permission for specific SMTP configurations
3. **Error handling**: Proper error messages for permission and configuration issues

### Edge Function Integration

1. **SMTP API endpoint**: Create `supabase/functions/smtp-api/index.ts`
2. **Authentication**: Forward auth token to Edge Function
3. **Parameter passing**: Pass action, agent_id, user_id, and params
4. **Response handling**: Handle success/error responses consistently

### Tool Schema Consistency

1. **OpenAI format**: Convert MCP tool definitions to OpenAI function format
2. **Parameter validation**: Ensure required parameters are enforced
3. **Description clarity**: Provide clear, actionable tool descriptions
4. **Scope requirements**: Define required permissions for each tool

This integration pattern ensures SMTP tools follow the same architecture as existing integrations, providing consistency, maintainability, and security.
