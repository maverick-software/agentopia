# Edge Function Architecture Design

**Date:** September 10, 2025  
**Research Item:** WBS 2.1 - Edge Function Architecture Design  
**Purpose:** Design modular Edge Function file structure following 200-300 line limits and existing patterns  

## Modular File Structure Design

### Overview
Based on analysis of Gmail API integration (918 lines single file) and user requirements for 200-300 line file limits, the Microsoft Outlook Edge Function will be split into focused modules:

```
supabase/functions/microsoft-outlook-api/
├── index.ts                    (Main handler - 250 lines)
├── email-operations.ts         (Email functions - 200 lines)
├── calendar-operations.ts      (Calendar functions - 200 lines)
├── contact-operations.ts       (Contact functions - 150 lines)
├── graph-client.ts            (Graph API client - 200 lines)
└── utils.ts                   (Helper functions - 150 lines)
```

### File Responsibilities

#### 1. index.ts (Main Handler - 250 lines)
**Purpose:** Main entry point, request routing, and response formatting
**Responsibilities:**
- HTTP request handling and CORS
- Request parsing and validation
- Action routing to appropriate modules
- Response formatting and error handling
- Authentication context setup
- Request/response logging

**Structure:**
```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { handleEmailOperation } from './email-operations.ts'
import { handleCalendarOperation } from './calendar-operations.ts'
import { handleContactOperation } from './contact-operations.ts'
import { createGraphClient } from './graph-client.ts'
import { validateRequest, formatResponse, enhanceErrorForLLM } from './utils.ts'

interface OutlookAPIRequest {
  agent_id: string;
  action: string;
  params: Record<string, any>;
  user_id: string;
}

serve(async (req) => {
  // CORS handling
  // Request parsing and validation
  // Authentication setup
  // Action routing switch statement
  // Error handling and response formatting
});
```

#### 2. email-operations.ts (Email Functions - 200 lines)
**Purpose:** Microsoft Graph email operations
**Responsibilities:**
- Send email functionality
- Read/list emails functionality  
- Search emails functionality
- Email-specific error handling
- Email parameter validation

**Functions:**
```typescript
export async function handleEmailOperation(
  action: string,
  params: any,
  graphClient: any,
  context: any
): Promise<any> {
  switch (action) {
    case 'send_email':
      return await sendEmail(params, graphClient, context);
    case 'get_emails':
      return await getEmails(params, graphClient, context);
    case 'search_emails':
      return await searchEmails(params, graphClient, context);
    default:
      throw new Error(`Unknown email action: ${action}`);
  }
}

async function sendEmail(params: any, graphClient: any, context: any): Promise<any>
async function getEmails(params: any, graphClient: any, context: any): Promise<any>
async function searchEmails(params: any, graphClient: any, context: any): Promise<any>
```

#### 3. calendar-operations.ts (Calendar Functions - 200 lines)
**Purpose:** Microsoft Graph calendar operations
**Responsibilities:**
- Create calendar events
- Read/list calendar events
- Calendar-specific error handling
- Date/time validation and timezone handling

**Functions:**
```typescript
export async function handleCalendarOperation(
  action: string,
  params: any,
  graphClient: any,
  context: any
): Promise<any> {
  switch (action) {
    case 'create_calendar_event':
      return await createCalendarEvent(params, graphClient, context);
    case 'get_calendar_events':
      return await getCalendarEvents(params, graphClient, context);
    default:
      throw new Error(`Unknown calendar action: ${action}`);
  }
}

async function createCalendarEvent(params: any, graphClient: any, context: any): Promise<any>
async function getCalendarEvents(params: any, graphClient: any, context: any): Promise<any>
```

#### 4. contact-operations.ts (Contact Functions - 150 lines)
**Purpose:** Microsoft Graph contacts operations
**Responsibilities:**
- Get/list contacts functionality
- Contact search functionality
- Contact-specific error handling
- Contact data validation

**Functions:**
```typescript
export async function handleContactOperation(
  action: string,
  params: any,
  graphClient: any,
  context: any
): Promise<any> {
  switch (action) {
    case 'get_contacts':
      return await getContacts(params, graphClient, context);
    case 'search_contacts':
      return await searchContacts(params, graphClient, context);
    default:
      throw new Error(`Unknown contact action: ${action}`);
  }
}

async function getContacts(params: any, graphClient: any, context: any): Promise<any>
async function searchContacts(params: any, graphClient: any, context: any): Promise<any>
```

#### 5. graph-client.ts (Graph API Client - 200 lines)
**Purpose:** Microsoft Graph API client and authentication
**Responsibilities:**
- Graph API HTTP client setup
- Token management and refresh
- Rate limiting and retry logic
- API request/response handling
- Authentication error handling

**Functions:**
```typescript
export interface GraphClientContext {
  accessToken: string;
  refreshToken?: string;
  userId: string;
  agentId: string;
  supabaseClient: any;
}

export async function createGraphClient(context: GraphClientContext): Promise<GraphClient>

export class GraphClient {
  private accessToken: string;
  private baseUrl = 'https://graph.microsoft.com/v1.0';
  
  constructor(accessToken: string) {
    this.accessToken = accessToken;
  }
  
  async get(endpoint: string, params?: any): Promise<any>
  async post(endpoint: string, data: any): Promise<any>
  async patch(endpoint: string, data: any): Promise<any>
  async delete(endpoint: string): Promise<any>
  
  private async makeRequest(method: string, endpoint: string, data?: any): Promise<any>
  private async handleRateLimit(response: Response): Promise<void>
  private async refreshTokenIfNeeded(error: any): Promise<void>
}
```

#### 6. utils.ts (Helper Functions - 150 lines)
**Purpose:** Shared utility functions
**Responsibilities:**
- Request validation functions
- Response formatting functions
- Error message transformation
- Date/time utilities
- Email/phone validation

**Functions:**
```typescript
export function validateRequest(request: any): { valid: boolean; errors: string[] }
export function formatResponse(data: any, success: boolean = true): any
export function enhanceErrorForLLM(error: any, action: string): string
export function validateEmailAddress(email: string): boolean
export function validatePhoneNumber(phone: string): boolean
export function formatDateTime(dateTime: string, timezone?: string): string
export function getRequiredScopes(action: string): string[]
```

## Action Routing Design

### Action Mapping
Following the Universal Tool Executor pattern:
```typescript
const ACTION_ROUTING = {
  // Email actions
  'send_email': { module: 'email', handler: 'handleEmailOperation' },
  'get_emails': { module: 'email', handler: 'handleEmailOperation' },
  'search_emails': { module: 'email', handler: 'handleEmailOperation' },
  
  // Calendar actions
  'create_calendar_event': { module: 'calendar', handler: 'handleCalendarOperation' },
  'get_calendar_events': { module: 'calendar', handler: 'handleCalendarOperation' },
  
  // Contact actions
  'get_contacts': { module: 'contact', handler: 'handleContactOperation' },
  'search_contacts': { module: 'contact', handler: 'handleContactOperation' }
};
```

### Main Handler Logic
```typescript
async function routeAction(action: string, params: any, graphClient: any, context: any): Promise<any> {
  const routing = ACTION_ROUTING[action];
  if (!routing) {
    throw new Error(`Question: I don't know how to perform the action '${action}'. Available actions are: send_email, get_emails, create_calendar_event, get_calendar_events, get_contacts.`);
  }
  
  switch (routing.module) {
    case 'email':
      return await handleEmailOperation(action, params, graphClient, context);
    case 'calendar':
      return await handleCalendarOperation(action, params, graphClient, context);
    case 'contact':
      return await handleContactOperation(action, params, graphClient, context);
    default:
      throw new Error(`Unknown module: ${routing.module}`);
  }
}
```

## Authentication Architecture

### Token Management Flow
Following Gmail API pattern but adapted for Microsoft Graph:
```typescript
async function setupAuthentication(userId: string, agentId: string): Promise<GraphClientContext> {
  // 1. Get service provider ID for microsoft-outlook
  const { data: provider } = await supabaseServiceRole
    .from('service_providers')
    .select('id')
    .eq('name', 'microsoft-outlook')
    .single();
    
  // 2. Get user's OAuth connection
  const { data: connection } = await supabaseServiceRole
    .from('user_integration_credentials')
    .select('*')
    .eq('user_id', userId)
    .eq('oauth_provider_id', provider.id)
    .eq('connection_status', 'active')
    .single();
    
  // 3. Decrypt access token from vault
  const { data: accessToken } = await supabaseServiceRole.rpc('vault_decrypt', {
    vault_id: connection.vault_access_token_id
  });
  
  // 4. Decrypt refresh token if available
  const { data: refreshToken } = connection.vault_refresh_token_id 
    ? await supabaseServiceRole.rpc('vault_decrypt', {
        vault_id: connection.vault_refresh_token_id
      })
    : { data: null };
    
  return {
    accessToken,
    refreshToken,
    userId,
    agentId,
    supabaseClient: supabaseServiceRole
  };
}
```

### Permission Validation
Following Gmail pattern:
```typescript
async function validatePermissions(agentId: string, userId: string, requiredScopes: string[]): Promise<boolean> {
  const { data: hasPermissions } = await supabaseServiceRole.rpc(
    'validate_agent_outlook_permissions',
    {
      p_agent_id: agentId,
      p_user_id: userId,
      p_required_scopes: requiredScopes
    }
  );
  
  return hasPermissions;
}
```

## Error Handling Architecture

### Error Enhancement Strategy
Transform Microsoft Graph errors to LLM-friendly questions:
```typescript
function enhanceErrorForLLM(error: any, action: string): string {
  const errorCode = error.response?.data?.error?.code;
  const errorMessage = error.response?.data?.error?.message;
  
  // Authentication errors
  if (errorCode === 'InvalidAuthenticationToken' || errorCode === 'TokenExpired') {
    return "Question: Your Outlook connection has expired. Please reconnect your Outlook account in the integrations settings and try again.";
  }
  
  // Permission errors
  if (errorCode === 'Forbidden') {
    return "Question: I don't have permission to perform this action. Please check that you've granted the necessary permissions for Outlook integration.";
  }
  
  // Not found errors
  if (errorCode === 'ItemNotFound') {
    if (action.includes('email')) {
      return "Question: I couldn't find that email. Could you provide more specific details like the subject line, sender, or date?";
    }
    if (action.includes('event')) {
      return "Question: I couldn't find that calendar event. Could you provide the event title or date?";
    }
    if (action.includes('contact')) {
      return "Question: I couldn't find that contact. Could you provide the contact's name or email address?";
    }
    return "Question: I couldn't find that item. Could you provide more specific details?";
  }
  
  // Rate limiting
  if (errorCode === 'TooManyRequests') {
    return "Question: I'm making too many requests to Outlook right now. Please wait a moment and try again.";
  }
  
  // Default fallback
  return `Question: I encountered an issue with Outlook: ${errorMessage}. Could you try again or provide different information?`;
}
```

### Retry Logic Architecture
Implement exponential backoff following research:
```typescript
class RetryHandler {
  private maxRetries = 3;
  private baseDelayMs = 1000;
  private maxDelayMs = 30000;

  async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (attempt === this.maxRetries || !this.shouldRetry(error)) {
          throw this.enhanceError(lastError);
        }
        
        const delay = this.calculateDelay(attempt, error);
        await this.sleep(delay);
      }
    }
    
    throw lastError!;
  }
  
  private shouldRetry(error: any): boolean {
    const status = error.response?.status;
    return status === 429 || status === 503 || status === 504;
  }
  
  private calculateDelay(attempt: number, error: any): number {
    // Check for Retry-After header
    if (error.response?.headers?.['retry-after']) {
      return parseInt(error.response.headers['retry-after']) * 1000;
    }
    
    // Exponential backoff with jitter
    const exponentialDelay = this.baseDelayMs * Math.pow(2, attempt);
    const jitter = Math.random() * 0.1 * exponentialDelay;
    
    return Math.min(exponentialDelay + jitter, this.maxDelayMs);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  private enhanceError(error: any): Error {
    const enhancedMessage = enhanceErrorForLLM(error, 'unknown');
    return new Error(enhancedMessage);
  }
}
```

## Response Formatting Architecture

### Consistent Response Structure
Follow Gmail API response pattern:
```typescript
interface OutlookAPIResponse {
  success: boolean;
  data?: any;
  error?: string;
  metadata?: {
    action: string;
    agent_id: string;
    user_id: string;
    execution_time: number;
    api_calls: number;
  };
}

function formatResponse(data: any, action: string, context: any, success: boolean = true): OutlookAPIResponse {
  return {
    success,
    data: success ? data : undefined,
    error: success ? undefined : data,
    metadata: {
      action,
      agent_id: context.agentId,
      user_id: context.userId,
      execution_time: Date.now(),
      api_calls: 1
    }
  };
}
```

## Integration with Universal Tool Executor

### Tool Routing Configuration
Add to Universal Tool Executor following existing pattern:
```typescript
'outlook_': {
  edgeFunction: 'microsoft-outlook-api',
  actionMapping: (toolName: string) => {
    const actionMap: Record<string, string> = {
      'outlook_send_email': 'send_email',
      'outlook_read_emails': 'get_emails',
      'outlook_search_emails': 'search_emails',
      'outlook_create_event': 'create_calendar_event',
      'outlook_get_events': 'get_calendar_events',
      'outlook_get_contacts': 'get_contacts',
      'outlook_search_contacts': 'search_contacts'
    };
    return actionMap[toolName] || 'unknown_action';
  },
  parameterMapping: (params: Record<string, any>, context: any) => {
    return {
      action: this.actionMapping(context.toolName),
      agent_id: context.agentId,
      user_id: context.userId,
      params: params
    };
  }
}
```

## Development and Testing Strategy

### File Development Order
1. **utils.ts** - Foundation utilities and helpers
2. **graph-client.ts** - Core API client and authentication
3. **email-operations.ts** - Email functionality (most critical)
4. **calendar-operations.ts** - Calendar functionality
5. **contact-operations.ts** - Contact functionality
6. **index.ts** - Main handler tying everything together

### Testing Approach
- Unit test each module independently
- Integration test with actual Microsoft Graph API
- End-to-end test through Universal Tool Executor
- Test error scenarios and retry mechanisms

### Deployment Strategy
- Deploy incrementally, starting with basic email functionality
- Test each module before adding the next
- Monitor logs and performance metrics
- Gradual rollout to agents

## Alignment with Requirements

### 200-300 Line Limits
- **index.ts:** 250 lines (main handler)
- **email-operations.ts:** 200 lines (3-4 functions)
- **calendar-operations.ts:** 200 lines (2-3 functions)
- **contact-operations.ts:** 150 lines (2-3 functions)
- **graph-client.ts:** 200 lines (client class + utilities)
- **utils.ts:** 150 lines (helper functions)

### Existing Pattern Compliance
- Follows Gmail API authentication pattern
- Uses same error enhancement approach
- Maintains consistent response structure
- Integrates with Universal Tool Executor pattern
- Uses Supabase Vault for token storage

### Microsoft Graph API Alignment
- Handles Graph API specific payload structures
- Implements proper rate limiting for Graph API
- Supports Graph API error codes and messages
- Uses Graph API endpoint patterns

This modular architecture ensures maintainability, testability, and adherence to both user requirements and existing patterns while providing a solid foundation for the Microsoft Outlook integration.
