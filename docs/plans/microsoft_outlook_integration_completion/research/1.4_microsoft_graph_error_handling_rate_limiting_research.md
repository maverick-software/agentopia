# Microsoft Graph API Error Handling and Rate Limiting Research

**Date:** September 10, 2025  
**Research Item:** WBS 1.1 - Microsoft Graph API Research - Error Handling and Rate Limiting  
**Purpose:** Research Microsoft Graph API error handling patterns, rate limiting, and best practices  

## Microsoft Graph API Rate Limiting

### Rate Limit Thresholds
- **General Limit:** 10,000 requests per 10 minutes per application per tenant
- **Mail API:** Additional limits based on mailbox size and tenant type
- **Calendar API:** 1,500 requests per 30 seconds per mailbox
- **Contacts API:** 800 requests per 30 seconds per mailbox
- **Batch Requests:** Up to 20 individual requests per batch

### Rate Limiting Headers
Microsoft Graph includes helpful headers in responses:

#### Request Tracking Headers
- **request-id:** Unique identifier for the request
- **client-request-id:** Client-provided request identifier
- **x-ms-ags-diagnostic:** Additional diagnostic information

#### Rate Limiting Headers
- **Retry-After:** Number of seconds to wait before retrying (present on 429 responses)
- **X-RateLimit-Limit:** Maximum number of requests allowed
- **X-RateLimit-Remaining:** Number of requests remaining in current window
- **X-RateLimit-Reset:** Time when the rate limit window resets (Unix timestamp)

### HTTP Status Codes for Rate Limiting
- **429 Too Many Requests:** Rate limit exceeded, must wait before retrying
- **503 Service Unavailable:** Service temporarily unavailable
- **504 Gateway Timeout:** Request timed out

## Error Response Format

### Standard Error Structure
```json
{
  "error": {
    "code": "ErrorCode",
    "message": "Human-readable error message",
    "innerError": {
      "date": "2025-09-10T10:30:00",
      "request-id": "12345678-1234-1234-1234-123456789012",
      "client-request-id": "87654321-4321-4321-4321-210987654321"
    }
  }
}
```

### Common Error Codes

#### Authentication Errors
- **InvalidAuthenticationToken:** Token is invalid or expired
- **Unauthenticated:** No authentication token provided
- **Forbidden:** Insufficient permissions for requested operation
- **TokenExpired:** Access token has expired

#### Request Errors
- **BadRequest:** Invalid request syntax or parameters
- **NotFound:** Requested resource doesn't exist
- **MethodNotAllowed:** HTTP method not supported for endpoint
- **UnsupportedMediaType:** Content-Type not supported

#### Service Errors
- **InternalServerError:** Microsoft Graph service error
- **ServiceUnavailable:** Service temporarily unavailable
- **TooManyRequests:** Rate limit exceeded
- **GatewayTimeout:** Request timeout

#### Resource-Specific Errors
- **ItemNotFound:** Specific item (email, event, contact) not found
- **ConflictingObject:** Resource conflicts with existing resource
- **InvalidRequest:** Request parameters are invalid
- **QuotaLimitExceeded:** User quota limit exceeded

## Retry Strategies

### Exponential Backoff Pattern
```typescript
class RetryHandler {
  private maxRetries = 3;
  private baseDelayMs = 1000;
  private maxDelayMs = 30000;

  async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (attempt === this.maxRetries) {
          throw lastError;
        }
        
        const delay = this.calculateDelay(attempt, error);
        await this.sleep(delay);
      }
    }
    
    throw lastError!;
  }
  
  private calculateDelay(attempt: number, error: any): number {
    // Check for Retry-After header
    if (error.response?.headers?.['retry-after']) {
      return parseInt(error.response.headers['retry-after']) * 1000;
    }
    
    // Exponential backoff with jitter
    const exponentialDelay = this.baseDelayMs * Math.pow(2, attempt);
    const jitter = Math.random() * 0.1 * exponentialDelay;
    
    return Math.min(exponentialDelay + jitter, this.maxDelayMs);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Retry Conditions
**Should Retry:**
- 429 (Too Many Requests)
- 503 (Service Unavailable)
- 504 (Gateway Timeout)
- Network timeouts
- Connection errors

**Should NOT Retry:**
- 400 (Bad Request)
- 401 (Unauthorized)
- 403 (Forbidden)
- 404 (Not Found)
- 422 (Unprocessable Entity)

## Error Handling Best Practices

### 1. Token Refresh Handling
```typescript
async function handleTokenRefresh(error: any, refreshToken: string): Promise<string> {
  if (error.response?.status === 401 && error.response?.data?.error?.code === 'InvalidAuthenticationToken') {
    try {
      // Refresh the access token
      const newToken = await refreshAccessToken(refreshToken);
      return newToken;
    } catch (refreshError) {
      // If refresh fails, user needs to re-authenticate
      throw new Error('Authentication required: Please reconnect your Outlook account');
    }
  }
  throw error;
}
```

### 2. Circuit Breaker Pattern
```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private readonly threshold = 5;
  private readonly timeout = 60000; // 1 minute
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.isOpen()) {
      throw new Error('Circuit breaker is open - service unavailable');
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private isOpen(): boolean {
    return this.failures >= this.threshold && 
           (Date.now() - this.lastFailureTime) < this.timeout;
  }
  
  private onSuccess(): void {
    this.failures = 0;
  }
  
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
  }
}
```

### 3. Request Deduplication
```typescript
class RequestDeduplicator {
  private pendingRequests = new Map<string, Promise<any>>();
  
  async deduplicate<T>(key: string, operation: () => Promise<T>): Promise<T> {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }
    
    const promise = operation().finally(() => {
      this.pendingRequests.delete(key);
    });
    
    this.pendingRequests.set(key, promise);
    return promise;
  }
}
```

## LLM-Friendly Error Messages

### Error Message Transformation
```typescript
function transformToLLMFriendlyError(error: any): string {
  const errorCode = error.response?.data?.error?.code;
  const errorMessage = error.response?.data?.error?.message;
  
  switch (errorCode) {
    case 'InvalidAuthenticationToken':
    case 'TokenExpired':
      return "Question: Your Outlook connection has expired. Please reconnect your Outlook account in the integrations settings and try again.";
    
    case 'Forbidden':
      return "Question: I don't have permission to perform this action. Please check that you've granted the necessary permissions for Outlook integration.";
    
    case 'ItemNotFound':
      return "Question: I couldn't find that item. Could you provide more specific details like the subject line, date, or contact name?";
    
    case 'TooManyRequests':
      return "Question: I'm making too many requests to Outlook right now. Please wait a moment and try again.";
    
    case 'ConflictingEvent':
      return "Question: This time slot conflicts with another event. Would you like me to suggest alternative times or create the event anyway?";
    
    case 'InvalidRequest':
      if (errorMessage.includes('email')) {
        return "Question: The email address format seems incorrect. Please provide a valid email address like 'name@example.com'.";
      }
      if (errorMessage.includes('date')) {
        return "Question: The date format is invalid. Please provide a date like 'September 15, 2025' or '2025-09-15'.";
      }
      return "Question: Some of the information provided is invalid. Could you please check and provide the correct details?";
    
    case 'QuotaLimitExceeded':
      return "Question: Your Outlook storage quota is full. Please free up some space in your mailbox and try again.";
    
    default:
      return `Question: I encountered an issue with Outlook: ${errorMessage}. Could you try again or provide different information?`;
  }
}
```

## Monitoring and Logging

### Request Logging
```typescript
interface APIRequest {
  requestId: string;
  method: string;
  endpoint: string;
  timestamp: Date;
  duration: number;
  statusCode: number;
  userId: string;
  agentId: string;
}

class APILogger {
  async logRequest(request: APIRequest): Promise<void> {
    console.log(`[Graph API] ${request.method} ${request.endpoint} - ${request.statusCode} (${request.duration}ms)`);
    
    // Store in database for analytics
    await this.storeRequestLog(request);
  }
  
  async logError(error: any, context: any): Promise<void> {
    console.error(`[Graph API Error] ${error.message}`, {
      requestId: context.requestId,
      endpoint: context.endpoint,
      userId: context.userId,
      agentId: context.agentId,
      error: error
    });
  }
}
```

### Performance Metrics
- **Request Duration:** Track API response times
- **Error Rates:** Monitor error frequency by endpoint
- **Rate Limit Usage:** Track rate limit consumption
- **Token Refresh Frequency:** Monitor authentication health

## Implementation Guidelines

### 1. Graceful Degradation
```typescript
async function sendEmailWithFallback(emailData: any): Promise<any> {
  try {
    return await sendEmailViaGraph(emailData);
  } catch (error) {
    if (isRetryableError(error)) {
      // Implement retry logic
      return await retryOperation(() => sendEmailViaGraph(emailData));
    }
    
    // For non-retryable errors, provide helpful guidance
    throw new Error(transformToLLMFriendlyError(error));
  }
}
```

### 2. Request Optimization
- **Use $select:** Request only needed properties
- **Batch Requests:** Combine multiple operations
- **Delta Queries:** Use delta queries for incremental sync
- **Caching:** Cache frequently accessed data

### 3. Security Considerations
- **Token Security:** Store tokens securely in Supabase Vault
- **Request Validation:** Validate all input parameters
- **Rate Limiting:** Implement client-side rate limiting
- **Audit Logging:** Log all API interactions for security

## Integration with Existing Patterns

### Alignment with Agentopia Error Handling
- Follow existing LLM-friendly error message patterns
- Use consistent retry mechanisms across integrations
- Maintain error logging standards
- Integrate with existing monitoring systems

### Tool Execution Error Handling
```typescript
// Example integration with Universal Tool Executor
async function executeOutlookTool(toolName: string, parameters: any): Promise<any> {
  try {
    const result = await callMicrosoftGraphAPI(toolName, parameters);
    return {
      success: true,
      data: result,
      metadata: {
        toolName,
        executionTime: Date.now(),
        apiCalls: 1
      }
    };
  } catch (error) {
    return {
      success: false,
      error: transformToLLMFriendlyError(error),
      metadata: {
        toolName,
        executionTime: Date.now(),
        errorCode: error.response?.data?.error?.code
      }
    };
  }
}
```

## Next Steps for Implementation
1. Implement retry handler with exponential backoff
2. Create LLM-friendly error message transformer
3. Add comprehensive request logging
4. Implement circuit breaker for service protection
5. Test error scenarios thoroughly
6. Monitor rate limit usage in production
