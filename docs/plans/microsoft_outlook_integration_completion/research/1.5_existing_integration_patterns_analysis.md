# Existing Integration Patterns Analysis

**Date:** September 10, 2025  
**Research Item:** WBS 1.2 - Existing Integration Pattern Analysis  
**Purpose:** Analyze Gmail API and SMTP integration patterns for reference in Microsoft Outlook implementation  

## Gmail API Integration Pattern Analysis

### File Structure
```
supabase/functions/gmail-api/
├── index.ts (main handler - 918 lines)
```

### Request/Response Pattern
```typescript
interface GmailAPIRequest {
  agent_id: string;
  action: string;
  parameters: Record<string, any>;
}

interface EmailMessage {
  to: string;
  subject: string;
  body: string;
  html?: string;
  attachments?: Array<{
    filename: string;
    content: string;
    contentType: string;
  }>;
}
```

### Action Handling Pattern
Gmail API uses a switch statement to handle different actions:
- `send_email` - Send emails via Gmail API
- `list_messages` - Read emails from Gmail
- `search_messages` - Search emails by query
- `modify_message` - Mark as read/unread, archive, etc.

### Authentication Pattern
1. **Service Role Client:** Uses `SUPABASE_SERVICE_ROLE_KEY` for vault access
2. **Permission Validation:** Calls `validate_agent_gmail_permissions` RPC function
3. **Token Retrieval:** Uses `vault_decrypt` to get OAuth tokens
4. **Token Refresh:** Automatic token refresh when expired

```typescript
// Permission validation
const { data: hasPermissions, error: permissionError } = await supabaseServiceRole.rpc(
  'validate_agent_gmail_permissions',
  {
    p_agent_id: agent_id,
    p_user_id: user_id,
    p_required_scopes: requiredScopes
  }
);

// Token retrieval
const { data: accessToken } = await supabaseServiceRole.rpc('vault_decrypt', {
  vault_id: connection.vault_access_token_id
});
```

### Error Handling Pattern
Gmail API implements LLM-friendly error messages:
```typescript
// Interactive error messages for retry mechanism
if (!action) {
  throw new Error('Question: What email action would you like me to perform? Please specify send_email, read_emails, or search_emails.');
}
if (!params.to) {
  throw new Error('Question: Who should I send this email to? Please provide the recipient email address.');
}
```

### API Client Pattern
Gmail uses Google APIs client library:
```typescript
const gmail = google.gmail({ version: 'v1', auth: oauth2Client });
const result = await gmail.users.messages.send({
  userId: 'me',
  requestBody: {
    raw: base64EncodedEmail
  }
});
```

## Universal Tool Executor Pattern Analysis

### File Location
`supabase/functions/chat/function_calling/universal-tool-executor.ts`

### Routing Configuration
Uses a mapping object to route tools to appropriate edge functions:
```typescript
const TOOL_ROUTING_MAP: Record<string, {
  edgeFunction: string;
  actionMapping: (toolName: string) => string;
  parameterMapping?: (params: Record<string, any>, context?: any) => Record<string, any>;
}> = {
  'gmail_': {
    edgeFunction: 'gmail-api',
    actionMapping: (toolName: string) => {
      const actionMap: Record<string, string> = {
        'gmail_send_email': 'send_email',
        'gmail_read_emails': 'list_messages',
        'gmail_search_emails': 'search_messages',
        'gmail_email_actions': 'modify_message'
      };
      return actionMap[toolName] || 'unknown_action';
    },
    parameterMapping: (params: Record<string, any>) => ({
      params: params  // Gmail API expects "params" not "parameters"
    })
  }
}
```

### Tool Execution Flow
1. **Find Routing Config:** Match tool name prefix to routing configuration
2. **Map Action:** Convert tool name to edge function action
3. **Transform Parameters:** Apply parameter mapping if defined
4. **Call Edge Function:** Invoke Supabase function with transformed parameters
5. **Handle Response:** Process result and format for agent consumption

### Error Enhancement Pattern
Universal Tool Executor enhances technical errors to be LLM-friendly:
```typescript
function enhanceErrorForLLM(error: string, toolName: string): string {
  // Convert technical errors to interactive questions
  if (error.includes('Missing required parameter')) {
    return `Question: I need more information to use ${toolName}. What specific details should I include?`;
  }
  // ... more error transformations
}
```

## SMTP Integration Pattern Analysis

### Routing Configuration
SMTP follows the same pattern as Gmail:
```typescript
'smtp_': {
  edgeFunction: 'smtp-api',
  actionMapping: (toolName: string) => {
    const actionMap: Record<string, string> = {
      'smtp_send_email': 'send_email',
      'smtp_email_templates': 'email_templates',
      'smtp_email_stats': 'email_stats'
    };
    return actionMap[toolName] || 'send_email';
  },
  parameterMapping: (params: Record<string, any>, context: any) => {
    return {
      action: actionMap[context.toolName] || 'send_email',
      agent_id: context.agentId,
      user_id: context.userId, 
      params: params
    };
  }
}
```

## Integration Capabilities Database Pattern

### Table Structure
Based on analysis of existing integrations, capabilities are stored in `integration_capabilities`:
```sql
integration_capabilities: {
  integration_id: uuid,           -- Links to service_providers table
  capability_key: text,           -- Specific tool name (e.g., 'gmail_send_email')
  display_label: text,            -- Human-readable label (e.g., 'Send Email')
  display_order: integer,         -- Sort order for UI display
  created_at: timestamptz,
  updated_at: timestamptz
}
```

### Example Entries
```sql
-- Gmail capabilities
INSERT INTO integration_capabilities (integration_id, capability_key, display_label, display_order)
SELECT id, 'gmail_send_email', 'Send Email', 1 FROM service_providers WHERE name = 'gmail';

INSERT INTO integration_capabilities (integration_id, capability_key, display_label, display_order)
SELECT id, 'gmail_read_emails', 'Read Emails', 2 FROM service_providers WHERE name = 'gmail';
```

## Service Provider Configuration Pattern

### Database Entry Structure
Service providers are configured in the `service_providers` table:
```sql
service_providers: {
  name: text,                     -- Unique identifier (e.g., 'gmail', 'microsoft-outlook')
  display_name: text,             -- UI display name
  authorization_endpoint: text,   -- OAuth authorization URL
  token_endpoint: text,           -- OAuth token exchange URL
  scopes_supported: jsonb,        -- Array of supported OAuth scopes
  configuration_metadata: jsonb   -- Provider-specific configuration
}
```

### Microsoft Outlook Configuration
Already exists in database:
```sql
name: 'microsoft-outlook'
display_name: 'Microsoft Outlook'
authorization_endpoint: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize'
token_endpoint: 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
scopes_supported: [
  'https://graph.microsoft.com/Mail.Read',
  'https://graph.microsoft.com/Mail.ReadWrite',
  'https://graph.microsoft.com/Mail.Send',
  'https://graph.microsoft.com/Calendars.Read',
  'https://graph.microsoft.com/Calendars.ReadWrite',
  'https://graph.microsoft.com/Contacts.Read',
  'https://graph.microsoft.com/Contacts.ReadWrite',
  'https://graph.microsoft.com/User.Read'
]
```

## Agent Permission System Pattern

### Permission Storage
Agent permissions are stored in `agent_integration_permissions`:
```sql
agent_integration_permissions: {
  agent_id: uuid,                 -- Reference to agents table
  user_oauth_connection_id: uuid, -- Reference to user_integration_credentials
  allowed_scopes: jsonb,          -- Array of granted scopes
  permission_level: text,         -- Permission granularity
  is_active: boolean              -- Permission status
}
```

### Permission Validation
Each integration has an RPC function for permission validation:
```sql
-- Gmail example
CREATE OR REPLACE FUNCTION validate_agent_gmail_permissions(
  p_agent_id UUID,
  p_user_id UUID,
  p_required_scopes TEXT[]
) RETURNS BOOLEAN;

-- Need similar function for Outlook
CREATE OR REPLACE FUNCTION validate_agent_outlook_permissions(
  p_agent_id UUID,
  p_user_id UUID,
  p_required_scopes TEXT[]
) RETURNS BOOLEAN;
```

## Key Patterns for Microsoft Outlook Implementation

### 1. File Structure Pattern
Follow Gmail pattern but modularize for 200-300 line files:
```
supabase/functions/microsoft-outlook-api/
├── index.ts (main handler - 250 lines)
├── email-operations.ts (email functions - 200 lines)
├── calendar-operations.ts (calendar functions - 200 lines)
├── contact-operations.ts (contact functions - 150 lines)
├── graph-client.ts (Graph API client - 200 lines)
└── utils.ts (helper functions - 150 lines)
```

### 2. Tool Routing Pattern
Add to Universal Tool Executor:
```typescript
'outlook_': {
  edgeFunction: 'microsoft-outlook-api',
  actionMapping: (toolName: string) => {
    const actionMap: Record<string, string> = {
      'outlook_send_email': 'send_email',
      'outlook_read_emails': 'get_emails',
      'outlook_create_event': 'create_calendar_event',
      'outlook_get_events': 'get_calendar_events',
      'outlook_get_contacts': 'get_contacts'
    };
    return actionMap[toolName] || 'unknown_action';
  },
  parameterMapping: (params: Record<string, any>, context: any) => {
    return {
      action: actionMap[context.toolName],
      agent_id: context.agentId,
      user_id: context.userId,
      params: params
    };
  }
}
```

### 3. Integration Capabilities Pattern
Create database entries:
```sql
-- Email capabilities
INSERT INTO integration_capabilities (integration_id, capability_key, display_label, display_order)
SELECT id, 'outlook_send_email', 'Send Email', 1 FROM service_providers WHERE name = 'microsoft-outlook';

INSERT INTO integration_capabilities (integration_id, capability_key, display_label, display_order)
SELECT id, 'outlook_read_emails', 'Read Emails', 2 FROM service_providers WHERE name = 'microsoft-outlook';

-- Calendar capabilities
INSERT INTO integration_capabilities (integration_id, capability_key, display_label, display_order)
SELECT id, 'outlook_create_event', 'Create Calendar Event', 3 FROM service_providers WHERE name = 'microsoft-outlook';

-- Contact capabilities
INSERT INTO integration_capabilities (integration_id, capability_key, display_label, display_order)
SELECT id, 'outlook_get_contacts', 'Get Contacts', 4 FROM service_providers WHERE name = 'microsoft-outlook';
```

### 4. Permission Validation Pattern
Create RPC function following Gmail pattern:
```sql
CREATE OR REPLACE FUNCTION validate_agent_outlook_permissions(
  p_agent_id UUID,
  p_user_id UUID,
  p_required_scopes TEXT[]
) RETURNS BOOLEAN AS $$
-- Implementation similar to Gmail validation
$$;
```

### 5. Error Handling Pattern
Follow Gmail's LLM-friendly error message pattern:
```typescript
// Transform Microsoft Graph errors to questions
if (error.code === 'InvalidAuthenticationToken') {
  return "Question: Your Outlook connection has expired. Please reconnect your Outlook account and try again.";
}
if (error.code === 'ItemNotFound') {
  return "Question: I couldn't find that item. Could you provide more specific details?";
}
```

### 6. Authentication Pattern
Follow Gmail's vault-based token management:
```typescript
// Get connection details
const { data: connection } = await supabaseServiceRole
  .from('user_integration_credentials')
  .select('*')
  .eq('user_id', user_id)
  .eq('oauth_provider_id', outlookProviderId)
  .eq('connection_status', 'active')
  .single();

// Decrypt access token
const { data: accessToken } = await supabaseServiceRole.rpc('vault_decrypt', {
  vault_id: connection.vault_access_token_id
});
```

## Alignment with Existing Patterns

### Consistency Requirements
1. **Tool Naming:** Use `outlook_` prefix for all tools
2. **Parameter Structure:** Follow existing parameter mapping patterns
3. **Error Messages:** Use LLM-friendly question format
4. **Response Format:** Return consistent success/error structure
5. **Authentication:** Use Supabase Vault for token storage
6. **Permissions:** Follow agent permission validation pattern

### Differences from Gmail
1. **API Structure:** Microsoft Graph uses different endpoint structure
2. **Payload Format:** Graph API uses nested object structure
3. **Multi-Service:** Graph API covers email, calendar, contacts in one API
4. **Rate Limiting:** Different rate limits and headers
5. **Token Management:** Same OAuth flow but different endpoints

## Next Steps for Implementation
1. Create modular file structure following 200-300 line limit
2. Implement Microsoft Graph API client utilities
3. Add Outlook routing to Universal Tool Executor
4. Create integration capabilities database entries
5. Implement permission validation RPC function
6. Follow LLM-friendly error message patterns
7. Test integration with existing agent system
