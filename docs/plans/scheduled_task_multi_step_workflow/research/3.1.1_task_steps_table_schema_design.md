# Task 3.1.1: Create task_steps Table Schema Design

## Research Date: August 29, 2025

## Task Overview
Design and create the `task_steps` table schema with all required fields, foreign key relationships, and performance indexes to support multi-step workflow functionality.

## Database Migration Pattern Analysis

### Existing Pattern from team_canvas_tables.sql
- Uses `BEGIN;` and `COMMIT;` for transaction safety
- Creates custom ENUMs when needed
- Implements comprehensive foreign key constraints with CASCADE options
- Includes performance indexes (B-tree and GIN for JSONB)
- Enables Row Level Security (RLS) with detailed policies
- Uses `gen_random_uuid()` for primary keys
- Includes update triggers for `updated_at` timestamps
- Adds table and column comments for documentation
- Grants appropriate permissions to roles

### Required Schema Elements for task_steps

#### 1. Core Table Structure
```sql
CREATE TABLE task_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID NOT NULL REFERENCES agent_tasks(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    step_name TEXT NOT NULL,
    instructions TEXT NOT NULL,
    include_previous_context BOOLEAN NOT NULL DEFAULT false,
    context_data JSONB DEFAULT '{}'::jsonb,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed', 'skipped')),
    execution_result JSONB DEFAULT '{}'::jsonb,
    execution_started_at TIMESTAMPTZ,
    execution_completed_at TIMESTAMPTZ,
    error_message TEXT,
    retry_count INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT task_steps_step_order_positive CHECK (step_order > 0),
    CONSTRAINT task_steps_retry_count_non_negative CHECK (retry_count >= 0),
    CONSTRAINT unique_task_step_order UNIQUE (task_id, step_order)
);
```

#### 2. Performance Indexes
```sql
-- Primary access patterns
CREATE INDEX idx_task_steps_task_id ON task_steps(task_id);
CREATE INDEX idx_task_steps_task_order ON task_steps(task_id, step_order);
CREATE INDEX idx_task_steps_status ON task_steps(status);

-- Execution queries
CREATE INDEX idx_task_steps_execution_time ON task_steps(execution_started_at, execution_completed_at);
CREATE INDEX idx_task_steps_pending ON task_steps(task_id, step_order) WHERE status = 'pending';

-- JSONB indexes for context and results
CREATE INDEX idx_task_steps_context_gin ON task_steps USING GIN (context_data);
CREATE INDEX idx_task_steps_result_gin ON task_steps USING GIN (execution_result);
```

#### 3. RLS Security Policies
```sql
-- Enable RLS
ALTER TABLE task_steps ENABLE ROW LEVEL SECURITY;

-- Users can access steps for their own agent tasks
CREATE POLICY task_steps_user_access ON task_steps
    FOR ALL TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM agent_tasks at
            WHERE at.id = task_id
            AND at.user_id = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM agent_tasks at
            WHERE at.id = task_id
            AND at.user_id = auth.uid()
        )
    );

-- Service role full access
CREATE POLICY task_steps_service_access ON task_steps
    FOR ALL TO service_role
    USING (true)
    WITH CHECK (true);
```

#### 4. Update Triggers
```sql
CREATE OR REPLACE FUNCTION update_task_steps_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER task_steps_updated_at_trigger
    BEFORE UPDATE ON task_steps
    FOR EACH ROW
    EXECUTE FUNCTION update_task_steps_updated_at();
```

## Field Design Rationale

### Core Fields
- **`id`**: UUID primary key following Agentopia patterns
- **`task_id`**: Foreign key to `agent_tasks` with CASCADE delete
- **`step_order`**: Integer ordering (1, 2, 3...) with positive constraint
- **`step_name`**: User-friendly step identifier
- **`instructions`**: Step-specific agent instructions

### Context Management
- **`include_previous_context`**: Boolean toggle for context passing
- **`context_data`**: JSONB for flexible context storage from previous steps

### Execution Tracking
- **`status`**: Enum-like constraint for step execution state
- **`execution_result`**: JSONB for flexible result storage
- **`execution_started_at`/`execution_completed_at`**: Timing metrics
- **`error_message`**: Human-readable error information
- **`retry_count`**: Track retry attempts for failed steps

### Constraints and Validation
- **Unique constraint**: (task_id, step_order) prevents duplicate ordering
- **Check constraints**: Positive step_order, non-negative retry_count
- **Status validation**: Ensures valid status values

## Migration Strategy

### Existing Task Compatibility
```sql
-- Migrate existing single-instruction tasks to step-based model
INSERT INTO task_steps (task_id, step_order, step_name, instructions, include_previous_context)
SELECT 
    id as task_id,
    1 as step_order,
    COALESCE(name, 'Task Step') as step_name,
    instructions,
    false as include_previous_context
FROM agent_tasks
WHERE NOT EXISTS (
    SELECT 1 FROM task_steps ts WHERE ts.task_id = agent_tasks.id
);
```

### Rollback Plan
```sql
-- If migration fails, we can rollback by:
-- 1. Dropping the task_steps table
-- 2. Existing agent_tasks table remains unchanged
-- 3. No data loss for existing functionality
```

## Performance Considerations

### Query Patterns
1. **Get all steps for a task**: `SELECT * FROM task_steps WHERE task_id = ? ORDER BY step_order`
2. **Get next pending step**: `SELECT * FROM task_steps WHERE task_id = ? AND status = 'pending' ORDER BY step_order LIMIT 1`
3. **Update step status**: `UPDATE task_steps SET status = ?, execution_result = ? WHERE id = ?`
4. **Context retrieval**: `SELECT execution_result FROM task_steps WHERE task_id = ? AND step_order = ?`

### Index Optimization
- Composite index on (task_id, step_order) for ordered retrieval
- Partial index on pending status for execution queries
- GIN indexes on JSONB fields for context/result queries

## Security Requirements

### Row Level Security
- Users can only access steps for tasks they own
- Service role has full access for system operations
- No cross-user data leakage possible

### Data Validation
- Step order must be positive and unique per task
- Status values are constrained to valid states
- Foreign key ensures step belongs to valid task

## Integration Points

### Agent Tasks Table
- Foreign key relationship with CASCADE delete
- Maintains referential integrity
- Existing tasks continue to work

### Task Executor Function
- Queries steps in order by step_order
- Updates status and results during execution
- Handles context passing between steps

### Frontend Components
- CRUD operations via API endpoints
- Real-time status updates via subscriptions
- Drag-and-drop reordering updates step_order

## File Size Estimate
- Migration file: ~150 lines
- Includes table creation, indexes, RLS policies, triggers
- Follows established patterns from existing migrations
- Comprehensive but concise implementation

## Dependencies
- Requires `agent_tasks` table (exists)
- Requires `auth.users` table (exists)
- Uses standard PostgreSQL and Supabase features
- No external dependencies

## Testing Strategy
- Create test tasks with multiple steps
- Verify foreign key constraints
- Test RLS policies with different users
- Validate index performance with large datasets
- Test migration on copy of production data

## References
- `supabase/migrations/20250828_152225_create_team_canvas_tables.sql` - Pattern reference
- `supabase/functions/agent-tasks/index.ts` - Current task schema
- Agentopia database patterns and conventions
- PostgreSQL JSONB and indexing best practices
