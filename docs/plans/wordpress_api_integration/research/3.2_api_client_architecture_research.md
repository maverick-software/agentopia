# WordPress API Client Architecture Research

## Research Overview
This document analyzes the architecture for WordPress API client implementation, examining existing patterns in Agentopia and designing the WordPress-specific client structure.

## Existing API Client Patterns Analysis

### 1. Edge Function Pattern (Recommended for WordPress)

#### Gmail API Example Structure
From `supabase/functions/gmail-api/index.ts`:

```typescript
// Standard Edge Function structure
serve(async (req) => {
  // 1. CORS handling
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // 2. Request parsing and validation
    const requestBody = await req.json();
    const { action, params, agent_id, user_id } = requestBody;
    
    // 3. Authentication and permission validation
    const supabaseServiceRole = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
    const hasPermissions = await validateAgentPermissions(agent_id, user_id, action);
    
    // 4. Get credentials from vault
    const credentials = await getCredentialsFromVault(user_id, connectionId);
    
    // 5. Execute API operation
    const result = await executeGmailOperation(action, params, credentials);
    
    // 6. Return response
    return new Response(JSON.stringify(result), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    // 7. Error handling
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});
```

#### Key Patterns Identified
1. **Centralized Authentication**: Service role client for vault access
2. **Permission Validation**: Agent-specific permission checking
3. **Credential Management**: Secure vault credential retrieval
4. **Action Routing**: Switch-based action handling
5. **Error Handling**: Comprehensive error responses
6. **CORS Support**: Standard CORS headers

### 2. Direct API Client Pattern (Frontend Testing)

#### ClickSend Example
From `src/integrations/clicksend/components/ClickSendSetupModal.tsx`:

```typescript
// Direct API testing for connection validation
const handleTestConnection = async () => {
  try {
    const credentials = btoa(`${username.trim()}:${apiKey.trim()}`);
    const response = await fetch('https://rest.clicksend.com/v3/account', {
      method: 'GET',
      headers: {
        'Authorization': `Basic ${credentials}`,
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      const accountData = await response.json();
      // Handle success
    } else {
      // Handle error
    }
  } catch (error) {
    // Handle network error
  }
};
```

## WordPress API Client Architecture Design

### 1. Edge Function Structure (`supabase/functions/wordpress-api/index.ts`)

```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface WordPressAPIRequest {
  action: string;
  params: Record<string, any>;
  agent_id: string;
  user_id: string;
  connection_id: string;
}

interface WordPressCredentials {
  site_url: string;
  username: string;
  app_password: string;
  api_base_url: string;
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Parse and validate request
    const requestBody: WordPressAPIRequest = await req.json();
    const { action, params, agent_id, user_id, connection_id } = requestBody;

    // Validate required parameters
    if (!action || !agent_id || !user_id || !connection_id) {
      throw new Error('Missing required parameters');
    }

    // Create service role client
    const supabaseServiceRole = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Validate agent permissions
    const hasPermissions = await validateWordPressPermissions(
      supabaseServiceRole, 
      agent_id, 
      user_id, 
      action
    );

    if (!hasPermissions) {
      throw new Error('Agent does not have permission for this WordPress action');
    }

    // Get WordPress credentials from vault
    const credentials = await getWordPressCredentials(
      supabaseServiceRole, 
      user_id, 
      connection_id
    );

    // Execute WordPress API operation
    const result = await executeWordPressOperation(action, params, credentials);

    return new Response(JSON.stringify(result), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('WordPress API error:', error);
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error.message 
      }), 
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
```

### 2. WordPress API Client Class

```typescript
class WordPressAPIClient {
  private credentials: WordPressCredentials;
  private rateLimiter: WordPressRateLimiter;

  constructor(credentials: WordPressCredentials) {
    this.credentials = credentials;
    this.rateLimiter = new WordPressRateLimiter();
  }

  /**
   * Make authenticated request to WordPress REST API
   */
  private async makeRequest(
    endpoint: string, 
    method: string = 'GET', 
    body?: any
  ): Promise<any> {
    // Check rate limiting
    if (!this.rateLimiter.canMakeRequest(this.credentials.site_url)) {
      throw new Error('Rate limit exceeded for WordPress site');
    }

    const url = `${this.credentials.api_base_url}${endpoint}`;
    const auth = btoa(`${this.credentials.username}:${this.credentials.app_password}`);

    const options: RequestInit = {
      method,
      headers: {
        'Authorization': `Basic ${auth}`,
        'Content-Type': 'application/json',
        'User-Agent': 'Agentopia/1.0'
      }
    };

    if (body && method !== 'GET') {
      options.body = JSON.stringify(body);
    }

    const response = await fetch(url, options);

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`WordPress API error (${response.status}): ${errorText}`);
    }

    return await response.json();
  }

  /**
   * Posts Management
   */
  async getPosts(params: {
    per_page?: number;
    page?: number;
    search?: string;
    status?: string;
  } = {}): Promise<any[]> {
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        queryParams.append(key, value.toString());
      }
    });

    const endpoint = `/posts?${queryParams.toString()}`;
    return await this.makeRequest(endpoint);
  }

  async getPost(id: number): Promise<any> {
    return await this.makeRequest(`/posts/${id}`);
  }

  async createPost(post: {
    title: string;
    content: string;
    status?: string;
    categories?: number[];
    tags?: number[];
  }): Promise<any> {
    return await this.makeRequest('/posts', 'POST', post);
  }

  async updatePost(id: number, post: Partial<{
    title: string;
    content: string;
    status: string;
    categories: number[];
    tags: number[];
  }>): Promise<any> {
    return await this.makeRequest(`/posts/${id}`, 'POST', post);
  }

  async deletePost(id: number): Promise<any> {
    return await this.makeRequest(`/posts/${id}`, 'DELETE');
  }

  /**
   * Pages Management
   */
  async getPages(params: {
    per_page?: number;
    page?: number;
    search?: string;
    status?: string;
  } = {}): Promise<any[]> {
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        queryParams.append(key, value.toString());
      }
    });

    const endpoint = `/pages?${queryParams.toString()}`;
    return await this.makeRequest(endpoint);
  }

  async createPage(page: {
    title: string;
    content: string;
    status?: string;
    parent?: number;
  }): Promise<any> {
    return await this.makeRequest('/pages', 'POST', page);
  }

  /**
   * Media Management
   */
  async getMedia(params: {
    per_page?: number;
    page?: number;
    media_type?: string;
  } = {}): Promise<any[]> {
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        queryParams.append(key, value.toString());
      }
    });

    const endpoint = `/media?${queryParams.toString()}`;
    return await this.makeRequest(endpoint);
  }

  async uploadMedia(file: {
    filename: string;
    content: string;
    contentType: string;
  }): Promise<any> {
    // WordPress media upload requires multipart/form-data
    // This would need special handling for file uploads
    throw new Error('Media upload not yet implemented');
  }

  /**
   * Users Management
   */
  async getUsers(params: {
    per_page?: number;
    page?: number;
    search?: string;
    roles?: string[];
  } = {}): Promise<any[]> {
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        if (Array.isArray(value)) {
          queryParams.append(key, value.join(','));
        } else {
          queryParams.append(key, value.toString());
        }
      }
    });

    const endpoint = `/users?${queryParams.toString()}`;
    return await this.makeRequest(endpoint);
  }

  async getCurrentUser(): Promise<any> {
    return await this.makeRequest('/users/me');
  }

  /**
   * Categories and Tags
   */
  async getCategories(): Promise<any[]> {
    return await this.makeRequest('/categories');
  }

  async getTags(): Promise<any[]> {
    return await this.makeRequest('/tags');
  }

  async createCategory(category: {
    name: string;
    description?: string;
    parent?: number;
  }): Promise<any> {
    return await this.makeRequest('/categories', 'POST', category);
  }

  /**
   * Comments Management
   */
  async getComments(params: {
    post?: number;
    per_page?: number;
    page?: number;
    status?: string;
  } = {}): Promise<any[]> {
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        queryParams.append(key, value.toString());
      }
    });

    const endpoint = `/comments?${queryParams.toString()}`;
    return await this.makeRequest(endpoint);
  }

  async updateComment(id: number, comment: {
    status?: string;
    content?: string;
  }): Promise<any> {
    return await this.makeRequest(`/comments/${id}`, 'POST', comment);
  }

  /**
   * Site Settings (requires manage_options capability)
   */
  async getSettings(): Promise<any> {
    return await this.makeRequest('/settings');
  }

  async updateSettings(settings: Record<string, any>): Promise<any> {
    return await this.makeRequest('/settings', 'POST', settings);
  }
}
```

### 3. Rate Limiting Implementation

```typescript
class WordPressRateLimiter {
  private requests: Map<string, number[]> = new Map();
  private readonly maxRequestsPerMinute = 60;
  private readonly maxConcurrentRequests = 5;
  private activeRequests: Map<string, number> = new Map();

  canMakeRequest(siteUrl: string): boolean {
    const now = Date.now();
    
    // Check concurrent requests
    const active = this.activeRequests.get(siteUrl) || 0;
    if (active >= this.maxConcurrentRequests) {
      return false;
    }

    // Check rate limit
    const requests = this.requests.get(siteUrl) || [];
    const recentRequests = requests.filter(time => now - time < 60000);
    
    if (recentRequests.length >= this.maxRequestsPerMinute) {
      return false;
    }

    // Update tracking
    recentRequests.push(now);
    this.requests.set(siteUrl, recentRequests);
    this.activeRequests.set(siteUrl, active + 1);

    return true;
  }

  requestCompleted(siteUrl: string): void {
    const active = this.activeRequests.get(siteUrl) || 0;
    this.activeRequests.set(siteUrl, Math.max(0, active - 1));
  }
}
```

### 4. Action Router Implementation

```typescript
async function executeWordPressOperation(
  action: string, 
  params: any, 
  credentials: WordPressCredentials
): Promise<any> {
  const client = new WordPressAPIClient(credentials);

  try {
    switch (action) {
      // Posts
      case 'get_posts':
        return await client.getPosts(params);
      case 'get_post':
        return await client.getPost(params.id);
      case 'create_post':
        return await client.createPost(params);
      case 'update_post':
        return await client.updatePost(params.id, params);
      case 'delete_post':
        return await client.deletePost(params.id);

      // Pages
      case 'get_pages':
        return await client.getPages(params);
      case 'create_page':
        return await client.createPage(params);

      // Media
      case 'get_media':
        return await client.getMedia(params);
      case 'upload_media':
        return await client.uploadMedia(params);

      // Users
      case 'get_users':
        return await client.getUsers(params);
      case 'get_current_user':
        return await client.getCurrentUser();

      // Taxonomies
      case 'get_categories':
        return await client.getCategories();
      case 'get_tags':
        return await client.getTags();
      case 'create_category':
        return await client.createCategory(params);

      // Comments
      case 'get_comments':
        return await client.getComments(params);
      case 'update_comment':
        return await client.updateComment(params.id, params);

      // Settings
      case 'get_settings':
        return await client.getSettings();
      case 'update_settings':
        return await client.updateSettings(params);

      default:
        throw new Error(`Unknown WordPress action: ${action}`);
    }
  } finally {
    // Ensure rate limiter is updated
    client.rateLimiter?.requestCompleted(credentials.site_url);
  }
}
```

### 5. Credential Management

```typescript
async function getWordPressCredentials(
  supabase: any, 
  userId: string, 
  connectionId: string
): Promise<WordPressCredentials> {
  // Get connection record
  const { data: connection, error } = await supabase
    .from('user_integration_credentials')
    .select(`
      *,
      service_providers!inner(name, configuration_metadata)
    `)
    .eq('id', connectionId)
    .eq('user_id', userId)
    .single();

  if (error || !connection) {
    throw new Error('WordPress connection not found');
  }

  if (connection.service_providers.name !== 'wordpress') {
    throw new Error('Invalid connection type');
  }

  // Decrypt application password from vault
  const { data: appPassword, error: vaultError } = await supabase.rpc(
    'vault_decrypt',
    { vault_id: connection.vault_access_token_id }
  );

  if (vaultError || !appPassword) {
    throw new Error('Failed to decrypt WordPress credentials');
  }

  const metadata = connection.connection_metadata;
  
  return {
    site_url: metadata.site_url,
    username: metadata.username,
    app_password: appPassword,
    api_base_url: metadata.api_base_url
  };
}
```

### 6. Permission Validation

```typescript
async function validateWordPressPermissions(
  supabase: any,
  agentId: string,
  userId: string,
  action: string
): Promise<boolean> {
  // Map actions to required capabilities
  const actionCapabilities: Record<string, string[]> = {
    'get_posts': ['read'],
    'create_post': ['write'],
    'update_post': ['write'],
    'delete_post': ['delete'],
    'get_settings': ['manage_options'],
    'update_settings': ['manage_options'],
    'get_users': ['manage_users'],
    // ... more mappings
  };

  const requiredCapabilities = actionCapabilities[action] || ['read'];

  // Check agent permissions
  const { data: permissions, error } = await supabase
    .from('agent_integration_permissions')
    .select('allowed_scopes')
    .eq('agent_id', agentId)
    .eq('is_active', true)
    .single();

  if (error || !permissions) {
    return false;
  }

  const allowedScopes = permissions.allowed_scopes || [];
  return requiredCapabilities.every(cap => allowedScopes.includes(cap));
}
```

## Integration with Agentopia Architecture

### 1. Follows Established Patterns
- **Edge Function Structure**: Consistent with Gmail, Stripe patterns
- **Vault Integration**: Uses existing credential management
- **Permission System**: Leverages agent permission framework
- **Error Handling**: Standard error response format

### 2. WordPress-Specific Enhancements
- **Multi-Site Support**: Each connection to different WordPress site
- **Capability Mapping**: WordPress capabilities to Agentopia permissions
- **Rate Limiting**: WordPress-specific rate limiting
- **API Versioning**: Support for different WordPress versions

### 3. Security Considerations
- **HTTPS Enforcement**: All WordPress connections must use HTTPS
- **Credential Encryption**: Application passwords stored in vault
- **Permission Validation**: Action-level permission checking
- **Request Validation**: Input sanitization and validation

## Performance Optimizations

### 1. Caching Strategy
- Cache frequently accessed data (categories, tags, user info)
- Implement cache invalidation on content updates
- Use connection-level caching for site metadata

### 2. Batch Operations
- Support batch post creation/updates
- Bulk media operations
- Batch comment moderation

### 3. Connection Pooling
- Reuse connections for multiple requests
- Connection health monitoring
- Automatic reconnection on failures

## Error Handling and Logging

### 1. Comprehensive Error Types
```typescript
enum WordPressErrorType {
  AUTHENTICATION_FAILED = 'authentication_failed',
  PERMISSION_DENIED = 'permission_denied',
  RATE_LIMITED = 'rate_limited',
  SITE_UNAVAILABLE = 'site_unavailable',
  INVALID_REQUEST = 'invalid_request',
  WORDPRESS_ERROR = 'wordpress_error'
}
```

### 2. Structured Logging
```typescript
function logWordPressOperation(
  userId: string,
  agentId: string,
  siteUrl: string,
  action: string,
  success: boolean,
  error?: string
) {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    service: 'wordpress-api',
    user_id: userId,
    agent_id: agentId,
    site_url: sanitizeUrl(siteUrl),
    action,
    success,
    error,
    duration_ms: Date.now() - startTime
  }));
}
```

## Conclusion

The WordPress API client architecture provides:

1. **Comprehensive API Coverage**: Full WordPress REST API support
2. **Security**: Vault-based credential management with HTTPS enforcement
3. **Performance**: Rate limiting, caching, and connection optimization
4. **Reliability**: Comprehensive error handling and retry logic
5. **Extensibility**: Easy to add new WordPress endpoints and capabilities
6. **Consistency**: Follows established Agentopia patterns

This architecture ensures secure, performant, and maintainable WordPress integration while providing agents with comprehensive WordPress management capabilities.
