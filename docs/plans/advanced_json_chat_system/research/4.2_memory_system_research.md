# Research: Memory System Implementation

## Task: 4.2 Memory System

### Research Objective
Implement the multi-tiered memory management system for agents, including episodic memory (conversation history), semantic memory (knowledge base), procedural memory (learned patterns), and working memory (temporary context).

## Memory Architecture Overview

### Four-Tier Memory System

#### 1. Episodic Memory
- **Purpose**: Stores conversation history and experiences
- **Duration**: Session-based with configurable retention
- **Storage**: PostgreSQL + Vector embeddings
- **Access Pattern**: Chronological with recency bias

#### 2. Semantic Memory
- **Purpose**: Stores factual knowledge and concepts
- **Duration**: Long-term persistent
- **Storage**: Vector database (Pinecone) + Knowledge graph
- **Access Pattern**: Similarity-based retrieval

#### 3. Procedural Memory
- **Purpose**: Stores learned patterns and behaviors
- **Duration**: Persistent with decay
- **Storage**: PostgreSQL with pattern analysis
- **Access Pattern**: Context-triggered activation

#### 4. Working Memory
- **Purpose**: Temporary processing space
- **Duration**: Current conversation only
- **Storage**: In-memory with Redis backup
- **Access Pattern**: LIFO with capacity limits

## Memory Storage Research

### Database Schema Design

#### Agent Memories Table
```sql
CREATE TABLE agent_memories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    agent_id UUID NOT NULL REFERENCES agents(id),
    memory_type memory_type_enum NOT NULL,
    content JSONB NOT NULL,
    embedding VECTOR(1536), -- OpenAI embedding
    metadata JSONB,
    relevance_score FLOAT,
    access_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now(),
    expires_at TIMESTAMPTZ,
    
    -- Indexes for performance
    INDEX idx_agent_memories_agent_id (agent_id),
    INDEX idx_agent_memories_type (memory_type),
    INDEX idx_agent_memories_created (created_at DESC),
    INDEX idx_agent_memories_embedding USING ivfflat (embedding vector_cosine_ops)
);

CREATE TYPE memory_type_enum AS ENUM (
    'episodic',
    'semantic', 
    'procedural',
    'working'
);
```

#### Memory Relationships Table
```sql
CREATE TABLE memory_relationships (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_memory_id UUID NOT NULL REFERENCES agent_memories(id),
    target_memory_id UUID NOT NULL REFERENCES agent_memories(id),
    relationship_type TEXT NOT NULL,
    strength FLOAT NOT NULL DEFAULT 1.0,
    created_at TIMESTAMPTZ DEFAULT now(),
    
    UNIQUE(source_memory_id, target_memory_id, relationship_type)
);
```

### Vector Database Integration (Pinecone)

#### Index Structure
```typescript
interface PineconeMemoryRecord {
  id: string;
  values: number[]; // 1536-dim embedding
  metadata: {
    agent_id: string;
    memory_type: 'episodic' | 'semantic' | 'procedural' | 'working';
    content: string;
    timestamp: string;
    relevance_score: number;
    tags: string[];
    conversation_id?: string;
    message_id?: string;
  };
}
```

#### Namespace Strategy
- `memories-{agent_id}`: Agent-specific memories
- `shared-knowledge`: Cross-agent knowledge
- `templates`: Memory templates and patterns

### Redis Cache Layer

#### Working Memory Cache
```typescript
interface WorkingMemoryCache {
  agent_id: string;
  session_id: string;
  memories: {
    id: string;
    content: any;
    relevance: number;
    timestamp: number;
  }[];
  capacity: number; // Max memories in working set
  ttl: number; // Time to live in seconds
}
```

## Memory Operations Research

### Memory Creation

#### Automatic Memory Formation
```typescript
interface MemoryFormationTrigger {
  trigger_type: 'conversation_end' | 'significant_event' | 'pattern_detected' | 'manual';
  content_source: 'message' | 'conversation' | 'tool_result' | 'external';
  importance_threshold: number;
  consolidation_rules: ConsolidationRule[];
}
```

#### Memory Consolidation
- **Real-time**: Immediate storage of working memory
- **Batch**: Periodic consolidation of episodic to semantic
- **Pattern Detection**: Automatic procedural memory creation
- **Decay**: Automatic removal of low-relevance memories

### Memory Retrieval

#### Retrieval Strategies
1. **Semantic Search**: Vector similarity for content matching
2. **Temporal Search**: Recent memories with decay
3. **Contextual Search**: Related to current conversation
4. **Pattern Search**: Procedural memories for similar situations

#### Hybrid Retrieval Algorithm
```typescript
interface RetrievalRequest {
  query: string;
  agent_id: string;
  memory_types: MemoryType[];
  max_results: number;
  min_relevance: number;
  temporal_weight: number; // 0-1, recency importance
  context_window: number; // Recent messages to consider
}

interface RetrievalResult {
  memories: Memory[];
  relevance_scores: number[];
  retrieval_method: string;
  total_searched: number;
  query_time_ms: number;
}
```

### Memory Maintenance

#### Consolidation Process
```typescript
interface ConsolidationJob {
  agent_id: string;
  source_type: MemoryType;
  target_type: MemoryType;
  rules: {
    min_access_count: number;
    min_age_hours: number;
    similarity_threshold: number;
    importance_threshold: number;
  };
  schedule: 'hourly' | 'daily' | 'weekly';
}
```

#### Memory Decay
- **Access-based**: Memories with low access frequency decay
- **Time-based**: Old memories gradually lose relevance
- **Importance-based**: High-importance memories resist decay
- **Relationship-based**: Connected memories reinforce each other

## Implementation Patterns

### Repository Pattern
```typescript
interface MemoryRepository {
  // CRUD operations
  create(memory: CreateMemoryRequest): Promise<Memory>;
  findById(id: string): Promise<Memory | null>;
  findByAgent(agentId: string, filters: MemoryFilters): Promise<Memory[]>;
  update(id: string, updates: Partial<Memory>): Promise<Memory>;
  delete(id: string): Promise<boolean>;
  
  // Advanced operations
  search(query: RetrievalRequest): Promise<RetrievalResult>;
  consolidate(job: ConsolidationJob): Promise<ConsolidationResult>;
  maintain(agentId: string): Promise<MaintenanceResult>;
}
```

### Factory Pattern
```typescript
interface MemoryFactory {
  createFromMessage(message: AdvancedChatMessage, importance: number): Promise<Memory>;
  createFromConversation(messages: AdvancedChatMessage[]): Promise<Memory[]>;
  createFromPattern(pattern: DetectedPattern): Promise<Memory>;
  createFromTool(toolResult: ToolResult, context: string): Promise<Memory>;
}
```

### Observer Pattern
```typescript
interface MemoryObserver {
  onMemoryCreated(memory: Memory): Promise<void>;
  onMemoryAccessed(memory: Memory): Promise<void>;
  onMemoryConsolidated(source: Memory, target: Memory): Promise<void>;
  onMemoryDecayed(memory: Memory): Promise<void>;
}
```

## Advanced Memory Features

### Memory Graphs
```typescript
interface MemoryGraph {
  nodes: Map<string, Memory>;
  edges: Map<string, MemoryRelationship[]>;
  
  // Graph operations
  findRelated(memoryId: string, depth: number): Memory[];
  findPath(sourceId: string, targetId: string): Memory[];
  detectClusters(): MemoryCluster[];
  calculateCentrality(memoryId: string): number;
}
```

### Memory Templates
```typescript
interface MemoryTemplate {
  id: string;
  name: string;
  pattern: string; // Regex or pattern matching
  memory_type: MemoryType;
  importance_modifier: number;
  metadata_extractors: MetadataExtractor[];
  consolidation_rules: ConsolidationRule[];
}
```

### Memory Compression
```typescript
interface MemoryCompressor {
  compress(memories: Memory[]): CompressedMemory;
  decompress(compressed: CompressedMemory): Memory[];
  calculateCompressionRatio(original: Memory[], compressed: CompressedMemory): number;
}
```

## Performance Optimizations

### Caching Strategy
1. **L1 Cache**: In-memory working memory (Redis)
2. **L2 Cache**: Recent episodic memories (Redis)
3. **L3 Cache**: Frequently accessed semantic memories (Redis)
4. **Cold Storage**: Archived memories (PostgreSQL)

### Indexing Strategy
```sql
-- Composite indexes for common queries
CREATE INDEX idx_memories_agent_type_time ON agent_memories(agent_id, memory_type, created_at DESC);
CREATE INDEX idx_memories_relevance ON agent_memories(relevance_score DESC) WHERE relevance_score > 0.5;
CREATE INDEX idx_memories_access ON agent_memories(access_count DESC, last_accessed DESC);

-- Partial indexes for active memories
CREATE INDEX idx_active_memories ON agent_memories(agent_id, memory_type) 
WHERE expires_at IS NULL OR expires_at > now();
```

### Query Optimization
```typescript
interface OptimizedQuery {
  // Use prepared statements
  prepared: boolean;
  
  // Limit result sets
  pagination: {
    limit: number;
    offset: number;
  };
  
  // Filter at database level
  filters: {
    agent_id: string;
    memory_types: MemoryType[];
    date_range?: [Date, Date];
    min_relevance?: number;
  };
  
  // Projection to reduce data transfer
  select: string[];
}
```

## Integration Points

### Message Processor Integration
```typescript
// In MessageProcessor
class EnrichmentStage {
  async process(message: AdvancedChatMessage): Promise<AdvancedChatMessage> {
    // Retrieve relevant memories
    const memories = await this.memoryManager.retrieve({
      query: message.content.text,
      agent_id: message.context.agent_id,
      memory_types: ['episodic', 'semantic'],
      max_results: 10,
    });
    
    // Add to message context
    message.context.relevant_memories = memories.map(m => m.id);
    message.memory = memories.map(m => ({ memory_id: m.id }));
    
    return message;
  }
}
```

### Context Engine Integration
```typescript
// Context building with memory
class ContextEngine {
  async buildMessageContext(message: AdvancedChatMessage): Promise<MessageContext> {
    const memories = await this.memoryManager.getByIds(
      message.memory?.map(m => m.memory_id) || []
    );
    
    return {
      ...message.context,
      memory_context: this.formatMemoriesForContext(memories),
      memory_score: this.calculateMemoryRelevance(memories),
    };
  }
}
```

### State Manager Integration
```typescript
// Memory-aware state management
class StateManager {
  async updateState(agentId: string, newState: any): Promise<void> {
    // Update state
    await this.updateAgentState(agentId, newState);
    
    // Create procedural memory from state changes
    if (this.isSignificantChange(newState)) {
      await this.memoryManager.createFromState(agentId, newState);
    }
  }
}
```

## Error Handling & Resilience

### Memory Corruption Recovery
```typescript
interface MemoryRecovery {
  detectCorruption(memory: Memory): CorruptionReport;
  attemptRepair(memory: Memory): RepairResult;
  quarantineMemory(memory: Memory): Promise<void>;
  restoreFromBackup(memoryId: string): Promise<Memory>;
}
```

### Fallback Strategies
1. **Vector DB Failure**: Fall back to PostgreSQL full-text search
2. **Cache Failure**: Direct database queries with performance warning
3. **Embedding Failure**: Use stored embeddings or text similarity
4. **Memory Overflow**: Automatic cleanup of least important memories

## Testing Strategy

### Unit Tests
```typescript
describe('MemoryManager', () => {
  test('creates episodic memory from message', async () => {
    const memory = await memoryManager.createFromMessage(message);
    expect(memory.memory_type).toBe('episodic');
    expect(memory.content.message_id).toBe(message.id);
  });
  
  test('retrieves relevant memories', async () => {
    const results = await memoryManager.retrieve({
      query: 'test query',
      agent_id: 'agent-1',
      memory_types: ['semantic'],
    });
    
    expect(results.memories.length).toBeGreaterThan(0);
    expect(results.relevance_scores[0]).toBeGreaterThan(0.5);
  });
});
```

### Integration Tests
```typescript
describe('Memory Integration', () => {
  test('end-to-end memory workflow', async () => {
    // Create message
    const message = createTestMessage();
    
    // Process through pipeline (should create memories)
    await messageProcessor.process(createChatRequest(message));
    
    // Verify memory creation
    const memories = await memoryManager.findByAgent(message.context.agent_id);
    expect(memories.length).toBeGreaterThan(0);
    
    // Test retrieval in next message
    const nextMessage = createFollowUpMessage();
    const response = await messageProcessor.process(createChatRequest(nextMessage));
    
    // Verify memory was used
    expect(response.data.message.context.relevant_memories).toBeDefined();
  });
});
```

### Performance Tests
```typescript
describe('Memory Performance', () => {
  test('retrieval under load', async () => {
    const startTime = Date.now();
    
    // Concurrent retrievals
    const promises = Array(100).fill(0).map(() => 
      memoryManager.retrieve({
        query: 'performance test',
        agent_id: 'test-agent',
        max_results: 10,
      })
    );
    
    await Promise.all(promises);
    
    const duration = Date.now() - startTime;
    expect(duration).toBeLessThan(5000); // Under 5 seconds
  });
});
```

## Security & Privacy

### Data Protection
- **Encryption**: All memories encrypted at rest
- **Access Control**: Agent-specific memory isolation
- **Audit Trail**: All memory operations logged
- **Retention**: Configurable memory expiration

### Privacy Compliance
- **Data Minimization**: Only store necessary information
- **Right to Deletion**: Complete memory removal capability
- **Anonymization**: Remove PII from consolidated memories
- **Consent**: User control over memory persistence

## Monitoring & Observability

### Memory Metrics
```typescript
interface MemoryMetrics {
  // Performance metrics
  retrieval_latency_ms: number;
  creation_latency_ms: number;
  consolidation_time_ms: number;
  
  // Usage metrics
  memories_created_per_hour: number;
  memories_accessed_per_hour: number;
  cache_hit_ratio: number;
  
  // Health metrics
  memory_corruption_rate: number;
  consolidation_success_rate: number;
  storage_utilization: number;
}
```

### Alerting
- Memory corruption detected
- High retrieval latency
- Storage capacity warnings
- Consolidation failures

## Implementation Phases

### Phase 1: Core Infrastructure
1. Database schema creation
2. Basic CRUD operations
3. Vector database integration
4. Memory factory implementation

### Phase 2: Retrieval System
1. Semantic search implementation
2. Hybrid retrieval algorithm
3. Caching layer
4. Performance optimization

### Phase 3: Advanced Features
1. Memory consolidation
2. Relationship tracking
3. Pattern detection
4. Memory graphs

### Phase 4: Integration & Testing
1. Message processor integration
2. Context engine integration
3. Comprehensive testing
4. Performance tuning

## References
- [Vector Databases for Memory Systems](https://www.pinecone.io/learn/vector-database/)
- [PostgreSQL Vector Extensions](https://github.com/pgvector/pgvector)
- [Memory Consolidation in AI Systems](https://arxiv.org/abs/2010.06891)
- [Efficient Similarity Search](https://arxiv.org/abs/1603.09320)
- [Redis Memory Optimization](https://redis.io/docs/manual/memory-optimization/)
- [Graph-based Memory Models](https://www.nature.com/articles/s41467-021-24760-8)