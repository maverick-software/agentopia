# Research: Type Definitions for Advanced JSON Chat System

## Task: 3.1 Type Definitions

### Research Objective
Create comprehensive TypeScript type definitions for the advanced JSON-based chat system that supports memory injection, state management, and extensible context handling.

## Research Findings

### 1. Current Type System Analysis
- **Existing types.ts**: Contains MCP-specific types, not chat message types
- **ChatMessage interface**: Simple structure with role, content, timestamp, agentName
- **Limitations**: No metadata, no structured content, no memory references, no state management

### 2. Industry Best Practices

#### OpenAI Structured Outputs
- JSON schema validation at API level
- Strict mode for guaranteed compliance
- Native SDK support (Pydantic/Zod)
- Refusal detection capabilities

#### Message Structure Standards
- **Anthropic Claude**: Uses XML-like structuring in prompts
- **OpenAI**: JSON with strict schemas
- **Google Gemini**: Supports both JSON and protobuf
- **Best Practice**: Version-aware schemas with backward compatibility

#### Memory Architecture Patterns
- **Episodic**: Event-based with temporal decay (MemInsight approach)
- **Semantic**: Knowledge graphs with embeddings
- **Procedural**: Skill tracking with performance metrics
- **Working**: LRU cache with priority queue

### 3. Technical Requirements

#### Type Safety
- Full TypeScript strict mode compliance
- Runtime validation capabilities
- Type guards for all structures
- Exhaustive discriminated unions

#### Extensibility
- Version fields in all major types
- Optional fields for future additions
- Generic type parameters where appropriate
- Plugin-ready architecture

#### Performance
- Token tracking in all content types
- Compression metadata support
- Lazy loading indicators
- Cache-friendly structures

### 4. Implementation Strategy

#### Core Types Needed
1. **Message Types**
   - AdvancedChatMessage (main structure)
   - MessageContent (flexible content)
   - MessageMetadata (performance, quality)
   - MessageContext (conversation, semantic)

2. **Memory Types**
   - MemoryBank (container)
   - EpisodicMemory (events)
   - SemanticMemory (knowledge)
   - ProceduralMemory (skills)
   - WorkingMemory (active)

3. **State Types**
   - AgentState (complete state)
   - LocalState (agent-specific)
   - SharedState (cross-agent)
   - SessionState (active session)
   - PersistentState (long-term)

4. **Context Types**
   - ContextWindow (token management)
   - ContextSegment (prioritized content)
   - CompressionStrategy (optimization)
   - OptimizationSettings (configuration)

#### Type Guards Strategy
- One guard per major interface
- Composite validators for requests
- Deep validation capabilities
- Performance-conscious implementation

#### Utility Functions
- ID generation (UUID v4)
- Timestamp utilities
- Token estimation
- State delta creation
- Memory ranking algorithms

### 5. Integration Considerations

#### Database Compatibility
- JSONB-friendly structures
- Indexed field identification
- Migration-aware versioning
- Efficient querying patterns

#### API Compatibility
- OpenAI function calling format
- MCP tool integration
- Streaming support indicators
- Error response standards

#### Vector Database Integration
- Embedding fields in memories
- Metadata for filtering
- Similarity score tracking
- Chunking indicators

### 6. Implementation Order
1. Create base message types
2. Add memory type definitions
3. Implement state structures
4. Design context types
5. Create type guards
6. Build utility functions
7. Export central index

### 7. Testing Strategy
- Unit tests for type guards
- Integration tests for utilities
- Performance tests for token counting
- Validation tests for schemas

## Recommendations

1. **Start with message types** as they're the foundation
2. **Use discriminated unions** for type safety
3. **Include version fields** in all major structures
4. **Create comprehensive type guards** for runtime safety
5. **Document extensively** within the types
6. **Consider future migrations** in the design

## References
- OpenAI Structured Outputs documentation
- TypeScript handbook on advanced types
- JSON Schema specification
- Research on memory architectures in AI systems