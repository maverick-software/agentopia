# Research: Database Schema Updates

## Task: 2.2 Database Schema Updates

### Research Objective
Design comprehensive database schema updates to support the advanced JSON-based chat system with memory management, state persistence, and structured message storage.

## Current Database Analysis

### Existing Schema Overview
Based on current system analysis and database documentation:

#### Current Tables
1. **chat_messages**
   - channel_id: uuid
   - content: text
   - sender_user_id: uuid
   - sender_agent_id: uuid
   - created_at: timestamp
   - **Limitations**: No metadata, no versioning, no structure

2. **agents**
   - id: uuid
   - name: text
   - system_instructions: text
   - assistant_instructions: text
   - personality: text
   - **Limitations**: No state storage, no memory configuration

3. **workspaces**
   - id: uuid
   - name: text
   - context_window_size: integer
   - context_window_token_limit: integer
   - **Limitations**: Basic configuration only

4. **agent_datastores**
   - agent_id: uuid
   - datastore_id: uuid
   - **Purpose**: Links agents to vector stores

### PostgreSQL Capabilities
- **JSONB Support**: Native JSON storage with indexing
- **Vector Extension**: pgvector for embeddings
- **UUID Support**: Built-in UUID generation
- **Triggers**: For automatic timestamps and validation
- **Partitioning**: For large tables (future consideration)

## Schema Design Requirements

### 1. Message Storage Requirements
- **Versioning**: Track message edits and versions
- **Metadata**: Store performance metrics, tokens, confidence
- **Structure**: Support different content types
- **Audit Trail**: Compliance and debugging
- **Relationships**: Link to memories, state snapshots

### 2. Memory Storage Requirements
- **Multi-Type**: Episodic, semantic, procedural, working
- **Vector Storage**: Embeddings for similarity search
- **Decay Tracking**: Importance and access patterns
- **Relationships**: Memory connections and hierarchies
- **Compression**: Handle large memory banks

### 3. State Storage Requirements
- **Versioning**: Track state evolution
- **Checkpointing**: Recovery points
- **Partitioning**: Local vs shared state
- **Delta Storage**: Efficient change tracking
- **Validation**: Schema compliance

### 4. Context Storage Requirements
- **Snapshots**: Point-in-time context saves
- **Compression**: Token optimization records
- **Analytics**: Performance tracking
- **Templates**: Reusable context patterns

## Proposed Schema Design

### Core Message Tables

#### 1. chat_messages_v2
```sql
CREATE TABLE chat_messages_v2 (
  -- Identification
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  version VARCHAR(10) NOT NULL DEFAULT '1.0.0',
  conversation_id UUID NOT NULL,
  session_id UUID NOT NULL,
  
  -- Relationships
  parent_message_id UUID REFERENCES chat_messages_v2(id),
  channel_id UUID REFERENCES channels(id),
  
  -- Actors
  sender_user_id UUID REFERENCES users(id),
  sender_agent_id UUID REFERENCES agents(id),
  
  -- Content
  role VARCHAR(20) NOT NULL CHECK (role IN ('system', 'user', 'assistant', 'tool')),
  content JSONB NOT NULL,
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  
  -- Context
  context JSONB DEFAULT '{}',
  
  -- Optional Components
  tools JSONB,
  memory_refs UUID[],
  state_snapshot_id UUID,
  
  -- Audit
  audit JSONB,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Indexes
  CONSTRAINT check_content_structure CHECK (
    content ? 'type' AND 
    content->>'type' IN ('text', 'structured', 'multimodal', 'tool_result')
  )
);

-- Indexes
CREATE INDEX idx_messages_conversation ON chat_messages_v2(conversation_id, created_at);
CREATE INDEX idx_messages_session ON chat_messages_v2(session_id);
CREATE INDEX idx_messages_channel ON chat_messages_v2(channel_id);
CREATE INDEX idx_messages_content_gin ON chat_messages_v2 USING gin(content);
CREATE INDEX idx_messages_metadata_gin ON chat_messages_v2 USING gin(metadata);
```

#### 2. message_versions
```sql
CREATE TABLE message_versions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  message_id UUID NOT NULL REFERENCES chat_messages_v2(id) ON DELETE CASCADE,
  version_number INTEGER NOT NULL,
  content JSONB NOT NULL,
  metadata JSONB,
  changed_by UUID REFERENCES users(id),
  change_reason TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(message_id, version_number)
);
```

### Memory Storage Tables

#### 3. agent_memories
```sql
CREATE TABLE agent_memories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  memory_type VARCHAR(20) NOT NULL CHECK (memory_type IN ('episodic', 'semantic', 'procedural', 'working')),
  
  -- Content (type-specific)
  content JSONB NOT NULL,
  
  -- Vector embedding
  embeddings VECTOR(1536),
  
  -- Metrics
  importance FLOAT DEFAULT 0.5 CHECK (importance >= 0 AND importance <= 1),
  decay_rate FLOAT DEFAULT 0.1,
  access_count INTEGER DEFAULT 0,
  
  -- Relationships
  related_memories UUID[],
  source_message_id UUID REFERENCES chat_messages_v2(id),
  
  -- Timestamps
  last_accessed TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  -- Indexes for different memory types
  CONSTRAINT check_memory_content CHECK (
    CASE memory_type
      WHEN 'episodic' THEN content ? 'event' AND content ? 'temporal'
      WHEN 'semantic' THEN content ? 'concept' AND content ? 'definition'
      WHEN 'procedural' THEN content ? 'skill' AND content ? 'steps'
      WHEN 'working' THEN content ? 'items' AND content ? 'capacity'
      ELSE false
    END
  )
);

-- Indexes
CREATE INDEX idx_memories_agent_type ON agent_memories(agent_id, memory_type);
CREATE INDEX idx_memories_importance ON agent_memories(importance DESC);
CREATE INDEX idx_memories_embedding ON agent_memories USING ivfflat (embeddings vector_cosine_ops);
CREATE INDEX idx_memories_content_gin ON agent_memories USING gin(content);
```

#### 4. memory_consolidations
```sql
CREATE TABLE memory_consolidations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  source_memories UUID[] NOT NULL,
  consolidated_memory_id UUID REFERENCES agent_memories(id),
  consolidation_type VARCHAR(20) CHECK (consolidation_type IN ('merge', 'summarize', 'abstract')),
  tokens_saved INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### State Management Tables

#### 5. agent_states
```sql
CREATE TABLE agent_states (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  version VARCHAR(10) NOT NULL,
  
  -- State partitions
  local_state JSONB NOT NULL DEFAULT '{}',
  shared_state JSONB DEFAULT '{}',
  session_state JSONB DEFAULT '{}',
  persistent_state JSONB NOT NULL DEFAULT '{}',
  
  -- Metadata
  state_hash VARCHAR(64) NOT NULL,
  modification_count INTEGER DEFAULT 0,
  
  -- Validity
  valid_from TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  valid_until TIMESTAMP WITH TIME ZONE,
  is_current BOOLEAN DEFAULT true,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_modified TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Ensure only one current state per agent
  CONSTRAINT unique_current_state UNIQUE(agent_id, is_current) WHERE is_current = true
);

-- Indexes
CREATE INDEX idx_states_agent_current ON agent_states(agent_id) WHERE is_current = true;
CREATE INDEX idx_states_valid_range ON agent_states(valid_from, valid_until);
```

#### 6. state_checkpoints
```sql
CREATE TABLE state_checkpoints (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  state_id UUID NOT NULL REFERENCES agent_states(id),
  
  -- Checkpoint details
  checkpoint_type VARCHAR(20) CHECK (checkpoint_type IN ('manual', 'automatic', 'error_recovery', 'milestone')),
  trigger_reason TEXT,
  
  -- Storage
  state_data JSONB NOT NULL,
  compression_type VARCHAR(10),
  size_bytes INTEGER,
  
  -- Recovery metrics
  restoration_time_ms INTEGER,
  restoration_count INTEGER DEFAULT 0,
  
  -- Retention
  retention_policy VARCHAR(20) CHECK (retention_policy IN ('temporary', 'permanent', 'archive')),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 7. state_transitions
```sql
CREATE TABLE state_transitions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  from_state_id UUID REFERENCES agent_states(id),
  to_state_id UUID NOT NULL REFERENCES agent_states(id),
  
  -- Transition details
  transition_type VARCHAR(20) CHECK (transition_type IN ('update', 'merge', 'reset', 'restore')),
  trigger VARCHAR(50),
  
  -- Changes
  changes JSONB NOT NULL,
  
  -- Rollback
  rollback_available BOOLEAN DEFAULT true,
  rollback_data JSONB,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Context Management Tables

#### 8. context_snapshots
```sql
CREATE TABLE context_snapshots (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  message_id UUID REFERENCES chat_messages_v2(id),
  agent_id UUID REFERENCES agents(id),
  
  -- Snapshot data
  snapshot_data JSONB NOT NULL,
  
  -- Metrics
  total_tokens INTEGER,
  compression_ratio FLOAT,
  segment_count INTEGER,
  
  -- Performance
  build_time_ms INTEGER,
  optimization_count INTEGER,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 9. context_templates
```sql
CREATE TABLE context_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  
  -- Template definition
  segments JSONB NOT NULL,
  variables JSONB,
  
  -- Metrics
  total_tokens INTEGER,
  use_count INTEGER DEFAULT 0,
  
  -- Applicability
  use_cases TEXT[],
  agent_types TEXT[],
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Supporting Tables

#### 10. conversation_sessions
```sql
CREATE TABLE conversation_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  conversation_id UUID NOT NULL,
  user_id UUID REFERENCES users(id),
  agent_id UUID REFERENCES agents(id),
  
  -- Session data
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  ended_at TIMESTAMP WITH TIME ZONE,
  last_active TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Metrics
  message_count INTEGER DEFAULT 0,
  total_tokens_used INTEGER DEFAULT 0,
  tool_calls_count INTEGER DEFAULT 0,
  
  -- State
  session_state JSONB DEFAULT '{}',
  interruption_context JSONB,
  
  -- Status
  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'paused', 'completed', 'abandoned'))
);
```

## Migration Strategy

### Phase 1: Parallel Tables
1. Create new v2 tables alongside existing
2. Implement dual-write in application
3. Backfill historical data
4. Validate data integrity

### Phase 2: Gradual Migration
1. Route reads to new tables progressively
2. Monitor performance and errors
3. Fix edge cases
4. Update dependent systems

### Phase 3: Cleanup
1. Stop writes to old tables
2. Final data migration
3. Update foreign key references
4. Archive old tables

### Migration Scripts Needed
1. **Data transformation**: Convert old messages to new format
2. **ID mapping**: Track old to new ID relationships
3. **Validation**: Ensure data integrity
4. **Rollback**: Scripts to revert if needed

## Performance Considerations

### Indexing Strategy
1. **Primary Access**: conversation_id, session_id
2. **Search**: Content GIN indexes for JSONB
3. **Vector Search**: IVFFlat for embeddings
4. **Time-based**: Created_at for history queries

### Partitioning Strategy (Future)
1. **Messages**: Partition by created_at (monthly)
2. **Memories**: Partition by agent_id
3. **States**: Archive old checkpoints

### Query Optimization
1. **Materialized Views**: For complex aggregations
2. **Caching**: Redis for hot data
3. **Read Replicas**: For analytics queries

## Security Considerations

### Access Control
1. **Row-Level Security**: Based on user_id/agent_id
2. **Column Encryption**: For sensitive data
3. **Audit Logging**: All modifications tracked

### Data Privacy
1. **PII Handling**: Separate encrypted storage
2. **Retention Policies**: Automatic expiration
3. **Right to Deletion**: Cascade deletes

## Monitoring Requirements

### Metrics to Track
1. **Table Growth**: Row counts and size
2. **Query Performance**: Slow query log
3. **Index Usage**: Unused indexes
4. **Memory Usage**: Working memory size

### Alerts
1. **Storage**: > 80% capacity
2. **Performance**: Queries > 1s
3. **Errors**: Constraint violations
4. **Growth**: Unusual spikes

## Implementation Order

1. **Core Tables First**
   - chat_messages_v2
   - conversation_sessions
   - Basic indexes

2. **Memory System**
   - agent_memories
   - Vector indexes
   - Consolidation tables

3. **State Management**
   - agent_states
   - Checkpoints
   - Transitions

4. **Supporting Tables**
   - Context snapshots
   - Templates
   - Analytics

## Testing Strategy

### Unit Tests
1. **Constraint Validation**: All CHECK constraints
2. **Trigger Functions**: Automatic updates
3. **Index Performance**: Query plans

### Integration Tests
1. **Migration Scripts**: Data transformation
2. **Dual-Write**: Consistency checks
3. **Rollback**: Recovery procedures

### Load Tests
1. **Concurrent Writes**: Message creation
2. **Vector Search**: Memory retrieval
3. **State Updates**: Checkpoint creation

## Risks and Mitigations

### Technical Risks
1. **Data Loss**: Comprehensive backups
2. **Performance**: Gradual rollout
3. **Compatibility**: Feature flags

### Operational Risks
1. **Downtime**: Blue-green deployment
2. **Rollback**: Tested procedures
3. **Monitoring**: Enhanced observability

## References
- PostgreSQL JSONB documentation
- pgvector extension guide
- Supabase migration best practices
- Previous migration experiences